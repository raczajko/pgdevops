define(["translations","pgadmin.browser.endpoints","pgadmin.browser.utils","pgadmin.browser.messages","pgadmin.user_management.current_user","pgadmin.server.supported_servers"], function(__WEBPACK_EXTERNAL_MODULE_44__, __WEBPACK_EXTERNAL_MODULE_45__, __WEBPACK_EXTERNAL_MODULE_77__, __WEBPACK_EXTERNAL_MODULE_96__, __WEBPACK_EXTERNAL_MODULE_194__, __WEBPACK_EXTERNAL_MODULE_272__) { return webpackJsonp([0,2,3],[
/* 0 */,
/* 1 */,
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(44)], __WEBPACK_AMD_DEFINE_RESULT__ = function (translations) {

  /***
   * This method behaves as a drop-in replacement for flask translation rendering.
   * It uses the same translation file under the hood and uses flask to determine the language.
   *
   * ex. translate("some %(adjective)s text", {adjective: "cool"})
   *
   * @param {String} text
   * @param {Object} substitutions
   */
  return function gettext(text, substitutions) {

    var rawTranslation = translations[text] ? translations[text] : text;

    // captures things of the form %(substitutionName)s
    var substitutionGroupsRegExp = /([^%]*)%\(([^\)]+)\)s(.*)/;
    var matchFound;

    var interpolated = rawTranslation;
    do {
      matchFound = false;
      interpolated = interpolated.replace(substitutionGroupsRegExp, function (_, textBeginning, substitutionName, textEnd) {
        matchFound = true;
        return textBeginning + substitutions[substitutionName] + textEnd;
      });
    } while (matchFound);

    return interpolated;
  };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (factory) {
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof module !== 'undefined' && module.exports) {
    // CommonJS
    module.exports = factory();
  } else {
    // Browser globals
    factory();
  }
})(function () {
  var pgAdmin = window.pgAdmin = window.pgAdmin || {};

  // Reference:
  // https://github.com/heygrady/Units/blob/master/Length.min.js
  // Changed it to save the function in pgAdmin object.
  (function (t, e, o) {
    "use strict";
    function r(t, e, r, p) {
      r = r || "width";var n,
          l,
          m,
          c = (e.match(s) || [])[2],
          f = "px" === c ? 1 : d[c + "toPx"],
          u = /r?em/i;if (f || u.test(c) && !p) t = f ? t : "rem" === c ? i : "fontSize" === r ? t.parentNode || t : t, f = f || parseFloat(a(t, "fontSize")), m = parseFloat(e) * f;else {
        n = t.style, l = n[r];try {
          n[r] = e;
        } catch (x) {
          return 0;
        }m = n[r] ? parseFloat(a(t, r)) : 0, n[r] = l !== o ? l : null;
      }return m;
    }function a(t, e) {
      var o,
          n,
          i,
          l,
          d,
          c = /^top|bottom/,
          f = ["paddingTop", "paddingBottom", "borderTop", "borderBottom"],
          u = 4;if (o = m ? m(t)[e] : (n = t.style["pixel" + e.charAt(0).toUpperCase() + e.slice(1)]) ? n + "px" : "fontSize" === e ? r(t, "1em", "left", 1) + "px" : t.currentStyle[e], i = (o.match(s) || [])[2], "%" === i && p) {
        if (c.test(e)) {
          for (l = (d = t.parentNode || t).offsetHeight; u--;) {
            l -= parseFloat(a(d, f[u]));
          }o = parseFloat(o) / 100 * l + "px";
        } else o = r(t, o);
      } else ("auto" === o || i && "px" !== i) && m ? o = 0 : i && "px" !== i && !m && (o = r(t, o) + "px");return o;
    }var p,
        n = e.createElement("test"),
        i = e.documentElement,
        l = e.defaultView,
        m = l && l.getComputedStyle,
        s = /^(-?[\d+\.\-]+)([a-z]+|%)$/i,
        d = {},
        c = [1 / 25.4, 1 / 2.54, 1 / 72, 1 / 6],
        f = ["mm", "cm", "pt", "pc", "in", "mozmm"],
        u = 6;for (i.appendChild(n), m && (n.style.marginTop = "1%", p = "1%" === m(n).marginTop); u--;) {
      d[f[u] + "toPx"] = c[u] ? c[u] * d.inToPx : r(n, "1" + f[u]);
    }i.removeChild(n), n = o, t.toPx = r;
  })(pgAdmin, window.document);

  // Reference:
  // https://github.com/javve/natural-sort/blob/master/index.js
  // Changed it to save the function in pgAdmin object.
  pgAdmin.natural_sort = function (a, b, options) {
    var re = /(^-?[0-9]+(\.?[0-9]*)[df]?e?[0-9]?$|^0x[0-9a-f]+$|[0-9]+)/gi,
        sre = /(^[ ]*|[ ]*$)/g,
        dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,
        hre = /^0x[0-9a-f]+$/i,
        ore = /^0/,
        options = options || {},
        i = function i(s) {
      return options.insensitive && ('' + s).toLowerCase() || '' + s;
    },

    // convert all to strings strip whitespace
    x = i(a).replace(sre, '') || '',
        y = i(b).replace(sre, '') || '',

    // chunk/tokenize
    xN = x.replace(re, '\0$1\0').replace(/\0$/, '').replace(/^\0/, '').split('\0'),
        yN = y.replace(re, '\0$1\0').replace(/\0$/, '').replace(/^\0/, '').split('\0'),

    // numeric, hex or date detection
    xD = parseInt(x.match(hre)) || xN.length !== 1 && x.match(dre) && Date.parse(x),
        yD = parseInt(y.match(hre)) || xD && y.match(dre) && Date.parse(y) || null,
        oFxNcL,
        oFyNcL,
        mult = options.desc ? -1 : 1;

    // first try and sort Hex codes or Dates
    if (yD) if (xD < yD) return -1 * mult;else if (xD > yD) return 1 * mult;

    // natural sorting through split numeric strings and default strings
    for (var cLoc = 0, numS = Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
      // find floats not starting with '0', string or 0 if not defined (Clint Priest)
      oFxNcL = !(xN[cLoc] || '').match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
      oFyNcL = !(yN[cLoc] || '').match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
      // handle numeric vs string comparison - number < string - (Kyle Adams)
      if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {
        return (isNaN(oFxNcL) ? 1 : -1) * mult;
      }
      // rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'
      else if ((typeof oFxNcL === 'undefined' ? 'undefined' : _typeof(oFxNcL)) !== (typeof oFyNcL === 'undefined' ? 'undefined' : _typeof(oFyNcL))) {
          oFxNcL += '';
          oFyNcL += '';
        }
      if (oFxNcL < oFyNcL) return -1 * mult;
      if (oFxNcL > oFyNcL) return 1 * mult;
    }
    return 0;
  };

  return pgAdmin;
});

/***/ }),
/* 4 */,
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(45)], __WEBPACK_AMD_DEFINE_RESULT__ = function (endpoints) {
  /***
   * This method behaves as a drop-in replacement for flask url_for function.
   * It uses the exposed URLs file under the hood, and replace the substitions provided by the modules.
   *
   * ex.
   * url_for("help.static", {filename: "server_dialog.html"}) will produce the
   * output string '/help/help/server_dialog.html' from the url ->
   * '/help/help/<path:filename>'.
   *
   * @param {String} text
   * @param {Object} substitutions
   */
  return function url_for(endpoint, substitutions) {

    var rawURL = endpoints[endpoint];

    // captures things of the form <path:substitutionName>
    var substitutionGroupsRegExp = /([<])([^:^>]*:)?([^>]+)([>])/g;
    var matchFound;

    var interpolated = rawURL;

    if (!rawURL) return rawURL;

    interpolated = interpolated.replace(substitutionGroupsRegExp, function (_origin, _1, _2, substitutionName) {
      if (substitutionName in substitutions) {
        return substitutions[substitutionName];
      }
      return _origin;
    });

    return interpolated;
  };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _codemirror = __webpack_require__(14);

var _codemirror2 = _interopRequireDefault(_codemirror);

__webpack_require__(52);

__webpack_require__(85);

__webpack_require__(86);

__webpack_require__(75);

__webpack_require__(87);

__webpack_require__(88);

__webpack_require__(89);

__webpack_require__(90);

__webpack_require__(53);

__webpack_require__(91);

__webpack_require__(76);

__webpack_require__(92);

__webpack_require__(93);

__webpack_require__(94);

__webpack_require__(95);

__webpack_require__(38);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _codemirror2.default;

/***/ }),
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (mod) {
  if (( false ? "undefined" : _typeof(exports)) == "object" && ( false ? "undefined" : _typeof(module)) == "object") // CommonJS
    mod(__webpack_require__(14));else if (true) // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(14)], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  CodeMirror.pgadminKeywordRangeFinder = function (cm, start, startTkn, endTkn) {
    var line = start.line,
        lineText = cm.getLine(line);
    var at = lineText.length,
        startChar,
        tokenType;
    for (; at > 0;) {
      var found = lineText.lastIndexOf(startTkn, at);
      var startToken = startTkn;
      var endToken = endTkn;
      if (found < start.ch) {
        var found = lineText.lastIndexOf("[", at);
        if (found < start.ch) break;
        var startToken = '[';
        var endToken = ']';
      }

      tokenType = cm.getTokenAt(CodeMirror.Pos(line, found + 1)).type;
      if (!/^(comment|string)/.test(tokenType)) {
        startChar = found;break;
      }
      at = found - 1;
    }
    if (startChar == null || lineText.lastIndexOf(startToken) > startChar) return;
    var count = 1,
        lastLine = cm.lineCount(),
        end,
        endCh;
    outer: for (var i = line + 1; i < lastLine; ++i) {
      var text = cm.getLine(i),
          pos = 0;
      for (;;) {
        var nextOpen = text.indexOf(startToken, pos),
            nextClose = text.indexOf(endToken, pos);
        if (nextOpen < 0) nextOpen = text.length;
        if (nextClose < 0) nextClose = text.length;
        pos = Math.min(nextOpen, nextClose);
        if (pos == text.length) break;
        if (cm.getTokenAt(CodeMirror.Pos(i, pos + 1)).type == tokenType) {
          if (pos == nextOpen) ++count;else if (! --count) {
            end = i;
            endCh = pos;
            break outer;
          }
        }
        ++pos;
      }
    }
    if (end == null || end == line + 1) return;
    return { from: CodeMirror.Pos(line, startChar + startTkn.length),
      to: CodeMirror.Pos(end, endCh) };
  };

  CodeMirror.pgadminBeginRangeFinder = function (cm, start) {
    var startToken = 'BEGIN';
    var endToken = 'END;';
    var fromToPos = CodeMirror.pgadminKeywordRangeFinder(cm, start, startToken, endToken);
    return fromToPos;
  };

  CodeMirror.pgadminIfRangeFinder = function (cm, start) {
    var startToken = 'IF';
    var endToken = 'END IF';
    var fromToPos = CodeMirror.pgadminKeywordRangeFinder(cm, start, startToken, endToken);
    return fromToPos;
  };

  CodeMirror.pgadminLoopRangeFinder = function (cm, start) {
    var startToken = 'LOOP';
    var endToken = 'END LOOP';
    var fromToPos = CodeMirror.pgadminKeywordRangeFinder(cm, start, startToken, endToken);
    return fromToPos;
  };

  CodeMirror.pgadminCaseRangeFinder = function (cm, start) {
    var startToken = 'CASE';
    var endToken = 'END CASE';
    var fromToPos = CodeMirror.pgadminKeywordRangeFinder(cm, start, startToken, endToken);
    return fromToPos;
  };
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(46)(module)))

/***/ }),
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_44__;

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_45__;

/***/ }),
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_77__;

/***/ }),
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_96__;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _underscore = __webpack_require__(1);

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function generate_url(baseUrl, treeInfo, actionType, nodeType, pickFunction, itemDataID) {
  var ref = '';
  _underscore2.default.each(_underscore2.default.sortBy(_underscore2.default.pick(treeInfo, pickFunction), function (treeInfoItems) {
    return treeInfoItems.priority;
  }), function (treeInfoItems) {
    ref = ref + '/' + encodeURI(treeInfoItems._id);
  });
  ref = itemDataID ? ref + '/' + itemDataID : ref + '/';

  return '' + baseUrl + nodeType + '/' + actionType + ref;
}

module.exports = {
  generate_url: generate_url
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(8), __webpack_require__(3), __webpack_require__(6), __webpack_require__(10), __webpack_require__(13), __webpack_require__(14), __webpack_require__(16), __webpack_require__(30), __webpack_require__(24), __webpack_require__(28), __webpack_require__(157)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, Alertify, pgAdmin, pgBrowser, Backbone, Backgrid, CodeMirror, Backform) {

  /*
   * Function used to return the respective Backgrid control based on the data type
   * of function input argument.
   */
  var cellFunction = function cellFunction(model) {
    var self = this,
        variable_type = model.get("type");

    // if variable type is an array then we need to render the custom control to take the input from user.
    if (variable_type.indexOf("[]") != -1) {
      if (variable_type.indexOf("integer") != -1) {
        return Backgrid.Extension.InputIntegerArrayCell;
      }
      return Backgrid.Extension.InputStringArrayCell;
    }

    switch (variable_type) {
      case "bool":
        return Backgrid.BooleanCell;
        break;

      case "integer":
        // As we are getting this value as text from sqlite database so we need to type cast it.
        if (model.get('value') != undefined) {
          model.set({ 'value': parseInt(model.get('value')) }, { silent: true });
        }

        return Backgrid.IntegerCell;
        break;

      case "real":
        // As we are getting this value as text from sqlite database so we need to type cast it.
        if (model.get('value') != undefined) {
          model.set({ 'value': parseFloat(model.get('value')) }, { silent: true });
        }
        return Backgrid.NumberCell;
        break;

      case "string":
        return Backgrid.StringCell;
        break;
      case "date":
        return Backgrid.DateCell;
        break;
      default:
        return Backgrid.Cell;
        break;
    }
  };

  /*
   * Function used to return the respective Backgrid string or boolean control based on the data type
   * of function input argument.
   */
  var cellExprControlFunction = function cellExprControlFunction(model) {
    var self = this,
        variable_type = model.get("type");
    if (variable_type.indexOf("[]") != -1) {
      return Backgrid.StringCell;
    }
    return Backgrid.BooleanCell;
  };

  /**
   *  DebuggerInputArgsModel used to represent input parameters for the function to debug
   *  for function objects.
   **/
  var DebuggerInputArgsModel = Backbone.Model.extend({
    defaults: {
      name: undefined,
      type: undefined,
      is_null: undefined,
      expr: undefined,
      value: undefined,
      use_default: undefined,
      default_value: undefined
    },
    validate: function validate() {
      if (_.isUndefined(this.get('value')) || _.isNull(this.get('value')) || String(this.get('value')).replace(/^\s+|\s+$/g, '') == '') {
        var msg = gettext('Please enter a value for the parameter.');
        this.errorModel.set('value', msg);
        return msg;
      } else {
        this.errorModel.unset('value');
      }
      return null;
    }
  });

  // Collection which contains the model for function informations.
  var DebuggerInputArgCollections = Backbone.Collection.extend({
    model: DebuggerInputArgsModel
  });

  // function will enable/disable the use_default column based on the value received.
  var disableDefaultCell = function disableDefaultCell(d) {
    if (d instanceof Backbone.Model) {
      return d.get('use_default');
    }
    return false;
  };

  // Enable/Disable the control based on the array data type of the function input arguments
  var disableExpressionControl = function disableExpressionControl(d) {
    var argType = d.get('type');
    if (d instanceof Backbone.Model) {
      var argType = d.get('type');
      if (argType.indexOf("[]") != -1) {
        return false;
      }
      return true;
    }
  };

  var res = function res(args, restart_debug) {
    if (!Alertify.debuggerInputArgsDialog) {
      Alertify.dialog('debuggerInputArgsDialog', function factory() {
        return {
          main: function main(title, data, restart_debug) {
            this.set('title', title);
            this.data = data;
            this.restart_debug = restart_debug;

            // Variables to store the data sent from sqlite database
            var func_args_data = this.func_args_data = [];

            // As we are not getting pgBrowser.tree when we debug again so tree info will be updated from the server data
            if (restart_debug == 0) {
              var t = pgBrowser.tree,
                  i = t.selected(),
                  d = i && i.length == 1 ? t.itemData(i) : undefined,
                  node = d && pgBrowser.Nodes[d._type];

              if (!d) return;

              var treeInfo = node.getTreeNodeHierarchy.apply(node, [i]);

              if (d._type == "function") {
                // Get the existing function parameters available from sqlite database
                var _Url = url_for('debugger.get_arguments', {
                  'sid': treeInfo.server._id,
                  'did': treeInfo.database._id,
                  'scid': treeInfo.schema._id,
                  'func_id': treeInfo.function._id
                });
              } else if (d._type == "procedure") {
                // Get the existing function parameters available from sqlite database
                var _Url = url_for('debugger.get_arguments', {
                  'sid': treeInfo.server._id,
                  'did': treeInfo.database._id,
                  'scid': treeInfo.schema._id,
                  'func_id': treeInfo.procedure._id
                });
              } else if (d._type == "edbfunc") {
                // Get the existing function parameters available from sqlite database
                var _Url = url_for('debugger.get_arguments', {
                  'sid': treeInfo.server._id,
                  'did': treeInfo.database._id,
                  'scid': treeInfo.schema._id,
                  'func_id': treeInfo.edbfunc._id
                });
              } else if (d._type == "edbproc") {
                // Get the existing function parameters available from sqlite database
                var _Url = url_for('debugger.get_arguments', {
                  'sid': treeInfo.server._id,
                  'did': treeInfo.database._id,
                  'scid': treeInfo.schema._id,
                  'func_id': treeInfo.edbproc._id
                });
              }
            } else {
              // Get the existing function parameters available from sqlite database
              var _Url = url_for('debugger.get_arguments', {
                'sid': this.data.server_id,
                'did': this.data.database_id,
                'scid': this.data.schema_id,
                'func_id': this.data.function_id
              });
            }
            $.ajax({
              url: _Url,
              method: 'GET',
              async: false,
              success: function success(res) {
                if (res.data.args_count != 0) {
                  for (i = 0; i < res.data.result.length; i++) {
                    // Below will format the data to be stored in sqlite database
                    func_args_data.push({
                      'arg_id': res.data.result[i]['arg_id'],
                      'is_null': res.data.result[i]['is_null'],
                      'is_expression': res.data.result[i]['is_expression'],
                      'use_default': res.data.result[i]['use_default'],
                      'value': res.data.result[i]['value']
                    });
                  }
                }
              },
              error: function error(e) {
                Alertify.alert('Debugger Set arguments error');
              }
            });

            var argname, argtype, argmode, default_args_count, default_args, arg_cnt;

            var value_header = Backgrid.HeaderCell.extend({
              // Add fixed width to the "value" column
              className: 'width_percent_25'
            });

            var def_val_list = [],
                gridCols = [{ name: 'name', label: 'Name', type: 'text', editable: false, cell: 'string' }, { name: 'type', label: 'Type', type: 'text', editable: false, cell: 'string' }, { name: 'is_null', label: 'Null?', type: 'boolean', cell: 'boolean' }, { name: 'expr', label: 'Expression?', type: 'boolean', cellFunction: cellExprControlFunction, editable: disableExpressionControl }, { name: 'value', label: 'Value', type: 'text', editable: true, cellFunction: cellFunction, headerCell: value_header }, { name: 'use_default', label: 'Use Default?', type: 'boolean', cell: "boolean", editable: disableDefaultCell }, { name: 'default_value', label: 'Default value', type: 'text', editable: false, cell: 'string' }];

            var my_obj = [];
            var func_obj = [];

            // Below will calculate the input argument id required to store in sqlite database
            var input_arg_id = this.input_arg_id = [];
            if (this.data['proargmodes'] != null) {
              var argmode_1 = this.data['proargmodes'].split(",");
              for (var k = 0; k < argmode_1.length; k++) {
                if (argmode_1[k] == 'i' || argmode_1[k] == 'b') {
                  input_arg_id.push(k);
                }
              }
            } else {
              var argtype_1 = this.data['proargtypenames'].split(",");
              for (var k = 0; k < argtype_1.length; k++) {
                input_arg_id.push(k);
              }
            }

            argtype = this.data['proargtypenames'].split(",");

            if (this.data['proargmodes'] != null) {
              argmode = this.data['proargmodes'].split(",");
            }

            if (this.data['pronargdefaults']) {
              default_args_count = this.data['pronargdefaults'];
              default_args = this.data['proargdefaults'].split(",");
              arg_cnt = default_args_count;
            }

            if (this.data['proargnames'] != null) {
              argname = this.data['proargnames'].split(",");

              // It will assign default values to "Default value" column
              for (var j = argname.length - 1; j >= 0; j--) {
                if (this.data['proargmodes'] != null) {
                  if (arg_cnt && (argmode[j] == 'i' || argmode[j] == 'b')) {
                    arg_cnt = arg_cnt - 1;
                    def_val_list[j] = default_args[arg_cnt];
                  } else {
                    def_val_list[j] = "<No default value>";
                  }
                } else {
                  if (arg_cnt) {
                    arg_cnt = arg_cnt - 1;
                    def_val_list[j] = default_args[arg_cnt];
                  } else {
                    def_val_list[j] = "<No default value>";
                  }
                }
              }

              if (argtype.length != 0) {
                for (i = 0; i < argtype.length; i++) {
                  if (this.data['proargmodes'] != null) {
                    if (argmode[i] == 'i' || argmode[i] == 'b') {
                      var use_def_value = false;
                      if (def_val_list[i] != "<No default value>") {
                        use_def_value = true;
                      }
                      my_obj.push({ "name": argname[i], "type": argtype[i], "use_default": use_def_value, "default_value": def_val_list[i] });
                    }
                  } else {
                    var use_def_value = false;
                    if (def_val_list[i] != "<No default value>") {
                      use_def_value = true;
                    }
                    my_obj.push({ "name": argname[i], "type": argtype[i], "use_default": use_def_value, "default_value": def_val_list[i] });
                  }
                }
              }

              // Need to update the func_obj variable from sqlite database if available
              if (func_args_data.length != 0) {
                for (i = 0; i < func_args_data.length; i++) {
                  var index = func_args_data[i]['arg_id'];
                  var values = [];
                  if (argtype[index].indexOf("[]") != -1) {
                    var vals = func_args_data[i]['value'].split(",");
                    if (argtype[index].indexOf("integer") != -1) {
                      _.each(vals, function (val) {
                        values.push({ 'value': parseInt(val) });
                      });
                    }
                    _.each(vals, function (val) {
                      values.push({ 'value': val });
                    });
                  } else {
                    values = func_args_data[i]['value'];
                  }

                  func_obj.push({ "name": argname[index], "type": argtype[index], "is_null": func_args_data[i]['is_null'] ? true : false, "expr": func_args_data[i]['is_expression'] ? true : false, "value": values, "use_default": func_args_data[i]['use_default'] ? true : false, "default_value": def_val_list[index] });
                }
              }
            } else {
              /*
               Generate the name parameter if function do not have arguments name
               like dbgparam1, dbgparam2 etc.
              */
              var myargname = [];

              for (i = 0; i < argtype.length; i++) {
                myargname[i] = "dbgparam" + (i + 1);
              }

              // If there is no default arguments
              if (!this.data['pronargdefaults']) {
                for (i = 0; i < argtype.length; i++) {
                  my_obj.push({ "name": myargname[i], "type": argtype[i], "use_default": false, "default_value": "<No default value>" });
                  def_val_list[i] = "<No default value>";
                }
              } else {
                // If there is default arguments
                //Below logic will assign default values to "Default value" column
                for (var j = myargname.length - 1; j >= 0; j--) {
                  if (this.data['proargmodes'] == null) {
                    if (arg_cnt) {
                      arg_cnt = arg_cnt - 1;
                      def_val_list[j] = default_args[arg_cnt];
                    } else {
                      def_val_list[j] = "<No default value>";
                    }
                  } else {
                    if (arg_cnt && (argmode[j] == 'i' || argmode[j] == 'b')) {
                      arg_cnt = arg_cnt - 1;
                      def_val_list[j] = default_args[arg_cnt];
                    } else {
                      def_val_list[j] = "<No default value>";
                    }
                  }
                }

                for (i = 0; i < argtype.length; i++) {
                  if (this.data['proargmodes'] == null) {
                    var use_def_value = false;
                    if (def_val_list[i] != "<No default value>") {
                      use_def_value = true;
                    }
                    my_obj.push({ "name": myargname[i], "type": argtype[i], "use_default": use_def_value, "default_value": def_val_list[i] });
                  } else {
                    if (argmode[i] == 'i' || argmode[i] == 'b') {
                      var use_def_value = false;
                      if (def_val_list[i] != "<No default value>") {
                        use_def_value = true;
                      }
                      my_obj.push({ "name": myargname[i], "type": argtype[i], "use_default": use_def_value, "default_value": def_val_list[i] });
                    }
                  }
                }
              }

              // Need to update the func_obj variable from sqlite database if available
              if (func_args_data.length != 0) {
                for (i = 0; i < func_args_data.length; i++) {
                  var index = func_args_data[i]['arg_id'];
                  var values = [];
                  if (argtype[index].indexOf("[]") != -1) {
                    var vals = func_args_data[i]['value'].split(",");
                    if (argtype[index].indexOf("integer") != -1) {
                      _.each(vals, function (val) {
                        values.push({ 'value': parseInt(val) });
                      });
                    }
                    _.each(vals, function (val) {
                      values.push({ 'value': val });
                    });
                  } else {
                    values = func_args_data[i]['value'];
                  }
                  func_obj.push({ "name": myargname[index], "type": argtype[index], "is_null": func_args_data[i]['is_null'] ? true : false, "expr": func_args_data[i]['is_expression'] ? true : false, "value": values, "use_default": func_args_data[i]['use_default'] ? true : false, "default_value": def_val_list[index] });
                }
              }
            }

            // Check if the arguments already available in the sqlite database then we should use the existing arguments
            if (func_args_data.length == 0) {
              var debuggerInputArgsColl = this.debuggerInputArgsColl = new DebuggerInputArgCollections(my_obj);
            } else {
              var debuggerInputArgsColl = this.debuggerInputArgsColl = new DebuggerInputArgCollections(func_obj);
            }

            // Initialize a new Grid instance
            if (this.grid) {
              this.grid.remove();
              this.grid = null;
            }
            var grid = this.grid = new Backgrid.Grid({
              columns: gridCols,
              collection: debuggerInputArgsColl,
              className: "backgrid table-bordered"
            });

            grid.render();
            $(this.elements.content).html(grid.el);
          },
          setup: function setup() {
            return {
              buttons: [{ text: "Debug", key: 13, className: "btn btn-primary" }, { text: "Cancel", key: 27, className: "btn btn-primary" }],
              options: { modal: 0, resizable: true }
            };
          },
          // Callback functions when click on the buttons of the Alertify dialogs
          callback: function callback(e) {
            if (e.button.text === "Debug") {

              // Initialize the target once the debug button is clicked and
              // create asynchronous connection and unique transaction ID
              var self = this;

              // If the debugging is started again then treeInfo is already stored in this.data so we can use the same.
              if (self.restart_debug == 0) {
                var t = pgBrowser.tree,
                    i = t.selected(),
                    d = i && i.length == 1 ? t.itemData(i) : undefined,
                    node = d && pgBrowser.Nodes[d._type];

                if (!d) return;

                var treeInfo = node.getTreeNodeHierarchy.apply(node, [i]);
              }

              var args_value_list = [];
              var sqlite_func_args_list = this.sqlite_func_args_list = [];
              var int_count = 0;

              this.grid.collection.each(function (m) {

                // Check if value is set to NULL then we should ignore the value field
                if (m.get('is_null')) {
                  args_value_list.push({ 'name': m.get('name'),
                    'type': m.get('type'),
                    'value': 'NULL' });
                } else {
                  // Check if default value to be used or not
                  if (m.get('use_default')) {
                    args_value_list.push({ 'name': m.get('name'),
                      'type': m.get('type'),
                      'value': m.get('default_value') });
                  } else {
                    args_value_list.push({ 'name': m.get('name'),
                      'type': m.get('type'),
                      'value': m.get('value') });
                  }
                }

                if (self.restart_debug == 0) {
                  var f_id;
                  if (d._type == "function") {
                    f_id = treeInfo.function._id;
                  } else if (d._type == "procedure") {
                    f_id = treeInfo.procedure._id;
                  } else if (d._type == "edbfunc") {
                    f_id = treeInfo.edbfunc._id;
                  } else if (d._type == "edbproc") {
                    f_id = treeInfo.edbproc._id;
                  }

                  // Below will format the data to be stored in sqlite database
                  sqlite_func_args_list.push({
                    'server_id': treeInfo.server._id,
                    'database_id': treeInfo.database._id,
                    'schema_id': treeInfo.schema._id,
                    'function_id': f_id,
                    'arg_id': self.input_arg_id[int_count],
                    'is_null': m.get('is_null') ? 1 : 0,
                    'is_expression': m.get('expr') ? 1 : 0,
                    'use_default': m.get('use_default') ? 1 : 0,
                    'value': m.get('value')
                  });
                } else {
                  // Below will format the data to be stored in sqlite database
                  sqlite_func_args_list.push({
                    'server_id': self.data.server_id,
                    'database_id': self.data.database_id,
                    'schema_id': self.data.schema_id,
                    'function_id': self.data.function_id,
                    'arg_id': self.input_arg_id[int_count],
                    'is_null': m.get('is_null') ? 1 : 0,
                    'is_expression': m.get('expr') ? 1 : 0,
                    'use_default': m.get('use_default') ? 1 : 0,
                    'value': m.get('value')
                  });
                }

                int_count = int_count + 1;
              });

              // If debugging is not started again then we should initialize the target otherwise not
              if (self.restart_debug == 0) {
                var baseUrl;
                if (d._type == "function") {
                  baseUrl = url_for('debugger.initialize_target_for_function', {
                    'debug_type': 'direct',
                    'sid': treeInfo.server._id,
                    'did': treeInfo.database._id,
                    'scid': treeInfo.schema._id,
                    'func_id': treeInfo.function._id
                  });
                } else if (d._type == "procedure") {
                  baseUrl = url_for('debugger.initialize_target_for_function', {
                    'debug_type': 'direct',
                    'sid': treeInfo.server._id,
                    'did': treeInfo.database._id,
                    'scid': treeInfo.schema._id,
                    'func_id': treeInfo.procedure._id
                  });
                } else if (d._type == "edbfunc") {
                  baseUrl = url_for('debugger.initialize_target_for_function', {
                    'debug_type': 'direct',
                    'sid': treeInfo.server._id,
                    'did': treeInfo.database._id,
                    'scid': treeInfo.schema._id,
                    'func_id': treeInfo.edbfunc._id
                  });
                } else if (d._type == "edbproc") {
                  baseUrl = url_for('debugger.initialize_target_for_function', {
                    'debug_type': 'direct',
                    'sid': treeInfo.server._id,
                    'did': treeInfo.database._id,
                    'scid': treeInfo.schema._id,
                    'func_id': treeInfo.edbproc._id
                  });
                }

                $.ajax({
                  url: baseUrl,
                  method: 'POST',
                  data: { 'data': JSON.stringify(args_value_list) },
                  success: function success(res) {

                    var url = url_for('debugger.direct', { 'trans_id': res.data.debuggerTransId });

                    if (res.data.newBrowserTab) {
                      window.open(url, '_blank');
                    } else {
                      pgBrowser.Events.once('pgadmin-browser:frame:urlloaded:frm_debugger', function (frame) {
                        frame.openURL(url);
                      });

                      // Create the debugger panel as per the data received from user input dialog.
                      var dashboardPanel = pgBrowser.docker.findPanels('properties'),
                          panel = pgBrowser.docker.addPanel('frm_debugger', wcDocker.DOCK.STACKED, dashboardPanel[0]);

                      panel.focus();

                      // Panel Closed event
                      panel.on(wcDocker.EVENT.CLOSED, function () {
                        var closeUrl = url_for('debugger.close', { 'trans_id': res.data.debuggerTransId });
                        $.ajax({
                          url: closeUrl,
                          method: 'DELETE'
                        });
                      });
                    }

                    if (d._type == "function") {
                      var _Url = url_for('debugger.set_arguments', {
                        'sid': treeInfo.server._id,
                        'did': treeInfo.database._id,
                        'scid': treeInfo.schema._id,
                        'func_id': treeInfo.function._id
                      });
                    } else if (d._type == "procedure") {
                      var _Url = url_for('debugger.set_arguments', {
                        'sid': treeInfo.server._id,
                        'did': treeInfo.database._id,
                        'scid': treeInfo.schema._id,
                        'func_id': treeInfo.procedure._id
                      });
                    } else if (d._type == "edbfunc") {
                      // Get the existing function parameters available from sqlite database
                      var _Url = url_for('debugger.set_arguments', {
                        'sid': treeInfo.server._id,
                        'did': treeInfo.database._id,
                        'scid': treeInfo.schema._id,
                        'func_id': treeInfo.edbfunc._id
                      });
                    } else if (d._type == "edbproc") {
                      // Get the existing function parameters available from sqlite database
                      var _Url = url_for('debugger.set_arguments', {
                        'sid': treeInfo.server._id,
                        'did': treeInfo.database._id,
                        'scid': treeInfo.schema._id,
                        'func_id': treeInfo.edbproc._id
                      });
                    }

                    $.ajax({
                      url: _Url,
                      method: 'POST',
                      data: { 'data': JSON.stringify(sqlite_func_args_list) },
                      success: function success(res) {},
                      error: function error(e) {
                        Alertify.alert('Debugger Set arguments error');
                      }
                    });
                  },
                  error: function error(e) {
                    Alertify.alert('Debugger target Initialize Error', e.responseJSON.errormsg);
                  }
                });
              } else {
                // If the debugging is started again then we should only set the arguments and start the listener again
                var baseUrl = url_for('debugger.start_listener', { 'trans_id': self.data.trans_id });

                $.ajax({
                  url: baseUrl,
                  method: 'POST',
                  data: { 'data': JSON.stringify(args_value_list) },
                  success: function success(res) {},
                  error: function error(e) {
                    Alertify.alert('Debugger listener starting error', e.responseJSON.errormsg);
                  }
                });

                // Set the new input arguments given by the user during debugging
                var _Url = url_for('debugger.set_arguments', {
                  'sid': self.data.server_id,
                  'did': self.data.database_id,
                  'scid': self.data.schema_id,
                  'func_id': self.data.function_id
                });
                $.ajax({
                  url: _Url,
                  method: 'POST',
                  data: { 'data': JSON.stringify(sqlite_func_args_list) },
                  success: function success(res) {},
                  error: function error(e) {
                    Alertify.alert('Debugger Set arguments error');
                  }
                });
              }

              return true;
            }

            if (e.button.text === "Cancel") {
              //close the dialog...
              return false;
            }
          },
          build: function build() {},
          prepare: function prepare() {
            /*
             If we already have data available in sqlite database then we should enable the debug button otherwise
             disable the debug button.
            */
            if (this.func_args_data.length == 0) {
              this.__internal.buttons[0].element.disabled = true;
            } else {
              this.__internal.buttons[0].element.disabled = false;
            }

            /*
             Listen to the grid change event so that if any value changed by user then we can enable/disable the
             debug button.
            */
            this.grid.listenTo(this.debuggerInputArgsColl, "backgrid:edited", function (obj) {

              return function () {

                var self = this;
                var enable_btn = false;

                for (var i = 0; i < this.collection.length; i++) {

                  // TODO: Need to check the "NULL" and "Expression" column value to enable/disable the "Debug" button
                  if (this.collection.models[i].get('value') == "" || this.collection.models[i].get('value') == null || this.collection.models[i].get('value') == undefined) {
                    enable_btn = true;

                    if (this.collection.models[i].get('use_default')) {
                      obj.__internal.buttons[0].element.disabled = false;
                    } else {
                      obj.__internal.buttons[0].element.disabled = true;
                      break;
                    }
                  }
                }
                if (!enable_btn) obj.__internal.buttons[0].element.disabled = false;
              };
            }(this));
          }
        };
      });
    }

    Alertify.debuggerInputArgsDialog('Debugger', args, restart_debug).resizeTo('60%', '60%');
  };

  return res;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//////////////////////////////////////////////////////////////////////////
//
// pgAdmin 4 - PostgreSQL Tools
//
// Copyright (C) 2013 - 2017, The pgAdmin Development Team
// This software is released under the PostgreSQL Licence
//
//////////////////////////////////////////////////////////////////////////

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0), __webpack_require__(1), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, _, S) {

  var check_node_visibility = function check_node_visibility(pgBrowser, node_type) {
    if (_.isUndefined(node_type) || _.isNull(node_type)) {
      return true;
    }

    // Target actual node instead of collection.
    // If node is disabled then there is no meaning of
    // adding collection node menu
    if (S.startsWith(node_type, "coll-")) {
      node_type = node_type.replace("coll-", "");
    }

    // Exclude non-applicable nodes
    var nodes_not_supported = ["server_group", "server", "catalog_object_column"];
    if (_.indexOf(nodes_not_supported, node_type) >= 0) {
      return true;
    }

    var preference = pgBrowser.get_preference("browser", 'show_node_' + node_type);

    if (preference) {
      return preference.value;
    } else {
      return true;
    }
  };

  return check_node_visibility;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(17), __webpack_require__(3), __webpack_require__(6), __webpack_require__(10), __webpack_require__(13), __webpack_require__(29), __webpack_require__(16), __webpack_require__(98), __webpack_require__(30), __webpack_require__(24), __webpack_require__(28)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, Alertify, pgAdmin, pgBrowser, Backbone, Backgrid, codemirror, Backform, debug_function_again) {

  var CodeMirror = codemirror.default;
  if (pgAdmin.Browser.tree != null) {
    pgAdmin = pgAdmin || window.pgAdmin || {};
  }

  var pgTools = pgAdmin.Tools = pgAdmin.Tools || {};

  if (pgTools.DirectDebug) return pgTools.DirectDebug;

  var controller = new function () {}();

  _.extend(controller, Backbone.Events, {
    enable: function enable(btn, _enable) {
      // trigger the event and change the button view to enable/disable the buttons for debugging
      this.trigger('pgDebugger:button:state:' + btn, _enable);
    },

    /*
      Function to set the breakpoint and send the line no. which is set to server
      trans_id :- Unique Transaction ID, line_no - line no. to set the breakpoint, set_type = 0 - clear , 1 - set
    */
    set_breakpoint: function set_breakpoint(trans_id, line_no, set_type) {
      var self = this;

      // Make ajax call to set/clear the break point by user
      var baseUrl = url_for('debugger.set_breakpoint', {
        'trans_id': trans_id,
        'line_no': line_no,
        'set_type': set_type
      });
      $.ajax({
        url: baseUrl,
        method: 'GET',
        success: function success(res) {
          if (res.data.status) {
            // Breakpoint has been set by the user
          }
        },
        error: function error(e) {
          Alertify.alert('Debugger Error', 'Error while setting debugging breakpoint.');
        }
      });
    },

    // Function to get the latest breakpoint information and update the gutters of codemirror
    UpdateBreakpoint: function UpdateBreakpoint(trans_id) {
      var self = this;

      var br_list = self.GetBreakpointInformation(trans_id);

      // If there is no break point to clear then we should return from here.
      if (br_list.length == 1 && br_list[0].linenumber == -1) return;

      var breakpoint_list = new Array();

      for (var i = 0; i < br_list.length; i++) {
        if (br_list[i].linenumber != -1) {
          breakpoint_list.push(br_list[i].linenumber);
        }
      }

      for (var i = 0; i < breakpoint_list.length; i++) {
        var info = pgTools.DirectDebug.editor.lineInfo(breakpoint_list[i] - 1);

        if (info.gutterMarkers != undefined) {
          pgTools.DirectDebug.editor.setGutterMarker(breakpoint_list[i] - 1, "breakpoints", null);
        } else {
          pgTools.DirectDebug.editor.setGutterMarker(breakpoint_list[i] - 1, "breakpoints", function () {
            var marker = document.createElement("div");
            marker.style.color = "#822";
            marker.innerHTML = "";
            return marker;
          }());
        }
      }
    },

    // Function to get the breakpoint information from the server
    GetBreakpointInformation: function GetBreakpointInformation(trans_id) {
      var self = this;
      var result = '';

      // Make ajax call to listen the database message
      var baseUrl = url_for('debugger.execute_query', {
        'trans_id': trans_id,
        'query_type': 'get_breakpoints'
      });
      $.ajax({
        url: baseUrl,
        method: 'GET',
        async: false,
        success: function success(res) {
          if (res.data.status === 'Success') {
            result = res.data.result;
          } else if (res.data.status === 'NotConnected') {
            Alertify.alert('Debugger Error', 'Error while fetching breakpoint information.');
          }
        },
        error: function error(e) {
          Alertify.alert('Debugger Error', 'Error while fetching breakpoint information.');
        }
      });

      return result;
    },

    // Function to start the executer and execute the user requested option for debugging
    start_execution: function start_execution(trans_id, port_num) {
      var self = this;
      // Make ajax call to listen the database message
      var baseUrl = url_for('debugger.start_execution', {
        'trans_id': trans_id,
        'port_num': port_num
      });
      $.ajax({
        url: baseUrl,
        method: 'GET',
        success: function success(res) {
          if (res.data.status === 'Success') {
            // If status is Success then find the port number to attach the executer.
            self.execute_query(trans_id);
          } else if (res.data.status === 'NotConnected') {
            Alertify.alert('Debugger Error', 'Error while starting debugging session.');
          }
        },
        error: function error(e) {
          Alertify.alert('Debugger Error', 'Error while starting debugging session.');
        }
      });
    },

    // Execute the query and get the first functions debug information from the server
    execute_query: function execute_query(trans_id) {
      var self = this;
      // Make ajax call to listen the database message
      var baseUrl = url_for('debugger.execute_query', {
        'trans_id': trans_id,
        'query_type': 'wait_for_breakpoint'
      });
      $.ajax({
        url: baseUrl,
        method: 'GET',
        success: function success(res) {
          if (res.data.status === 'Success') {
            // set the return code to the code editor text area
            if (res.data.result[0].src != null && res.data.result[0].linenumber != null) {
              pgTools.DirectDebug.editor.setValue(res.data.result[0].src);
              var active_line_no = self.active_line_no = res.data.result[0].linenumber - 2;
              pgTools.DirectDebug.editor.addLineClass(res.data.result[0].linenumber - 2, 'wrap', 'CodeMirror-activeline-background');
            }

            // Call function to create and update local variables ....
            self.GetStackInformation(trans_id);
            if (pgTools.DirectDebug.debug_type) {
              self.poll_end_execution_result(trans_id);
            }
          } else if (res.data.status === 'NotConnected') {
            Alertify.alert('Debugger Error', 'Error while executing requested debugging information.');
          }
        },
        error: function error(e) {
          Alertify.alert('Debugger Error', 'Error while executing requested debugging information.');
        }
      });
    },

    // Get the local variable information of the functions and update the grid
    GetLocalVariables: function GetLocalVariables(trans_id) {
      var self = this;

      // Make ajax call to listen the database message
      var baseUrl = url_for('debugger.execute_query', {
        'trans_id': trans_id,
        'query_type': 'get_variables'
      });
      $.ajax({
        url: baseUrl,
        method: 'GET',
        success: function success(res) {
          if (res.data.status === 'Success') {
            // Call function to create and update local variables
            self.AddLocalVariables(res.data.result);
            self.AddParameters(res.data.result);
            // If debug function is restarted then again start listener to read the updated messages.
            if (pgTools.DirectDebug.debug_restarted) {
              if (pgTools.DirectDebug.debug_type) {
                self.poll_end_execution_result(trans_id);
              }
              pgTools.DirectDebug.debug_restarted = false;
            }
          } else if (res.data.status === 'NotConnected') {
            Alertify.alert('Debugger Error', 'Error while fetching variable information.');
          }
        },
        error: function error(e) {
          Alertify.alert('Debugger Error', 'Error while fetching variable information.');
        }
      });
    },

    // Get the stack information of the functions and update the grid
    GetStackInformation: function GetStackInformation(trans_id) {
      var self = this;

      // Make ajax call to listen the database message
      var baseUrl = url_for('debugger.execute_query', {
        'trans_id': trans_id,
        'query_type': 'get_stack_info'
      });
      $.ajax({
        url: baseUrl,
        method: 'GET',
        success: function success(res) {
          if (res.data.status === 'Success') {
            // Call function to create and update stack information
            self.AddStackInformation(res.data.result);
            self.GetLocalVariables(pgTools.DirectDebug.trans_id);
          } else if (res.data.status === 'NotConnected') {
            Alertify.alert('Debugger Error', 'Error while fetching stack information.');
          }
        },
        error: function error(e) {
          Alertify.alert('Debugger Error', 'Error while fetching stack information.');
        }
      });
    },

    /*
      poll the actual result after user has executed the "continue", "step-into", "step-over" actions and get the
      other updated information from the server.
    */
    poll_result: function poll_result(trans_id) {
      var self = this;

      // Do we need to poll?
      if (!pgTools.DirectDebug.is_polling_required) {
        return;
      }

      // Make ajax call to listen the database message
      var baseUrl = url_for('debugger.poll_result', { 'trans_id': trans_id });

      /*
        During the execution we should poll the result in minimum seconds but once the execution is completed
        and wait for the another debugging session then we should decrease the polling frequency.
      */
      if (pgTools.DirectDebug.polling_timeout_idle) {
        // poll the result after 1 second
        var poll_timeout = 1000;
      } else {
        // poll the result after 200 ms
        var poll_timeout = 200;
      }

      setTimeout(function () {
        $.ajax({
          url: baseUrl,
          method: 'GET',
          beforeSend: function beforeSend(jqXHR, settings) {
            // set cursor to progress before every poll.
            $('.debugger-container').addClass('show_progress');
          },
          success: function success(res) {
            // remove progress cursor
            $('.debugger-container').removeClass('show_progress');

            if (res.data.status === 'Success') {
              // If no result then poll again to wait for results.
              if (res.data.result == null || res.data.result.length == 0) {
                self.poll_result(trans_id);
              } else {
                if (res.data.result[0].src != undefined || res.data.result[0].src != null) {
                  pgTools.DirectDebug.polling_timeout_idle = false;
                  pgTools.DirectDebug.docker.finishLoading(50);
                  pgTools.DirectDebug.editor.setValue(res.data.result[0].src);
                  self.UpdateBreakpoint(trans_id);
                  pgTools.DirectDebug.editor.removeLineClass(self.active_line_no, 'wrap', 'CodeMirror-activeline-background');
                  pgTools.DirectDebug.editor.addLineClass(res.data.result[0].linenumber - 2, 'wrap', 'CodeMirror-activeline-background');
                  self.active_line_no = res.data.result[0].linenumber - 2;

                  // Update the stack, local variables and parameters information
                  self.GetStackInformation(trans_id);
                } else if (!pgTools.DirectDebug.debug_type && !pgTools.DirectDebug.first_time_indirect_debug) {
                  pgTools.DirectDebug.docker.finishLoading(50);
                  if (self.active_line_no != undefined) {
                    pgTools.DirectDebug.editor.removeLineClass(self.active_line_no, 'wrap', 'CodeMirror-activeline-background');
                  }
                  self.clear_all_breakpoint(trans_id);
                  self.execute_query(trans_id);
                  pgTools.DirectDebug.first_time_indirect_debug = true;
                  pgTools.DirectDebug.polling_timeout_idle = false;
                } else {
                  pgTools.DirectDebug.polling_timeout_idle = false;
                  pgTools.DirectDebug.docker.finishLoading(50);
                  // If the source is really changed then only update the breakpoint information
                  if (res.data.result[0].src != pgTools.DirectDebug.editor.getValue()) {
                    pgTools.DirectDebug.editor.setValue(res.data.result[0].src);
                    self.UpdateBreakpoint(trans_id);
                  }

                  pgTools.DirectDebug.editor.removeLineClass(self.active_line_no, 'wrap', 'CodeMirror-activeline-background');
                  pgTools.DirectDebug.editor.addLineClass(res.data.result[0].linenumber - 2, 'wrap', 'CodeMirror-activeline-background');
                  self.active_line_no = res.data.result[0].linenumber - 2;

                  // Update the stack, local variables and parameters information
                  self.GetStackInformation(trans_id);
                }

                // Enable all the buttons as we got the results
                self.enable('stop', true);
                self.enable('step_over', true);
                self.enable('step_into', true);
                self.enable('continue', true);
                self.enable('toggle_breakpoint', true);
                self.enable('clear_all_breakpoints', true);
              }
            } else if (res.data.status === 'Busy') {
              pgTools.DirectDebug.polling_timeout_idle = true;
              // If status is Busy then poll the result by recursive call to the poll function
              if (!pgTools.DirectDebug.debug_type) {
                pgTools.DirectDebug.docker.startLoading(gettext('Waiting for another session to invoke the target...'));

                // As we are waiting for another session to invoke the target,disable all the buttons
                self.enable('stop', false);
                self.enable('step_over', false);
                self.enable('step_into', false);
                self.enable('continue', false);
                self.enable('toggle_breakpoint', false);
                self.enable('clear_all_breakpoints', false);
                pgTools.DirectDebug.first_time_indirect_debug = false;
                self.poll_result(trans_id);
              } else {
                self.poll_result(trans_id);
              }
            } else if (res.data.status === 'NotConnected') {
              Alertify.alert('Debugger Error', 'Error while polling result.');
            }
          },
          error: function error(e) {
            Alertify.alert('Debugger Error', 'Error while polling result.');
          }
        });
      }, poll_timeout);
    },

    // This function will update messages tab
    update_messages: function update_messages(msg) {
      // To prevent xss
      msg = _.escape(msg);

      var old_msgs = '',
          new_msgs = '';
      old_msgs = pgTools.DirectDebug.messages_panel.$container.find('.messages').html();
      if (old_msgs) {
        new_msgs = (old_msgs + '\n' + msg).replace(/(?:\r\n|\r|\n)/g, '<br />') // Newlines with <br>
        .replace(/(<br\ ?\/?>)+/g, '<br />'); // multiple <br> with single <br>
      } else {
        new_msgs = msg;
      }
      pgTools.DirectDebug.messages_panel.$container.find('.messages').html(new_msgs);
    },

    /*
      For the direct debugging, we need to check weather the functions execution is completed or not. After completion
      of the debugging, we will stop polling the result  until new execution starts.
    */
    poll_end_execution_result: function poll_end_execution_result(trans_id) {
      var self = this;

      // Do we need to poll?
      if (!pgTools.DirectDebug.is_polling_required) {
        return;
      }

      // Make ajax call to listen the database message
      var baseUrl = url_for('debugger.poll_end_execution_result', { 'trans_id': trans_id });

      /*
        During the execution we should poll the result in minimum seconds but once the execution is completed
        and wait for the another debugging session then we should decrease the polling frequency.
      */
      if (pgTools.DirectDebug.polling_timeout_idle) {
        // poll the result to check that execution is completed or not after 1200 ms
        var poll_end_timeout = 1200;
      } else {
        // poll the result to check that execution is completed or not after 350 ms
        var poll_end_timeout = 250;
      }

      setTimeout(function () {
        $.ajax({
          url: baseUrl,
          method: 'GET',
          success: function success(res) {
            if (res.data.status === 'Success') {
              if (res.data.result == undefined) {
                /*
                 "result" is undefined only in case of EDB procedure. As Once the EDB procedure execution is completed
                 then we are not getting any result so we need ignore the result.
                */
                pgTools.DirectDebug.editor.removeLineClass(self.active_line_no, 'wrap', 'CodeMirror-activeline-background');
                pgTools.DirectDebug.direct_execution_completed = true;
                pgTools.DirectDebug.polling_timeout_idle = true;

                //Set the alertify message to inform the user that execution is completed.
                Alertify.success(res.info, 3);

                // Update the message tab of the debugger
                if (res.data.status_message) {
                  self.update_messages(res.data.status_message);
                }

                // remove progress cursor
                $('.debugger-container').removeClass('show_progress');

                // Execution completed so disable the buttons other than "Continue/Start" button because user can still
                // start the same execution again.
                self.enable('stop', false);
                self.enable('step_over', false);
                self.enable('step_into', false);
                self.enable('toggle_breakpoint', false);
                self.enable('clear_all_breakpoints', false);
                self.enable('continue', true);
                // Stop further polling
                pgTools.DirectDebug.is_polling_required = false;
              } else {
                // Call function to create and update local variables ....
                if (res.data.result != null) {
                  pgTools.DirectDebug.editor.removeLineClass(self.active_line_no, 'wrap', 'CodeMirror-activeline-background');
                  self.AddResults(res.data.col_info, res.data.result);
                  pgTools.DirectDebug.results_panel.focus();
                  pgTools.DirectDebug.direct_execution_completed = true;
                  pgTools.DirectDebug.polling_timeout_idle = true;

                  //Set the alertify message to inform the user that execution is completed.
                  Alertify.success(res.info, 3);

                  // Update the message tab of the debugger
                  if (res.data.status_message) {
                    self.update_messages(res.data.status_message);
                  }

                  // remove progress cursor
                  $('.debugger-container').removeClass('show_progress');

                  // Execution completed so disable the buttons other than "Continue/Start" button because user can still
                  // start the same execution again.
                  self.enable('stop', false);
                  self.enable('step_over', false);
                  self.enable('step_into', false);
                  self.enable('toggle_breakpoint', false);
                  self.enable('clear_all_breakpoints', false);
                  self.enable('continue', true);

                  // Stop further pooling
                  pgTools.DirectDebug.is_polling_required = false;
                }
              }
            } else if (res.data.status === 'Busy') {
              // If status is Busy then poll the result by recursive call to the poll function
              self.poll_end_execution_result(trans_id);
              // Update the message tab of the debugger
              if (res.data.status_message) {
                self.update_messages(res.data.status_message);
              }
            } else if (res.data.status === 'NotConnected') {
              Alertify.alert('Debugger poll end execution error', res.data.result);
            } else if (res.data.status === 'ERROR') {
              pgTools.DirectDebug.direct_execution_completed = true;
              pgTools.DirectDebug.editor.removeLineClass(self.active_line_no, 'wrap', 'CodeMirror-activeline-background');

              //Set the Alertify message to inform the user that execution is completed with error.
              if (!pgTools.DirectDebug.is_user_aborted_debugging) {
                Alertify.error(res.info, 3);
              }

              // Update the message tab of the debugger
              if (res.data.status_message) {
                self.update_messages(res.data.status_message);
              }

              pgTools.DirectDebug.messages_panel.focus();

              // remove progress cursor
              $('.debugger-container').removeClass('show_progress');

              // Execution completed so disable the buttons other than
              // "Continue/Start" button because user can still start the
              // same execution again.
              self.enable('stop', false);
              self.enable('step_over', false);
              self.enable('step_into', false);
              self.enable('toggle_breakpoint', false);
              self.enable('clear_all_breakpoints', false);
              // If debugging is stopped by user then do not enable
              // continue/restart button
              if (!pgTools.DirectDebug.is_user_aborted_debugging) {
                self.enable('continue', true);
                pgTools.DirectDebug.is_user_aborted_debugging = false;
              }

              // Stop further pooling
              pgTools.DirectDebug.is_polling_required = false;
            }
          },
          error: function error(e) {
            Alertify.alert('Debugger Error', 'Error while polling result.');
          }
        });
      }, poll_end_timeout);
    },

    Restart: function Restart(trans_id) {

      var self = this,
          baseUrl = url_for('debugger.restart', { 'trans_id': trans_id });
      self.enable('stop', false);
      self.enable('step_over', false);
      self.enable('step_into', false);
      self.enable('toggle_breakpoint', false);
      self.enable('clear_all_breakpoints', false);
      self.enable('continue', false);

      // Clear msg tab
      pgTools.DirectDebug.messages_panel.$container.find('.messages').html('');

      $.ajax({
        url: baseUrl,
        success: function success(res) {
          // Restart the same function debugging with previous arguments
          var restart_dbg = res.data.restart_debug ? 1 : 0;

          // Start pooling again
          pgTools.DirectDebug.polling_timeout_idle = false;
          pgTools.DirectDebug.is_polling_required = true;
          self.poll_end_execution_result(trans_id);
          self.poll_result(trans_id);

          if (restart_dbg) {
            pgTools.DirectDebug.debug_restarted = true;
          }

          /*
           Need to check if restart debugging really require to open the input dialog ?
           If yes then we will get the previous arguments from database and populate the input dialog
           If no then we should directly start the listener.
          */
          if (res.data.result.require_input) {
            var res_val = debug_function_again(res.data.result, restart_dbg);
          } else {
            // Debugging of void function is started again so we need to start the listener again
            var baseUrl = url_for('debugger.start_listener', { 'trans_id': trans_id });

            $.ajax({
              url: baseUrl,
              method: 'GET',
              success: function success(res) {
                if (pgTools.DirectDebug.debug_type) {
                  self.poll_end_execution_result(trans_id);
                }
              },
              error: function error(e) {
                Alertify.alert('Debugger Error', 'Error while polling result.');
              }
            });
          }
        },
        error: function error(xhr, status, _error) {
          try {
            var err = $.parseJSON(xhr.responseText);
            if (err.success == 0) {
              Alertify.alert(err.errormsg);
            }
          } catch (e) {}
        }
      });
    },

    // Continue the execution until the next breakpoint
    Continue: function Continue(trans_id) {
      var self = this;
      self.enable('stop', false);
      self.enable('step_over', false);
      self.enable('step_into', false);
      self.enable('toggle_breakpoint', false);
      self.enable('clear_all_breakpoints', false);
      self.enable('continue', false);

      //Check first if previous execution was completed or not
      if (pgTools.DirectDebug.direct_execution_completed && pgTools.DirectDebug.direct_execution_completed == pgTools.DirectDebug.polling_timeout_idle) {
        self.Restart(trans_id);
      } else {
        // Make ajax call to listen the database message
        var baseUrl = url_for('debugger.execute_query', {
          'trans_id': trans_id,
          'query_type': 'continue'
        });
        $.ajax({
          url: baseUrl,
          method: 'GET',
          success: function success(res) {
            if (res.data.status) {
              self.poll_result(trans_id);
            } else {
              Alertify.alert('Debugger Error', 'Error while executing continue in debugging session.');
            }
          },
          error: function error(e) {
            Alertify.alert('Debugger Error', 'Error while executing continue in debugging session.');
          }
        });
      }
    },

    Step_over: function Step_over(trans_id) {
      var self = this;
      self.enable('stop', false);
      self.enable('step_over', false);
      self.enable('step_into', false);
      self.enable('toggle_breakpoint', false);
      self.enable('clear_all_breakpoints', false);
      self.enable('continue', false);

      // Make ajax call to listen the database message
      var baseUrl = url_for('debugger.execute_query', {
        'trans_id': trans_id,
        'query_type': 'step_over'
      });
      $.ajax({
        url: baseUrl,
        method: 'GET',
        success: function success(res) {
          if (res.data.status) {
            self.poll_result(trans_id);
          } else {
            Alertify.alert('Debugger Error', 'Error while executing step over in debugging session.');
          }
        },
        error: function error(e) {
          Alertify.alert('Debugger Error', 'Error while executing step over in debugging session.');
        }
      });
    },

    Step_into: function Step_into(trans_id) {
      var self = this;
      self.enable('stop', false);
      self.enable('step_over', false);
      self.enable('step_into', false);
      self.enable('toggle_breakpoint', false);
      self.enable('clear_all_breakpoints', false);
      self.enable('continue', false);

      // Make ajax call to listen the database message
      var baseUrl = url_for('debugger.execute_query', {
        'trans_id': trans_id,
        'query_type': 'step_into'
      });
      $.ajax({
        url: baseUrl,
        method: 'GET',
        success: function success(res) {
          if (res.data.status) {
            self.poll_result(trans_id);
          } else {
            Alertify.alert('Debugger Error', 'Error while executing step into in debugging session.');
          }
        },
        error: function error(e) {
          Alertify.alert('Debugger Error', 'Error while executing step into in debugging session.');
        }
      });
    },

    Stop: function Stop(trans_id) {
      var self = this;
      self.enable('stop', false);
      self.enable('step_over', false);
      self.enable('step_into', false);
      self.enable('toggle_breakpoint', false);
      self.enable('clear_all_breakpoints', false);
      self.enable('continue', false);

      // Make ajax call to listen the database message
      var baseUrl = url_for('debugger.execute_query', {
        'trans_id': trans_id,
        'query_type': 'abort_target'
      });
      $.ajax({
        url: baseUrl,
        method: 'GET',
        success: function success(res) {
          if (res.data.status) {
            // Call function to create and update local variables ....
            pgTools.DirectDebug.editor.removeLineClass(self.active_line_no, 'wrap', 'CodeMirror-activeline-background');
            pgTools.DirectDebug.direct_execution_completed = true;
            pgTools.DirectDebug.is_user_aborted_debugging = true;

            // Stop further pooling
            pgTools.DirectDebug.is_polling_required = false;

            // Restarting debugging in the same transaction do not work
            // We will give same behaviour as pgAdmin3 and disable all buttons
            self.enable('continue', false);

            // Set the Alertify message to inform the user that execution
            // is completed.
            Alertify.success(res.info, 3);
          } else if (res.data.status === 'NotConnected') {
            Alertify.alert('Debugger Error', 'Error while executing stop in debugging session.');
          }
        },
        error: function error(e) {
          Alertify.alert('Debugger Error', 'Error while executing stop in debugging session.');
        }
      });
    },

    toggle_breakpoint: function toggle_breakpoint(trans_id) {
      var self = this;
      self.enable('stop', false);
      self.enable('step_over', false);
      self.enable('step_into', false);
      self.enable('toggle_breakpoint', false);
      self.enable('clear_all_breakpoints', false);
      self.enable('continue', false);

      var info = pgTools.DirectDebug.editor.lineInfo(self.active_line_no);
      var baseUrl = '';

      // If gutterMarker is undefined that means there is no marker defined previously
      // So we need to set the breakpoint command here...
      if (info.gutterMarkers == undefined) {
        baseUrl = url_for('debugger.set_breakpoint', {
          'trans_id': trans_id,
          'line_no': self.active_line_no + 1,
          'set_type': '1'
        });
      } else {
        baseUrl = url_for('debugger.set_breakpoint', {
          'trans_id': trans_id,
          'line_no': self.active_line_no + 1,
          'set_type': '0'
        });
      }

      $.ajax({
        url: baseUrl,
        method: 'GET',
        success: function success(res) {
          if (res.data.status) {
            // Call function to create and update local variables ....
            var info = pgTools.DirectDebug.editor.lineInfo(self.active_line_no);

            if (info.gutterMarkers != undefined) {
              pgTools.DirectDebug.editor.setGutterMarker(self.active_line_no, "breakpoints", null);
            } else {
              pgTools.DirectDebug.editor.setGutterMarker(self.active_line_no, "breakpoints", function () {
                var marker = document.createElement("div");
                marker.style.color = "#822";
                marker.innerHTML = "";
                return marker;
              }());
            }
            self.enable('stop', true);
            self.enable('step_over', true);
            self.enable('step_into', true);
            self.enable('toggle_breakpoint', true);
            self.enable('clear_all_breakpoints', true);
            self.enable('continue', true);
          } else if (res.data.status === 'NotConnected') {
            Alertify.alert('Debugger Error', 'Error while toggling breakpoint.');
          }
        },
        error: function error(e) {
          Alertify.alert('Debugger Error', 'Error while toggling breakpoint.');
        }
      });
    },

    clear_all_breakpoint: function clear_all_breakpoint(trans_id) {
      var self = this,
          br_list = self.GetBreakpointInformation(trans_id);

      // If there is no break point to clear then we should return from here.
      if (br_list.length == 1 && br_list[0].linenumber == -1) return;

      self.enable('stop', false);
      self.enable('step_over', false);
      self.enable('step_into', false);
      self.enable('toggle_breakpoint', false);
      self.enable('clear_all_breakpoints', false);
      self.enable('continue', false);

      var breakpoint_list = new Array();

      for (var i = 0; i < br_list.length; i++) {
        if (br_list[i].linenumber != -1) {
          breakpoint_list.push(br_list[i].linenumber);
        }
      }

      // Make ajax call to listen the database message
      var baseUrl = url_for('debugger.clear_all_breakpoint', { 'trans_id': trans_id });

      $.ajax({
        url: baseUrl,
        method: 'POST',
        data: { 'breakpoint_list': breakpoint_list.join() },
        success: function success(res) {
          if (res.data.status) {
            for (var i = 0; i < breakpoint_list.length; i++) {
              var info = pgTools.DirectDebug.editor.lineInfo(breakpoint_list[i] - 1);

              if (info) {
                if (info.gutterMarkers != undefined) {
                  pgTools.DirectDebug.editor.setGutterMarker(breakpoint_list[i] - 1, "breakpoints", null);
                }
              }
            }
          }
          self.enable('stop', true);
          self.enable('step_over', true);
          self.enable('step_into', true);
          self.enable('toggle_breakpoint', true);
          self.enable('clear_all_breakpoints', true);
          self.enable('continue', true);
        },
        error: function error(e) {
          Alertify.alert('Debugger Error', 'Error while clearing all breakpoint.');
        }
      });
    },

    AddStackInformation: function AddStackInformation(result) {
      var self = this;

      // Remove the existing created grid and update the stack values
      if (self.stack_grid) {
        self.stack_grid.remove();
        self.stack_grid = null;
      }

      var DebuggerStackModel = Backbone.Model.extend({
        defaults: {
          name: undefined,
          value: undefined,
          line_no: undefined
        }
      });

      // Collection which contains the model for function informations.
      var StackCollection = Backbone.Collection.extend({
        model: DebuggerStackModel
      });

      var stackGridCols = [{ name: 'name', label: 'Name', type: 'text', editable: false, cell: 'string' }, { name: 'value', label: 'Value', type: 'text', editable: false, cell: 'string' }, { name: 'line_no', label: 'Line No.', type: 'text', editable: false, cell: 'string' }];

      var my_obj = [];
      if (result.length != 0) {
        for (var i = 0; i < result.length; i++) {
          my_obj.push({ "name": result[i].targetname, "value": result[i].args, "line_no": result[i].linenumber });
        }
      }

      var stackColl = this.stackColl = new StackCollection(my_obj);
      this.stackColl.on('backgrid:row:selected', self.select_frame, self);

      // Initialize a new Grid instance
      var stack_grid = this.stack_grid = new Backgrid.Grid({
        columns: stackGridCols,
        row: Backgrid.Row.extend({
          highlightColor: "#D9EDF7",
          disabledColor: "#F1F1F1",
          events: {
            click: "rowClick"
          },
          rowClick: function rowClick(e) {
            //Find which row is selected and depending on that send the frame id
            for (var i = 0; i < this.model.collection.length; i++) {
              if (this.model.collection.models[i].get('name') == this.model.get('name')) {
                self.frame_id_ = i;
                break;
              }
            }
            this.model.trigger('backgrid:row:selected', this);
            self.stack_grid.$el.find("td").css("background-color", this.disabledColor);
            this.$el.find("td").css("background-color", this.highlightColor);
          }
        }),
        collection: stackColl,
        className: "backgrid table-bordered"
      });

      stack_grid.render();

      // Render the stack grid into stack panel
      pgTools.DirectDebug.stack_pane_panel.$container.find('.stack_pane').append(stack_grid.el);
    },

    AddResults: function AddResults(columns, result) {
      var self = this;

      // Remove the existing created grid and update the result values
      if (self.result_grid) {
        self.result_grid.remove();
        self.result_grid = null;
      }

      var DebuggerResultsModel = Backbone.Model.extend({
        defaults: {
          name: undefined
        }
      });

      // Collection which contains the model for function informations.
      var ResultsCollection = Backbone.Collection.extend({
        model: DebuggerResultsModel
      });

      var resultGridCols = [];
      if (_.size(columns)) {
        _.each(columns, function (c) {
          var column = {
            type: 'text',
            editable: false,
            cell: 'string'
          };
          column['name'] = column['label'] = c.name;
          resultGridCols.push(column);
        });
      }

      // Initialize a new Grid instance
      var result_grid = this.result_grid = new Backgrid.Grid({
        columns: resultGridCols,
        collection: new ResultsCollection(result),
        className: "backgrid table-bordered"
      });

      result_grid.render();

      // Render the result grid into result panel
      pgTools.DirectDebug.results_panel.$container.find('.debug_results').append(result_grid.el);
    },

    AddLocalVariables: function AddLocalVariables(result) {
      var self = this;

      // Remove the existing created grid and update the variables values
      if (self.variable_grid) {
        self.variable_grid.remove();
        self.variable_grid = null;
      }

      var DebuggerVariablesModel = Backbone.Model.extend({
        defaults: {
          name: undefined,
          type: undefined,
          value: undefined
        }
      });

      // Collection which contains the model for function informations.
      var VariablesCollection = Backbone.Collection.extend({
        model: DebuggerVariablesModel
      });

      var gridCols = [{ name: 'name', label: 'Name', type: 'text', editable: false, cell: 'string' }, { name: 'type', label: 'Type', type: 'text', editable: false, cell: 'string' }, { name: 'value', label: 'Value', type: 'text', cell: 'string' }];

      var my_obj = [];
      if (result.length != 0) {
        for (var i = 0; i < result.length; i++) {
          if (result[i].varclass == 'L') {
            my_obj.push({ "name": result[i].name, "type": result[i].dtype, "value": result[i].value });
          }
        }
      }

      // Initialize a new Grid instance
      var variable_grid = this.variable_grid = new Backgrid.Grid({
        columns: gridCols,
        collection: new VariablesCollection(my_obj),
        className: "backgrid table-bordered"
      });

      variable_grid.render();

      // Render the variables grid into local variables panel
      pgTools.DirectDebug.local_variables_panel.$container.find('.local_variables').append(variable_grid.el);
    },

    AddParameters: function AddParameters(result) {
      var self = this;

      // Remove the existing created grid and update the parameter values
      if (self.param_grid) {
        self.param_grid.remove();
        self.param_grid = null;
      }

      var DebuggerParametersModel = Backbone.Model.extend({
        defaults: {
          name: undefined,
          type: undefined,
          value: undefined
        }
      });

      // Collection which contains the model for function informations.
      var ParametersCollection = self.ParametersCollection = Backbone.Collection.extend({
        model: DebuggerParametersModel
      });

      self.ParametersCollection.prototype.on('change', self.deposit_parameter_value, self);

      var paramGridCols = [{ name: 'name', label: 'Name', type: 'text', editable: false, cell: 'string' }, { name: 'type', label: 'Type', type: 'text', editable: false, cell: 'string' }, { name: 'value', label: 'Value', type: 'text', cell: 'string' }];

      var param_obj = [];
      if (result.length != 0) {
        for (var i = 0; i < result.length; i++) {
          if (result[i].varclass == 'A') {
            param_obj.push({ "name": result[i].name, "type": result[i].dtype, "value": result[i].value });
          }
        }
      }

      // Initialize a new Grid instance
      var param_grid = this.param_grid = new Backgrid.Grid({
        columns: paramGridCols,
        collection: new ParametersCollection(param_obj),
        className: "backgrid table-bordered"
      });

      param_grid.render();

      // Render the parameters grid into parameter panel
      pgTools.DirectDebug.parameters_panel.$container.find('.parameters').append(param_grid.el);
    },

    deposit_parameter_value: function deposit_parameter_value(model) {
      var self = this;

      // variable name and value list that is changed by user
      var name_value_list = [];

      name_value_list.push({ 'name': model.get('name'), 'type': model.get('type'), 'value': model.get('value') });

      // Make ajax call to listen the database message
      var baseUrl = url_for('debugger.deposit_value', {
        'trans_id': pgTools.DirectDebug.trans_id
      });
      $.ajax({
        url: baseUrl,
        method: 'POST',
        data: { 'data': JSON.stringify(name_value_list) },
        success: function success(res) {
          if (res.data.status) {
            // Get the updated variables value
            self.GetLocalVariables(pgTools.DirectDebug.trans_id);
            // Show the message to the user that deposit value is success or failure
            if (res.data.result) {
              Alertify.success(res.data.info, 3);
            } else {
              Alertify.error(res.data.info, 3);
            }
          }
        },
        error: function error(e) {
          Alertify.alert('Debugger Error', 'Error while depositing variable value.');
        }
      });
    },

    select_frame: function select_frame(model, selected) {
      var self = this;

      // Make ajax call to listen the database message
      var baseUrl = url_for('debugger.select_frame', {
        'trans_id': pgTools.DirectDebug.trans_id,
        'frame_id': self.frame_id_
      });
      $.ajax({
        url: baseUrl,
        method: 'GET',
        success: function success(res) {
          if (res.data.status) {
            pgTools.DirectDebug.editor.setValue(res.data.result[0].src);
            self.UpdateBreakpoint(pgTools.DirectDebug.trans_id);
            //active_line_no = self.active_line_no = (res.data.result[0].linenumber - 2);
            pgTools.DirectDebug.editor.addLineClass(res.data.result[0].linenumber - 2, 'wrap', 'CodeMirror-activeline-background');

            // Call function to create and update local variables ....
            self.GetLocalVariables(pgTools.DirectDebug.trans_id);
          }
        },
        error: function error(e) {
          Alertify.alert('Debugger Error', 'Error while selecting frame.');
        }
      });
    }
  });

  /*
    Debugger tool var view to create the button toolbar and listen to the button click event and inform the
    controller about the click and controller will take the action for the specified button click.
  */
  var DebuggerToolbarView = Backbone.View.extend({
    el: '#btn-toolbar',
    initialize: function initialize() {
      controller.on('pgDebugger:button:state:stop', this.enable_stop, this);
      controller.on('pgDebugger:button:state:step_over', this.enable_step_over, this);
      controller.on('pgDebugger:button:state:step_into', this.enable_step_into, this);
      controller.on('pgDebugger:button:state:continue', this.enable_continue, this);
      controller.on('pgDebugger:button:state:toggle_breakpoint', this.enable_toggle_breakpoint, this);
      controller.on('pgDebugger:button:state:clear_all_breakpoints', this.enable_clear_all_breakpoints, this);
    },
    events: {
      'click .btn-stop': 'on_stop',
      'click .btn-clear-breakpoint': 'on_clear_all_breakpoint',
      'click .btn-toggle-breakpoint': 'on_toggle_breakpoint',
      'click .btn-continue': 'on_continue',
      'click .btn-step-over': 'on_step_over',
      'click .btn-step-into': 'on_step_into'
    },
    enable_stop: function enable_stop(enable) {
      var $btn = this.$el.find('.btn-stop');

      if (enable) {
        $btn.prop('disabled', false);
        $btn.removeAttr('disabled');
      } else {
        $btn.prop('disabled', true);
        $btn.attr('disabled', 'disabled');
      }
    },
    enable_step_over: function enable_step_over(enable) {
      var $btn = this.$el.find('.btn-step-over');

      if (enable) {
        $btn.prop('disabled', false);
        $btn.removeAttr('disabled');
      } else {
        $btn.prop('disabled', true);
        $btn.attr('disabled', 'disabled');
      }
    },
    enable_step_into: function enable_step_into(enable) {
      var $btn = this.$el.find('.btn-step-into');

      if (enable) {
        $btn.prop('disabled', false);
        $btn.removeAttr('disabled');
      } else {
        $btn.prop('disabled', true);
        $btn.attr('disabled', 'disabled');
      }
    },
    enable_continue: function enable_continue(enable) {
      var $btn = this.$el.find('.btn-continue');

      if (enable) {
        $btn.prop('disabled', false);
        $btn.removeAttr('disabled');
      } else {
        $btn.prop('disabled', true);
        $btn.attr('disabled', 'disabled');
      }
    },
    enable_toggle_breakpoint: function enable_toggle_breakpoint(enable) {
      var $btn = this.$el.find('.btn-toggle-breakpoint');

      if (enable) {
        $btn.prop('disabled', false);
        $btn.removeAttr('disabled');
      } else {
        $btn.prop('disabled', true);
        $btn.attr('disabled', 'disabled');
      }
    },
    enable_clear_all_breakpoints: function enable_clear_all_breakpoints(enable) {
      var $btn = this.$el.find('.btn-clear-breakpoint');

      if (enable) {
        $btn.prop('disabled', false);
        $btn.removeAttr('disabled');
      } else {
        $btn.prop('disabled', true);
        $btn.attr('disabled', 'disabled');
      }
    },

    on_stop: function on_stop() {
      controller.Stop(pgTools.DirectDebug.trans_id);
    },
    on_clear_all_breakpoint: function on_clear_all_breakpoint() {
      controller.clear_all_breakpoint(pgTools.DirectDebug.trans_id);
    },
    on_toggle_breakpoint: function on_toggle_breakpoint() {
      controller.toggle_breakpoint(pgTools.DirectDebug.trans_id);
    },
    on_continue: function on_continue() {
      controller.Continue(pgTools.DirectDebug.trans_id);
    },
    on_step_over: function on_step_over() {
      controller.Step_over(pgTools.DirectDebug.trans_id);
    },
    on_step_into: function on_step_into() {
      controller.Step_into(pgTools.DirectDebug.trans_id);
    }
  });

  /*
    Function is responsible to create the new wcDocker instance for debugger and initialize the debugger panel inside
    the docker instance.
  */
  var DirectDebug = function DirectDebug() {};

  _.extend(DirectDebug.prototype, {
    init: function init(trans_id, debug_type) {
      /* We should get the transaction id from the server during initialization here */
      // We do not want to initialize the module multiple times.

      var self = this;
      _.bindAll(pgTools.DirectDebug, 'messages');

      if (this.initialized) return;

      this.initialized = true;
      this.trans_id = trans_id;
      this.debug_type = debug_type;
      this.first_time_indirect_debug = false;
      this.direct_execution_completed = false;
      this.polling_timeout_idle = false;
      this.debug_restarted = false;
      this.is_user_aborted_debugging = false;
      this.is_polling_required = true; // Flag to stop unwanted ajax calls

      var docker = this.docker = new wcDocker('#container', {
        allowContextMenu: false,
        allowCollapse: false,
        themePath: url_for('static', { 'filename': 'css' }),
        theme: 'webcabin.overrides.css'
      });

      this.panels = [];

      // Below code will be executed for indirect debugging
      // indirect debugging - 0  and for direct debugging - 1
      if (trans_id != undefined && !debug_type) {
        // Make ajax call to execute the and start the target for execution
        var baseUrl = url_for('debugger.start_listener', { 'trans_id': trans_id });

        $.ajax({
          url: baseUrl,
          method: 'GET',
          success: function success(res) {
            if (res.data.status) {
              self.intializePanels();
              controller.poll_result(trans_id);
            }
          },
          error: function error(e) {
            Alertify.alert('Debugger Error', 'Error while starting debugging listener.');
          }
        });
      } else if (trans_id != undefined && debug_type) {
        // Make ajax call to execute the and start the target for execution
        var baseUrl = url_for('debugger.start_listener', { 'trans_id': trans_id });

        $.ajax({
          url: baseUrl,
          method: 'GET',
          success: function success(res) {
            if (res.data.status) {
              self.messages(trans_id);
            }
          },
          error: function error(e) {
            Alertify.alert('Debugger Error', 'Error while starting debugging listener.');
          }
        });
      } else this.intializePanels();
    },

    // Read the messages of the database server and get the port ID and attach the executer to that port.
    messages: function messages(trans_id) {
      var self = this;
      // Make ajax call to listen the database message
      var baseUrl = url_for('debugger.messages', { 'trans_id': trans_id });

      $.ajax({
        url: baseUrl,
        method: 'GET',
        success: function success(res) {
          if (res.data.status === 'Success') {
            self.intializePanels();
            // If status is Success then find the port number to attach the executer.
            //self.start_execution(trans_id, res.data.result);
            controller.start_execution(trans_id, res.data.result);
          } else if (res.data.status === 'Busy') {
            // If status is Busy then poll the result by recursive call to the poll function
            self.messages(trans_id);
          } else if (res.data.status === 'NotConnected') {
            Alertify.alert('Not connected to server or connection with the server has been closed.', res.data.result);
          }
        },
        error: function error(e) {
          Alertify.alert('Debugger Error', 'Error while fetching messages information.');
        }
      });
    },

    // Callback function when user click on gutters of codemirror to set/clear the breakpoint
    onBreakPoint: function onBreakPoint(cm, m, gutter) {
      var self = this;

      // If breakpoint gutter is clicked and execution is not completed then only set the breakpoint
      if (gutter == "breakpoints" && !pgTools.DirectDebug.polling_timeout_idle) {
        // We may want to check, if break-point is allowed at this moment or not
        var info = cm.lineInfo(m);

        // If gutterMarker is undefined that means there is no marker defined previously
        // So we need to set the breakpoint command here...
        if (info.gutterMarkers == undefined) {
          controller.set_breakpoint(self.trans_id, m + 1, 1); //set the breakpoint
        } else {
          if (info.gutterMarkers.breakpoints == undefined) {
            controller.set_breakpoint(self.trans_id, m + 1, 1); //set the breakpoint
          } else {
            controller.set_breakpoint(self.trans_id, m + 1, 0); //clear the breakpoint
          }
        }

        // If line folding is defined then gutterMarker will be defined so
        // we need to find out 'breakpoints' information
        var markers = info.gutterMarkers;
        if (markers != undefined && info.gutterMarkers.breakpoints == undefined) markers = info.gutterMarkers.breakpoints;

        cm.setGutterMarker(m, "breakpoints", markers ? null : function () {
          var marker = document.createElement("div");

          marker.style.color = "#822";
          marker.innerHTML = "";

          return marker;
        }());
      }
    },

    // Create the debugger layout with splitter and display the appropriate data received from server.
    intializePanels: function intializePanels() {
      var self = this;
      this.registerPanel('code', false, '100%', '50%', function (panel) {

        // Create the parameters panel to display the arguments of the functions
        var parameters = new pgAdmin.Browser.Panel({
          name: 'parameters',
          title: gettext('Parameters'),
          width: '100%',
          height: '100%',
          isCloseable: false,
          isPrivate: true,
          content: '<div id ="parameters" class="parameters"></div>'
        });

        // Create the Local variables panel to display the local variables of the function.
        var local_variables = new pgAdmin.Browser.Panel({
          name: 'local_variables',
          title: gettext('Local variables'),
          width: '100%',
          height: '100%',
          isCloseable: false,
          isPrivate: true,
          content: '<div id ="local_variables" class="local_variables"></div>'
        });

        // Create the messages panel to display the message returned from the database server
        var messages = new pgAdmin.Browser.Panel({
          name: 'messages',
          title: gettext('Messages'),
          width: '100%',
          height: '100%',
          isCloseable: false,
          isPrivate: true,
          content: '<div id="messages" class="messages"></div>'
        });

        // Create the result panel to display the result after debugging the function
        var results = new pgAdmin.Browser.Panel({
          name: 'results',
          title: gettext('Results'),
          width: '100%',
          height: '100%',
          isCloseable: false,
          isPrivate: true,
          content: '<div id="debug_results" class="debug_results"></div>'
        });

        // Create the stack pane panel to display the debugging stack information.
        var stack_pane = new pgAdmin.Browser.Panel({
          name: 'stack_pane',
          title: gettext('Stack'),
          width: '100%',
          height: '100%',
          isCloseable: false,
          isPrivate: true,
          content: '<div id="stack_pane" class="stack_pane"></div>'
        });

        // Load all the created panels
        parameters.load(self.docker);
        local_variables.load(self.docker);
        messages.load(self.docker);
        results.load(self.docker);
        stack_pane.load(self.docker);
      });

      self.code_editor_panel = self.docker.addPanel('code', wcDocker.DOCK.TOP);

      self.parameters_panel = self.docker.addPanel('parameters', wcDocker.DOCK.BOTTOM, self.code_editor_panel);
      self.local_variables_panel = self.docker.addPanel('local_variables', wcDocker.DOCK.STACKED, self.parameters_panel, {
        tabOrientation: wcDocker.TAB.TOP
      });
      self.messages_panel = self.docker.addPanel('messages', wcDocker.DOCK.STACKED, self.parameters_panel);
      self.results_panel = self.docker.addPanel('results', wcDocker.DOCK.STACKED, self.parameters_panel);
      self.stack_pane_panel = self.docker.addPanel('stack_pane', wcDocker.DOCK.STACKED, self.parameters_panel);

      var editor_pane = $('<div id="stack_editor_pane" class="full-container-pane info"></div>');
      var code_editor_area = $('<textarea id="debugger-editor-textarea"></textarea>').append(editor_pane);
      self.code_editor_panel.layout().addItem(code_editor_area);

      // To show the line-number and set breakpoint marker details by user.
      var editor = self.editor = CodeMirror.fromTextArea(code_editor_area.get(0), {
        lineNumbers: true,
        foldOptions: {
          widget: '\u2026'
        },
        foldGutter: {
          rangeFinder: CodeMirror.fold.combine(CodeMirror.pgadminBeginRangeFinder, CodeMirror.pgadminIfRangeFinder, CodeMirror.pgadminLoopRangeFinder, CodeMirror.pgadminCaseRangeFinder)
        },
        gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter", "breakpoints"],
        mode: "text/x-pgsql",
        readOnly: true,
        extraKeys: pgAdmin.Browser.editor_shortcut_keys,
        tabSize: pgAdmin.Browser.editor_options.tabSize,
        lineWrapping: pgAdmin.Browser.editor_options.wrapCode,
        autoCloseBrackets: pgAdmin.Browser.editor_options.insert_pair_brackets,
        matchBrackets: pgAdmin.Browser.editor_options.brace_matching
      });

      // On loading the docker, register the callbacks
      var onLoad = function onLoad() {
        self.docker.finishLoading(100);
        self.docker.off(wcDocker.EVENT.LOADED);
        // Register the callback when user set/clear the breakpoint on gutter area.
        self.editor.on("gutterClick", self.onBreakPoint.bind(self), self);
      };

      self.docker.startLoading(gettext('Loading...'));
      self.docker.on(wcDocker.EVENT.LOADED, onLoad);

      // Create the toolbar view for debugging the function
      this.toolbarView = new DebuggerToolbarView();
    },

    // Register the panel with new debugger docker instance.
    registerPanel: function registerPanel(name, title, width, height, onInit) {
      var self = this;

      this.docker.registerPanelType(name, {
        title: title,
        isPrivate: true,
        onCreate: function onCreate(panel) {
          self.panels[name] = panel;
          panel.initSize(width, height);
          if (!title) panel.title(false);else panel.title(title);
          panel.closeable(false);
          panel.layout().addItem($('<div>', { 'class': 'pg-debugger-panel' }));
          if (onInit) {
            onInit.apply(self, [panel]);
          }
        }
      });
    }
  });

  pgTools.DirectDebug = new DirectDebug();
  pgTools.DirectDebug['jquery'] = $;

  return pgTools.DirectDebug;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

//////////////////////////////////////////////////////////////////////////
//
// pgAdmin 4 - PostgreSQL Tools
//
// Copyright (C) 2013 - 2017, The pgAdmin Development Team
// This software is released under the PostgreSQL Licence
//
//////////////////////////////////////////////////////////////////////////
// This file contains common utilities functions used in sqleditor modules

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
  var sqlEditorUtils = {
    /* Reference link http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
     * Modified as per requirement.
     */
    epicRandomString: function epicRandomString(length) {
      var s = [];
      var hexDigits = "0123456789abcdef";
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      // bits 12-15 of the time_hi_and_version field to 0010
      s[14] = "4";
      // bits 6-7 of the clock_seq_hi_and_reserved to 01
      s[19] = hexDigits.substr(s[19] & 0x3 | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = "-";

      var uuid = s.join("");
      return uuid.replace(/-/g, '').substr(0, length);
    },

    // Returns a unique hash for input string
    getHash: function getHash(input) {
      var hash = 0,
          len = input.length;
      for (var i = 0; i < len; i++) {
        hash = (hash << 5) - hash + input.charCodeAt(i);
        hash |= 0; // to 32bit integer
      }
      return hash;
    },
    calculateColumnWidth: function calculateColumnWidth(text) {
      // Calculate column header width based on column name or type
      // Create a temporary element with given label, append to body
      // calculate its width and remove the element.
      $('body').append('<span id="pg_text" style="visibility: hidden;">' + text + '</span>');
      var width = $('#pg_text').width() + 23;
      $('#pg_text').remove(); // remove element

      return width;
    },
    capitalizeFirstLetter: function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
  };
  return sqlEditorUtils;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backbone) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(272), __webpack_require__(194), __webpack_require__(17), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, supported_servers, current_user, alertify) {

  if (!pgBrowser.Nodes['server']) {
    var connect_to_server = function connect_to_server(obj, data, tree, item, reconnect) {
      var wasConnected = reconnect || data.connected,
          onFailure = function onFailure(xhr, status, error, _node, _data, _tree, _item, _wasConnected) {
        data.connected = false;

        // It should be attempt to reconnect.
        // Let's not change the status of the tree node now.
        if (!_wasConnected) {
          tree.setInode(_item);
          tree.addIcon(_item, { icon: 'icon-server-not-connected' });
        }

        alertify.pgNotifier('error', xhr, error, function (msg) {
          setTimeout(function () {
            alertify.dlgServerPass(gettext('Connect to Server'), msg, _node, _data, _tree, _item, _wasConnected).resizeTo();
          }, 100);
        });
      },
          onSuccess = function onSuccess(res, node, data, tree, item, _wasConnected) {
        if (res && res.data) {
          if (typeof res.data.icon == 'string') {
            tree.removeIcon(item);
            data.icon = res.data.icon;
            tree.addIcon(item, { icon: data.icon });
          }

          _.extend(data, res.data);
          data.is_connecting = false;

          var serverInfo = pgBrowser.serverInfo = pgBrowser.serverInfo || {};
          serverInfo[data._id] = _.extend({}, data);

          alertify.success(res.info);
          obj.trigger('connected', obj, item, data);

          // Generate the event that server is connected
          pgBrowser.Events.trigger('pgadmin:server:connected', data._id, item, data);
          // Generate the event that database is connected
          pgBrowser.Events.trigger('pgadmin:database:connected', data._id, data.db, item, data);

          // We're not reconnecting
          if (!_wasConnected) {
            tree.setInode(item);
            tree.deselect(item);

            setTimeout(function () {
              tree.select(item);
              tree.open(item);
            }, 10);
          } else {
            // We just need to refresh the tree now.
            setTimeout(function () {
              node.callbacks.refresh.apply(node, [true]);
            }, 10);
          }
        }
      };

      // Ask Password and send it back to the connect server
      if (!alertify.dlgServerPass) {
        alertify.dialog('dlgServerPass', function factory() {
          return {
            main: function main(title, message, node, data, tree, item, _status, _onSuccess, _onFailure, _onCancel) {
              this.set('title', title);
              this.message = message;
              this.tree = tree;
              this.nodeData = data;
              this.nodeItem = item;
              this.node = node;
              this.connected = _status;
              this.onSuccess = _onSuccess || onSuccess;
              this.onFailure = _onFailure || onFailure;
              this.onCancel = _onCancel || onCancel;
            },
            setup: function setup() {
              return {
                buttons: [{
                  text: gettext("OK"), key: 13, className: "btn btn-primary"
                }, {
                  text: gettext("Cancel"), className: "btn btn-danger"
                }],
                focus: { element: '#password', select: true },
                options: {
                  modal: 0, resizable: false, maximizable: false, pinnable: false
                }
              };
            },
            build: function build() {},
            prepare: function prepare() {
              this.setContent(this.message);
            },
            callback: function callback(closeEvent) {
              var _tree = this.tree,
                  _item = this.nodeItem,
                  _node = this.node,
                  _data = this.nodeData,
                  _status = this.connected,
                  _onSuccess = this.onSuccess,
                  _onFailure = this.onFailure,
                  _onCancel = this.onCancel;

              if (closeEvent.button.text == gettext("OK")) {

                var _url = _node.generate_url(_item, 'connect', _data, true);

                if (!_status) {
                  _tree.setLeaf(_item);
                  _tree.removeIcon(_item);
                  _tree.addIcon(_item, { icon: 'icon-server-connecting' });
                }

                $.ajax({
                  type: 'POST',
                  timeout: 30000,
                  url: _url,
                  data: $('#frmPassword').serialize(),
                  success: function success(res) {
                    return _onSuccess(res, _node, _data, _tree, _item, _status);
                  },
                  error: function error(xhr, status, _error7) {
                    return _onFailure(xhr, status, _error7, _node, _data, _tree, _item, _status);
                  }
                });
              } else {
                this.onCancel && typeof this.onCancel == 'function' && this.onCancel(_tree, _item, _data, _status);
              }
            }
          };
        });
      }

      var onCancel = function onCancel(_tree, _item, _data, _status) {
        _data.is_connecting = false;
        _tree.unload(_item);
        _tree.setInode(_item);
        _tree.removeIcon(_item);
        _tree.addIcon(_item, { icon: 'icon-server-not-connected' });
        obj.trigger('connect:cancelled', data._id, data.db, obj, _item, _data);
        pgBrowser.Events.trigger('pgadmin:server:connect:cancelled', data._id, _item, _data, obj);
        pgBrowser.Events.trigger('pgadmin:database:connect:cancelled', data._id, data.db, _item, _data, obj);
        if (_status) {
          _tree.select(_item);
        }
      };

      data.is_connecting = true;
      var url = obj.generate_url(item, "connect", data, true);
      $.post(url).done(function (res) {
        if (res.success == 1) {
          return onSuccess(res, obj, data, tree, item, wasConnected);
        }
      }).fail(function (xhr, status, error) {
        return onFailure(xhr, status, error, obj, data, tree, item, wasConnected);
      });
    };

    /* Send PING to indicate that session is alive */


    var server_status = function server_status(server_id) {
      url = "/ping";
      $.post(url).done(function (data) {
        return true;
      }).fail(function (xhr, status, error) {
        return false;
      });
    };

    var SecurityModel = pgBrowser.SecLabelModel = pgBrowser.Node.Model.extend({
      defaults: {
        provider: undefined,
        label: undefined
      },
      schema: [{
        id: 'provider', label: gettext('Provider'),
        type: 'text', editable: true,
        cellHeaderClasses: 'width_percent_50'
      }, {
        id: 'label', label: gettext('Security Label'),
        type: 'text', editable: true,
        cellHeaderClasses: 'override_label_class_font_size'
      }],
      validate: function validate() {
        var err = {},
            errmsg = null;
        this.errorModel.clear();

        if (_.isUndefined(this.get('label')) || _.isNull(this.get('label')) || String(this.get('label')).replace(/^\s+|\s+$/g, '') == '') {
          errmsg = gettext('Label must be specified.');
          this.errorModel.set('label', errmsg);
          return errmsg;
        }

        return null;
      }
    });

    pgAdmin.Browser.Nodes['server'] = pgAdmin.Browser.Node.extend({
      parent_type: 'server_group',
      type: 'server',
      dialogHelp: url_for('help.static', { 'filename': 'server_dialog.html' }),
      label: gettext('Server'),
      canDrop: true,
      hasStatistics: true,
      hasCollectiveStatistics: true,
      can_expand: function can_expand(d) {
        return d && d.connected;
      },
      Init: function Init() {

        /* Avoid multiple registration of same menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_server_on_sg', node: 'server_group', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 1, label: gettext('Server...'),
          data: { action: 'create' }, icon: 'wcTabIcon icon-server'
        }, {
          name: 'create_server', node: 'server', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 3, label: gettext('Server...'),
          data: { action: 'create' }, icon: 'wcTabIcon icon-server'
        }, {
          name: 'connect_server', node: 'server', module: this,
          applies: ['object', 'context'], callback: 'connect_server',
          category: 'connect', priority: 4, label: gettext('Connect Server'),
          icon: 'fa fa-link', enable: 'is_not_connected'
        }, {
          name: 'disconnect_server', node: 'server', module: this,
          applies: ['object', 'context'], callback: 'disconnect_server',
          category: 'drop', priority: 5, label: gettext('Disconnect Server'),
          icon: 'fa fa-chain-broken', enable: 'is_connected'
        }, {
          name: 'reload_configuration', node: 'server', module: this,
          applies: ['tools', 'context'], callback: 'reload_configuration',
          category: 'reload', priority: 6, label: gettext('Reload Configuration'),
          icon: 'fa fa-repeat', enable: 'enable_reload_config'
        }, {
          name: 'restore_point', node: 'server', module: this,
          applies: ['tools', 'context'], callback: 'restore_point',
          category: 'restore', priority: 9, label: gettext('Add Named Restore Point...'),
          icon: 'fa fa-anchor', enable: 'is_applicable'
        }, {
          name: 'change_password', node: 'server', module: this,
          applies: ['file'], callback: 'change_password',
          label: gettext('Change Password...'),
          icon: 'fa fa-lock', enable: 'is_connected'
        }, {
          name: 'wal_replay_pause', node: 'server', module: this,
          applies: ['tools', 'context'], callback: 'pause_wal_replay',
          category: 'wal_replay_pause', priority: 7, label: gettext('Pause Replay of WAL'),
          icon: 'fa fa-pause-circle', enable: 'wal_pause_enabled'
        }, {
          name: 'wal_replay_resume', node: 'server', module: this,
          applies: ['tools', 'context'], callback: 'resume_wal_replay',
          category: 'wal_replay_resume', priority: 8, label: gettext('Resume Replay of WAL'),
          icon: 'fa fa-play-circle', enable: 'wal_resume_enabled'
        }]);

        _.bindAll(this, 'connection_lost');
        pgBrowser.Events.on('pgadmin:server:connection:lost', this.connection_lost);
      },
      is_not_connected: function is_not_connected(node) {
        return node && node.connected != true;
      },
      is_connected: function is_connected(node) {
        return node && node.connected == true;
      },
      enable_reload_config: function enable_reload_config(node) {
        // Must be connected & is Super user
        if (node && node._type == "server" && node.connected && node.user.is_superuser) {
          return true;
        }
        return false;
      },
      is_applicable: function is_applicable(node) {
        // Must be connected & super user & not in recovery mode
        if (node && node._type == "server" && node.connected && node.user.is_superuser && node.in_recovery == false) {
          return true;
        }
        return false;
      },
      wal_pause_enabled: function wal_pause_enabled(node) {
        // Must be connected & is Super user & in Recovery mode
        if (node && node._type == "server" && node.connected && node.user.is_superuser && node.in_recovery == true && node.wal_pause == false) {
          return true;
        }
        return false;
      },
      wal_resume_enabled: function wal_resume_enabled(node) {
        // Must be connected & is Super user & in Recovery mode
        if (node && node._type == "server" && node.connected && node.user.is_superuser && node.in_recovery == true && node.wal_pause == true) {
          return true;
        }
        return false;
      },
      callbacks: {
        /* Connect the server */
        connect_server: function connect_server(args) {
          var input = args || {},
              obj = this,
              t = pgBrowser.tree,
              i = input.item || t.selected(),
              d = i && i.length == 1 ? t.itemData(i) : undefined;

          if (!d) return false;

          connect_to_server(obj, d, t, i, false);
          return false;
        },
        /* Disconnect the server */
        disconnect_server: function disconnect_server(args, notify) {
          var input = args || {},
              obj = this,
              t = pgBrowser.tree,
              i = 'item' in input ? input.item : t.selected(),
              d = i && i.length == 1 ? t.itemData(i) : undefined;

          if (!d) return false;

          notify = notify || _.isUndefined(notify) || _.isNull(notify);

          var disconnect = function disconnect() {
            $.ajax({
              url: obj.generate_url(i, 'connect', d, true),
              type: 'DELETE',
              success: function success(res) {
                if (res.success == 1) {
                  alertify.success(res.info);
                  d = t.itemData(i);
                  t.removeIcon(i);
                  d.connected = false;
                  d.icon = 'icon-server-not-connected';
                  t.addIcon(i, { icon: d.icon });
                  obj.callbacks.refresh.apply(obj, [null, i]);
                  if (pgBrowser.serverInfo && d._id in pgBrowser.serverInfo) {
                    delete pgBrowser.serverInfo[d._id];
                  }
                  pgBrowser.enable_disable_menus(i);
                  // Trigger server disconnect event
                  pgBrowser.Events.trigger('pgadmin:server:disconnect', { item: i, data: d }, false);
                } else {
                  try {
                    alertify.error(res.errormsg);
                  } catch (e) {}
                  t.unload(i);
                }
              },
              error: function error(xhr, status, _error) {
                try {
                  var err = $.parseJSON(xhr.responseText);
                  if (err.success == 0) {
                    alertify.error(err.errormsg);
                  }
                } catch (e) {}
                t.unload(i);
              }
            });
          };

          if (notify) {
            alertify.confirm(gettext('Disconnect server'), gettext('Are you sure you want to disconnect the server %(server)s?', { server: d.label }), function (evt) {
              disconnect();
            }, function (evt) {
              return true;
            });
          } else {
            disconnect();
          }

          return false;
        },
        /* Connect the server (if not connected), before opening this node */
        beforeopen: function beforeopen(item, data) {

          if (!data || data._type != 'server') {
            return false;
          }

          pgBrowser.tree.addIcon(item, { icon: data.icon });
          if (!data.connected) {
            connect_to_server(this, data, pgBrowser.tree, item, false);

            return false;
          }
          return true;
        },
        added: function added(item, data) {

          pgBrowser.serverInfo = pgBrowser.serverInfo || {};
          pgBrowser.serverInfo[data._id] = _.extend({}, data);

          // Call added method of node.js
          pgAdmin.Browser.Node.callbacks.added.apply(this, arguments);
          return true;
        },
        /* Reload configuration */
        reload_configuration: function reload_configuration(args) {
          var input = args || {},
              obj = this,
              t = pgBrowser.tree,
              i = input.item || t.selected(),
              d = i && i.length == 1 ? t.itemData(i) : undefined;

          if (!d) return false;

          alertify.confirm(gettext('Reload server configuration'), S(gettext('Are you sure you want to reload the server configuration on %s?')).sprintf(d.label).value(), function (evt) {
            $.ajax({
              url: obj.generate_url(i, 'reload', d, true),
              method: 'GET',
              success: function success(res) {
                if (res.data.status) {
                  alertify.success(res.data.result);
                } else {
                  alertify.error(res.data.result);
                }
              },
              error: function error(xhr, status, _error2) {
                try {
                  var err = $.parseJSON(xhr.responseText);
                  if (err.success == 0) {
                    alertify.error(err.errormsg);
                  }
                } catch (e) {}
                t.unload(i);
              }
            });
          }, function (evt) {
            return true;
          });

          return false;
        },
        /* Add restore point */
        restore_point: function restore_point(args) {
          var input = args || {},
              obj = this,
              t = pgBrowser.tree,
              i = input.item || t.selected(),
              d = i && i.length == 1 ? t.itemData(i) : undefined;

          if (!d) return false;

          alertify.prompt(gettext('Enter the name of the restore point to add'), '',
          // We will execute this function when user clicks on the OK button
          function (evt, value) {
            // If user has provided a value, send it to the server
            if (!_.isUndefined(value) && !_.isNull(value) && value !== '' && String(value).replace(/^\s+|\s+$/g, '') !== '') {
              $.ajax({
                url: obj.generate_url(i, 'restore_point', d, true),
                method: 'POST',
                data: { 'value': JSON.stringify(value) },
                success: function success(res) {
                  alertify.success(res.data.result, 10);
                },
                error: function error(xhr, status, _error3) {
                  try {
                    var err = $.parseJSON(xhr.responseText);
                    if (err.success == 0) {
                      alertify.error(err.errormsg, 10);
                    }
                  } catch (e) {}
                  t.unload(i);
                }
              });
            } else {
              evt.cancel = true;
              alertify.error(gettext('Please enter a valid name.'), 10);
            }
          },
          // We will execute this function when user clicks on the Cancel button
          // Do nothing just close it
          function (evt, value) {
            evt.cancel = false;
          }).set({ 'title': 'Restore point name' });
        },

        /* Change password */
        change_password: function change_password(args) {
          var input = args || {},
              obj = this,
              t = pgBrowser.tree,
              i = input.item || t.selected(),
              d = i && i.length == 1 ? t.itemData(i) : undefined,
              node = d && pgBrowser.Nodes[d._type],
              url = obj.generate_url(i, 'change_password', d, true);

          if (!d) return false;

          if (!alertify.changeServerPassword) {
            var newPasswordModel = Backbone.Model.extend({
              defaults: {
                user_name: undefined,
                password: undefined,
                newPassword: undefined,
                confirmPassword: undefined
              },
              validate: function validate() {
                return null;
              }
            }),
                passwordChangeFields = [{
              name: 'user_name', label: gettext('User'),
              type: 'text', disabled: true, control: 'input'
            }, {
              name: 'password', label: gettext('Current Password'),
              type: 'password', disabled: false, control: 'input',
              required: true
            }, {
              name: 'newPassword', label: gettext('New Password'),
              type: 'password', disabled: false, control: 'input',
              required: true
            }, {
              name: 'confirmPassword', label: gettext('Confirm Password'),
              type: 'password', disabled: false, control: 'input',
              required: true
            }];

            alertify.dialog('changeServerPassword', function factory() {
              return {
                main: function main(params) {
                  var title = gettext('Change Password ');
                  this.set('title', title);
                  this.user_name = params.user.name;
                },
                setup: function setup() {
                  return {
                    buttons: [{
                      text: gettext('Ok'), key: 13, className: 'btn btn-primary', attrs: { name: 'submit' }
                    }, {
                      text: gettext('Cancel'), key: 27, className: 'btn btn-danger', attrs: { name: 'cancel' }
                    }],
                    // Set options for dialog
                    options: {
                      padding: !1,
                      overflow: !1,
                      modal: false,
                      resizable: true,
                      maximizable: true,
                      pinnable: false,
                      closableByDimmer: false
                    }
                  };
                },
                hooks: {
                  // triggered when the dialog is closed
                  onclose: function onclose() {
                    if (this.view) {
                      this.view.remove({ data: true, internal: true, silent: true });
                    }
                  }
                },
                prepare: function prepare() {
                  var self = this;
                  // Disable Backup button until user provides Filename
                  this.__internal.buttons[0].element.disabled = true;
                  var $container = $("<div class='change_password'></div>"),
                      newpasswordmodel = new newPasswordModel({ 'user_name': self.user_name });

                  var view = this.view = new Backform.Form({
                    el: $container,
                    model: newpasswordmodel,
                    fields: passwordChangeFields });

                  view.render();

                  this.elements.content.appendChild($container.get(0));

                  // Listen to model & if filename is provided then enable Backup button
                  this.view.model.on('change', function () {
                    var that = this,
                        password = this.get('password'),
                        newPassword = this.get('newPassword'),
                        confirmPassword = this.get('confirmPassword');

                    if (_.isUndefined(password) || _.isNull(password) || password == '' || _.isUndefined(newPassword) || _.isNull(newPassword) || newPassword == '' || _.isUndefined(confirmPassword) || _.isNull(confirmPassword) || confirmPassword == '') {
                      self.__internal.buttons[0].element.disabled = true;
                    } else if (newPassword != confirmPassword) {
                      self.__internal.buttons[0].element.disabled = true;

                      this.errorTimeout && clearTimeout(this.errorTimeout);
                      this.errorTimeout = setTimeout(function () {
                        that.errorModel.set('confirmPassword', gettext('Passwords do not match.'));
                      }, 400);
                    } else {
                      that.errorModel.clear();
                      self.__internal.buttons[0].element.disabled = false;
                    }
                  });
                },
                // Callback functions when click on the buttons of the Alertify dialogs
                callback: function callback(e) {
                  if (e.button.element.name == "submit") {
                    var self = this,
                        args = this.view.model.toJSON();

                    e.cancel = true;

                    $.ajax({
                      url: url,
                      method: 'POST',
                      data: { 'data': JSON.stringify(args) },
                      success: function success(res) {
                        if (res.success) {
                          alertify.success(res.info);
                          self.close();
                        } else {
                          alertify.error(res.errormsg);
                        }
                      },
                      error: function error(xhr, status, _error4) {
                        try {
                          var err = $.parseJSON(xhr.responseText);
                          if (err.success == 0) {
                            alertify.error(err.errormsg);
                          }
                        } catch (e) {}
                      }
                    });
                  }
                }
              };
            });
          }

          alertify.changeServerPassword(d).resizeTo('40%', '52%');
          return false;
        },

        /* Pause WAL Replay */
        pause_wal_replay: function pause_wal_replay(args) {
          var input = args || {},
              obj = this,
              t = pgBrowser.tree,
              i = input.item || t.selected(),
              d = i && i.length == 1 ? t.itemData(i) : undefined;

          if (!d) return false;

          var data = d;
          $.ajax({
            url: obj.generate_url(i, 'wal_replay', d, true),
            type: 'DELETE',
            dataType: "json",
            success: function success(res) {
              if (res.success == 1) {
                alertify.success(res.info);
                t.itemData(i).wal_pause = res.data.wal_pause;
                t.unload(i);
                t.setInode(i);
                t.deselect(i);
                // Fetch updated data from server
                setTimeout(function () {
                  t.select(i);
                }, 10);
              }
            },
            error: function error(xhr, status, _error5) {
              try {
                var err = $.parseJSON(xhr.responseText);
                if (err.success == 0) {
                  msg = S(err.errormsg).value();
                  alertify.error(err.errormsg);
                }
              } catch (e) {}
              t.unload(i);
            }
          });
        },

        /* Resume WAL Replay */
        resume_wal_replay: function resume_wal_replay(args) {
          var input = args || {},
              obj = this,
              t = pgBrowser.tree,
              i = input.item || t.selected(),
              d = i && i.length == 1 ? t.itemData(i) : undefined;

          if (!d) return false;

          var data = d;
          $.ajax({
            url: obj.generate_url(i, 'wal_replay', d, true),
            type: 'PUT',
            dataType: "json",
            success: function success(res) {
              if (res.success == 1) {
                alertify.success(res.info);
                t.itemData(i).wal_pause = res.data.wal_pause;
                t.unload(i);
                t.setInode(i);
                t.deselect(i);
                // Fetch updated data from server
                setTimeout(function () {
                  t.select(i);
                }, 10);
              }
            },
            error: function error(xhr, status, _error6) {
              try {
                var err = $.parseJSON(xhr.responseText);
                if (err.success == 0) {
                  msg = S(err.errormsg).value();
                  alertify.error(err.errormsg);
                }
              } catch (e) {}
              t.unload(i);
            }
          });
        }
      },
      model: pgAdmin.Browser.Node.Model.extend({
        defaults: {
          gid: undefined,
          id: undefined,
          name: '',
          sslmode: 'prefer',
          host: '',
          hostaddr: '',
          port: 5432,
          db: 'postgres',
          username: current_user.name,
          role: null,
          connect_now: true,
          password: undefined,
          save_password: false,
          db_res: ''
        },
        // Default values!
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;

          if (isNew) {
            this.set({ 'gid': args.node_info['server_group']._id });
          }
          pgAdmin.Browser.Node.Model.prototype.initialize.apply(this, arguments);
        },
        schema: [{
          id: 'id', label: gettext('ID'), type: 'int', mode: ['properties']
        }, {
          id: 'name', label: gettext('Name'), type: 'text',
          mode: ['properties', 'edit', 'create']
        }, {
          id: 'gid', label: gettext('Server group'), type: 'int',
          control: 'node-list-by-id', node: 'server_group',
          mode: ['create', 'edit'], select2: { allowClear: false }
        }, {
          id: 'server_type', label: gettext('Server type'), type: 'options',
          mode: ['properties'], visible: 'isConnected',
          'options': supported_servers
        }, {
          id: 'connected', label: gettext('Connected?'), type: 'switch',
          mode: ['properties'], group: gettext('Connection'), 'options': {
            'onText': 'True', 'offText': 'False', 'onColor': 'success',
            'offColor': 'danger', 'size': 'small'
          }
        }, {
          id: 'version', label: gettext('Version'), type: 'text', group: null,
          mode: ['properties'], visible: 'isConnected'
        }, {
          id: 'connect_now', controlLabel: gettext('Connect now?'), type: 'checkbox',
          group: null, mode: ['create']
        }, {
          id: 'comment', label: gettext('Comments'), type: 'multiline', group: null,
          mode: ['properties', 'edit', 'create']
        }, {
          id: 'host', label: gettext('Host name/address'), type: 'text', group: gettext('Connection'),
          mode: ['properties', 'edit', 'create'], disabled: 'isConnected'
        }, {
          id: 'hostaddr', label: gettext('Host address'), type: 'text', group: gettext('Advanced'),
          mode: ['properties', 'edit', 'create'], disabled: 'isConnected'
        }, {
          id: 'db_res', label: gettext('DB restriction'), type: 'select2', group: gettext('Advanced'),
          mode: ['properties', 'edit', 'create'], disabled: 'isConnected', select2: { multiple: true, allowClear: false,
            tags: true, tokenSeparators: [','], first_empty: false, selectOnClose: true, emptyOptions: true }
        }, {
          id: 'port', label: gettext('Port'), type: 'int', group: gettext('Connection'),
          mode: ['properties', 'edit', 'create'], disabled: 'isConnected', min: 1024, max: 65535
        }, {
          id: 'db', label: gettext('Maintenance database'), type: 'text', group: gettext('Connection'),
          mode: ['properties', 'edit', 'create'], disabled: 'isConnected'
        }, {
          id: 'username', label: gettext('Username'), type: 'text', group: gettext('Connection'),
          mode: ['properties', 'edit', 'create'], disabled: 'isConnected'
        }, {
          id: 'password', label: gettext('Password'), type: 'password',
          group: gettext('Connection'), control: 'input', mode: ['create'], deps: ['connect_now'],
          visible: function visible(m) {
            return m.get('connect_now') && m.isNew();
          }
        }, {
          id: 'save_password', controlLabel: gettext('Save password?'), type: 'checkbox',
          group: gettext('Connection'), mode: ['create'], deps: ['connect_now'],
          visible: function visible(m) {
            return m.get('connect_now') && m.isNew();
          },
          disabled: function disabled(m) {
            return !current_user.allow_save_password;
          }
        }, {
          id: 'role', label: gettext('Role'), type: 'text', group: gettext('Connection'),
          mode: ['properties', 'edit', 'create'], disabled: 'isConnected'
        }, {
          id: 'sslmode', label: gettext('SSL mode'), type: 'options', group: gettext('Connection'),
          mode: ['properties', 'edit', 'create'], disabled: 'isConnected',
          'options': [{ label: 'Allow', value: 'allow' }, { label: 'Prefer', value: 'prefer' }, { label: 'Require', value: 'require' }, { label: 'Disable', value: 'disable' }, { label: 'Verify-CA', value: 'verify-ca' }, { label: 'Verify-Full', value: 'verify-full' }]
        }],
        validate: function validate() {
          var err = {},
              errmsg,
              self = this;

          var check_for_empty = function check_for_empty(id, msg) {
            var v = self.get(id);
            if (_.isUndefined(v) || v === null || String(v).replace(/^\s+|\s+$/g, '') == '') {
              err[id] = msg;
              errmsg = errmsg || msg;
              return true;
            } else {
              self.errorModel.unset(id);
              return false;
            }
          };
          var check_for_valid_ipv6 = function check_for_valid_ipv6(val) {
            // Regular expression for validating IPv6 address formats
            var exps = ['^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|', '(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|', '2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|', '(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|', ':((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|', '(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|', '2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|', '(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|', '[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|', '((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|', '(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|', '1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|', '((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$'];

            var exp = new RegExp(exps.join(''));
            return exp.test(val.trim());
          };
          var check_for_valid_ip = function check_for_valid_ip(id, msg) {
            var v4exps = "(^\\s*((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))\\s*$)";
            var v4exp = new RegExp(v4exps);
            var v = self.get(id);
            if (v && !v4exp.test(v.trim())) {
              if (!check_for_valid_ipv6(v)) {
                err[id] = msg;
                errmsg = msg;
              }
            } else {
              self.errorModel.unset(id);
            }
          };

          if (!self.isNew() && 'id' in self.sessAttrs) {
            err['id'] = gettext('The ID cannot be changed.');
            errmsg = err['id'];
          } else {
            self.errorModel.unset('id');
          }
          check_for_empty('name', gettext('Name must be specified.'));

          if (check_for_empty('host', gettext('Either Host name or Host address must be specified.')) && check_for_empty('hostaddr', gettext('Either Host name or Host address must be specified.'))) {
            errmsg = errmsg || gettext('Either Host name or Host address must be specified');
          } else {
            errmsg = undefined;
            delete err['host'];
            delete err['hostaddr'];
          }

          check_for_empty('db', gettext('Maintenance database must be specified.'));
          check_for_empty('username', gettext('Username must be specified.'));
          check_for_empty('port', gettext('Port must be specified.'));
          check_for_valid_ip('hostaddr', gettext('Host address must be valid IPv4 or IPv6 address.'));
          this.errorModel.set(err);

          if (_.size(err)) {
            return errmsg;
          }

          return null;
        },
        isConnected: function isConnected(model) {
          return model.get('connected');
        }
      }),
      connection_lost: function connection_lost(i, resp) {
        if (pgBrowser.tree) {
          var t = pgBrowser.tree,
              info = i && this.getTreeNodeHierarchy(i),
              s = null,
              d = i && t.itemData(i),
              self = this;

          while (d && d._type != 'server') {
            i = t.parent(i);
            d = i && t.itemData(i);
          }

          if (i && d && d._type == 'server') {
            if (_.isUndefined(d.is_connecting) || !d.is_connecting) {
              d.is_connecting = true;

              var disconnect = function disconnect(_sid) {
                if (d._id == _sid) {
                  d.is_connecting = false;
                  // Stop listening to the connection cancellation event
                  pgBrowser.Events.off('pgadmin:server:connect:cancelled', disconnect);

                  // Connection to the database will also be cancelled
                  pgBrowser.Events.trigger('pgadmin:database:connect:cancelled', _sid, resp.data.database || d.db);

                  // Make sure - the server is disconnected properly
                  pgBrowser.Events.trigger('pgadmin:server:disconnect', { item: _i, data: _d }, false);
                }
              };

              // Listen for the server connection cancellation event
              pgBrowser.Events.on('pgadmin:server:connect:cancelled', disconnect);
              alertify.confirm(gettext('Connection lost'), gettext('Would you like to reconnect to the database?'), function () {
                connect_to_server(self, d, t, i, true);
              }, function () {
                d.is_connecting = false;
                t.unload(i);
                t.setInode(i);
                t.addIcon(i, { icon: 'icon-database-not-connected' });
                pgBrowser.Events.trigger('pgadmin:server:connect:cancelled', i, d, self);
                t.select(i);
              });
            }
          }
        }
      }
    });
  }

  return pgBrowser.Nodes['server'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 194 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_194__;

/***/ }),
/* 195 */,
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backbone) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/* Create and Register Function Collection and Node. */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  if (!pgBrowser.Nodes['coll-function']) {
    var functions = pgBrowser.Nodes['coll-function'] = pgBrowser.Collection.extend({
      node: 'function',
      label: gettext('Functions'),
      type: 'coll-function',
      columns: ['name', 'funcowner', 'description'],
      hasStatistics: true
    });
  };

  // Argument Model
  var ArgumentModel = pgBrowser.Node.Model.extend({
    idAttribute: 'argid',
    defaults: {
      argid: undefined,
      argtype: undefined,
      argmode: undefined,
      argname: undefined,
      argdefval: undefined
    },
    schema: [{
      id: 'argid', visible: false, type: 'text',
      mode: ['properties', 'edit', 'create']
    }, {
      id: 'argtype', label: gettext('Data Type'), cell: 'node-ajax-options', cellHeaderClasses: 'width_percent_30',
      control: 'node-ajax-options', type: 'text', url: 'get_types',
      editable: function editable(m) {
        var node_info = this.get('node_info');
        if (node_info && 'catalog' in node_info) {
          return false;
        }
        return _.isUndefined(m.isNew) ? true : m.isNew();
      }, first_empty: true
    }, {
      id: 'argmode', label: gettext('Mode'), type: 'options',
      control: 'node-ajax-options', cellHeaderClasses: 'width_percent_20',
      options: [{ 'label': 'IN', 'value': 'IN' }, { 'label': 'OUT', 'value': 'OUT' }, { 'label': 'INOUT', 'value': 'INOUT' }, { 'label': 'VARIADIC', 'value': 'VARIADIC' }], editable: function editable(m) {
        var node_info = this.get('node_info');
        if (node_info && 'catalog' in node_info) {
          return false;
        }
        return _.isUndefined(m.isNew) ? true : m.isNew();
      }
    }, {
      id: 'argname', label: gettext('Argument Name'), type: 'text',
      cell: 'string', editable: 'isInCatalog', cellHeaderClasses: 'width_percent_30'
    }, {
      id: 'argdefval', label: gettext('Default Value'), type: 'text',
      cell: 'string', editable: 'isInCatalog', cellHeaderClasses: 'width_percent_20'
    }],
    toJSON: Backbone.Model.prototype.toJSON,
    isInCatalog: function isInCatalog(m) {
      var node_info = this.get('node_info');
      if (node_info && 'catalog' in node_info) {
        return false;
      }
      // Below will disable default value cell if argument mode is 'INOUT' or 'OUT' as
      // user cannot set default value for out parameters.
      if (!_.isUndefined(m.get('argmode')) && !_.isUndefined(this.get('name')) && this.get('name') == 'argdefval' && (m.get('argmode') == 'INOUT' || m.get('argmode') == 'OUT')) {
        return false;
      }
      return true;
    },
    validate: function validate() {}
  });

  if (!pgBrowser.Nodes['function']) {
    pgBrowser.Nodes['function'] = pgBrowser.Node.extend({
      type: 'function',
      sqlAlterHelp: 'sql-alterfunction.html',
      sqlCreateHelp: 'sql-createfunction.html',
      dialogHelp: url_for('help.static', { 'filename': 'function_dialog.html' }),
      label: gettext('Function'),
      collection_type: 'coll-function',
      hasSQL: true,
      hasDepends: true,
      hasStatistics: true,
      hasScriptTypes: ['create', 'select'],
      parent_type: ['schema', 'catalog'],
      Init: function Init(args) {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_function_on_coll', node: 'coll-function', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Function...'),
          icon: 'wcTabIcon icon-function', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_function', node: 'function', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Function...'),
          icon: 'wcTabIcon icon-function', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_function', node: 'schema', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Function...'),
          icon: 'wcTabIcon icon-function', data: { action: 'create', check: false },
          enable: 'canCreate'
        }]);
      },
      canDrop: pgBrowser.Nodes['schema'].canChildDrop,
      canDropCascade: pgBrowser.Nodes['schema'].canChildDrop,
      model: pgBrowser.Node.Model.extend({
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;
          if (isNew) {
            // Set Selected Schema
            var schema_id = args.node_info.schema._id;
            this.set({ 'pronamespace': schema_id }, { silent: true });

            // Set Current User
            var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;
            this.set({ 'funcowner': userInfo.name }, { silent: true });
          }
          pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
        },
        defaults: {
          name: undefined,
          oid: undefined,
          xmin: undefined,
          funcowner: undefined,
          pronamespace: undefined,
          description: undefined,
          pronargs: undefined, /* Argument Count */
          proargs: undefined, /* Arguments */
          proargtypenames: undefined, /* Argument Signature */
          prorettypename: undefined, /* Return Type */
          lanname: 'sql', /* Language Name in which function is being written */
          provolatile: undefined, /* Volatility */
          proretset: undefined, /* Return Set */
          proisstrict: undefined,
          prosecdef: undefined, /* Security of definer */
          proiswindow: undefined, /* Window Function ? */
          proparallel: undefined, /* Parallel mode */
          procost: undefined, /* Estimated execution Cost */
          prorows: undefined, /* Estimated number of rows */
          proleakproof: undefined,
          arguments: [],
          prosrc: undefined,
          prosrc_c: undefined,
          probin: '$libdir/',
          options: [],
          variables: [],
          proacl: undefined,
          seclabels: [],
          acl: [],
          sysfunc: undefined,
          sysproc: undefined
        },
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'],
          disabled: 'isDisabled'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', mode: ['properties']
        }, {
          id: 'funcowner', label: gettext('Owner'), cell: 'string',
          control: Backform.NodeListByNameControl, node: 'role', type: 'text', disabled: 'isDisabled'
        }, {
          id: 'pronamespace', label: gettext('Schema'), cell: 'string',
          control: 'node-list-by-id', type: 'text', cache_level: 'database',
          node: 'schema', disabled: 'isDisabled', mode: ['create', 'edit']
        }, {
          id: 'sysfunc', label: gettext('System function?'),
          cell: 'boolean', type: 'switch',
          mode: ['properties'], visible: 'isVisible'
        }, {
          id: 'sysproc', label: gettext('System procedure?'),
          cell: 'boolean', type: 'switch',
          mode: ['properties'], visible: 'isVisible'
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline', disabled: 'isDisabled'
        }, {
          id: 'pronargs', label: gettext('Argument count'), cell: 'string',
          type: 'text', group: gettext('Definition'), mode: ['properties']
        }, {
          id: 'proargs', label: gettext('Arguments'), cell: 'string',
          type: 'text', group: gettext('Definition'), mode: ['properties', 'edit'],
          disabled: 'isDisabled'
        }, {
          id: 'proargtypenames', label: gettext('Signature arguments'), cell: 'string', type: 'text', group: gettext('Definition'), mode: ['properties'],
          disabled: 'isDisabled'
        }, {
          id: 'prorettypename', label: gettext('Return type'), cell: 'string',
          control: 'node-ajax-options', type: 'text', group: gettext('Definition'),
          url: 'get_types', disabled: 'isDisabled', first_empty: true,
          mode: ['create'], visible: 'isVisible'
        }, {
          id: 'prorettypename', label: gettext('Return type'), cell: 'string',
          type: 'text', group: gettext('Definition'),
          mode: ['properties', 'edit'], disabled: 'isDisabled', visible: 'isVisible'
        }, {
          id: 'lanname', label: gettext('Language'), cell: 'string',
          control: 'node-ajax-options', type: 'text', group: gettext('Definition'),
          url: 'get_languages', disabled: 'isDisabled'
        }, {
          id: 'prosrc', label: gettext('Code'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'],
          group: gettext('Definition'), deps: ['lanname'],
          control: Backform.SqlFieldControl,
          extraClasses: ['custom_height_css_class'],
          visible: function visible(m) {
            if (m.get('lanname') == 'c') {
              return false;
            }
            return true;
          }, disabled: 'isDisabled'
        }, {
          id: 'probin', label: gettext('Object file'), cell: 'string',
          type: 'text', group: gettext('Definition'), deps: ['lanname'], visible: function visible(m) {
            if (m.get('lanname') == 'c') {
              return true;
            }
            return false;
          }, disabled: 'isDisabled'
        }, {
          id: 'prosrc_c', label: gettext('Link symbol'), cell: 'string',
          type: 'text', group: gettext('Definition'), deps: ['lanname'], visible: function visible(m) {
            if (m.get('lanname') == 'c') {
              return true;
            }
            return false;
          }, disabled: 'isDisabled'
        }, {
          id: 'provolatile', label: gettext('Volatility'), cell: 'string',
          control: 'node-ajax-options', type: 'text', group: gettext('Options'),
          options: [{ 'label': 'VOLATILE', 'value': 'v' }, { 'label': 'STABLE', 'value': 's' }, { 'label': 'IMMUTABLE', 'value': 'i' }], disabled: 'isDisabled', select2: { allowClear: false }
        }, {
          id: 'proretset', label: gettext('Returns a set?'), type: 'switch',
          disabled: 'isDisabled', group: gettext('Options'),
          visible: 'isVisible'
        }, {
          id: 'proisstrict', label: gettext('Strict?'), type: 'switch',
          group: gettext('Options'), disabled: 'isDisabled',
          options: {
            'onText': 'Yes', 'offText': 'No',
            'onColor': 'success', 'offColor': 'primary',
            'size': 'small'
          }
        }, {
          id: 'prosecdef', label: gettext('Security of definer?'),
          group: gettext('Options'), type: 'switch',
          disabled: 'isDisabled'
        }, {
          id: 'proiswindow', label: gettext('Window?'),
          group: gettext('Options'), cell: 'boolean', type: 'switch',
          disabled: 'isDisabled', visible: 'isVisible'
        }, {
          id: 'proparallel', label: gettext('Parallel'), cell: 'string',
          control: 'node-ajax-options', type: 'text', group: gettext('Options'),
          options: [{ 'label': 'UNSAFE', 'value': 'u' }, { 'label': 'RESTRICTED', 'value': 'r' }, { 'label': 'SAFE', 'value': 's' }], disabled: 'isDisabled', min_version: 90600,
          select2: { allowClear: false }
        }, {
          id: 'procost', label: gettext('Estimated cost'), group: gettext('Options'),
          cell: 'string', type: 'text', disabled: 'isDisabled'
        }, {
          id: 'prorows', label: gettext('Estimated rows'), type: 'text',
          deps: ['proretset'], visible: 'isVisible', disabled: 'isDisabled',
          group: gettext('Options')
        }, {
          id: 'proleakproof', label: gettext('Leak proof?'),
          group: gettext('Options'), cell: 'boolean', type: 'switch', min_version: 90200,
          disabled: 'isDisabled'
        }, {
          id: 'proacl', label: gettext('Privileges'), type: 'text',
          mode: ['properties'], group: gettext('Security')
        }, {
          id: 'arguments', label: gettext('Arguments'), cell: 'string',
          group: gettext('Arguments'), type: 'collection', canAdd: function canAdd(m) {
            return m.isNew();
          },
          canDelete: true, model: ArgumentModel, mode: ['create', 'edit'],
          columns: ['argtype', 'argmode', 'argname', 'argdefval'],
          disabled: 'isDisabled', canDeleteRow: function canDeleteRow(m) {
            return m.isNew();
          }
        }, {
          id: 'variables', label: gettext('Parameters'), type: 'collection',
          group: gettext('Parameters'), control: 'variable-collection',
          model: pgBrowser.Node.VariableModel,
          mode: ['edit', 'create'], canAdd: 'canVarAdd', canEdit: false,
          canDelete: true, disabled: 'isDisabled'
        }, pgBrowser.SecurityGroupSchema, {
          id: 'acl', label: gettext('Privileges'), editable: false,
          model: pgBrowser.Node.PrivilegeRoleModel.extend({
            privileges: ['X']
          }), uniqueCol: ['grantee', 'grantor'], type: 'collection',
          group: 'security', mode: ['edit', 'create'], canAdd: true,
          canDelete: true, control: 'unique-col-collection',
          disabled: 'isDisabled'
        }, {
          id: 'seclabels', label: gettext('Security Labels'), canAdd: true,
          model: pgBrowser.SecLabelModel, type: 'collection',
          min_version: 90100, group: 'security', mode: ['edit', 'create'],
          canEdit: false, canDelete: true, uniqueCol: ['provider'],
          disabled: 'isDisabled', control: 'unique-col-collection',
          visible: function visible() {
            return this.node && this.node.type != "procedure";
          }
        }],
        validate: function validate() {
          var err = {},
              errmsg,
              seclabels = this.get('seclabels');

          if (_.isUndefined(this.get('name')) || String(this.get('name')).replace(/^\s+|\s+$/g, '') == '') {
            err['name'] = gettext('Name cannot be empty.');
            errmsg = errmsg || err['name'];
          }

          if (_.isUndefined(this.get('funcowner')) || String(this.get('funcowner')).replace(/^\s+|\s+$/g, '') == '') {
            err['funcowner'] = gettext('Owner cannot be empty.');
            errmsg = errmsg || err['funcowner'];
          }

          if (_.isUndefined(this.get('pronamespace')) || String(this.get('pronamespace')).replace(/^\s+|\s+$/g, '') == '') {
            err['pronamespace'] = gettext('Schema cannot be empty.');
            errmsg = errmsg || err['pronamespace'];
          }

          if (_.isUndefined(this.get('prorettypename')) || String(this.get('prorettypename')).replace(/^\s+|\s+$/g, '') == '') {
            err['prorettypename'] = gettext('Return type cannot be empty.');
            errmsg = errmsg || err['prorettypename'];
          }

          if (_.isUndefined(this.get('lanname')) || String(this.get('lanname')).replace(/^\s+|\s+$/g, '') == '') {
            err['lanname'] = gettext('Language cannot be empty.');
            errmsg = errmsg || err['lanname'];
          }

          if (String(this.get('lanname')) == 'c') {
            if (_.isUndefined(this.get('probin')) || String(this.get('probin')).replace(/^\s+|\s+$/g, '') == '') {
              err['probin'] = gettext('Object File cannot be empty.');
              errmsg = errmsg || err['probin'];
            }

            if (_.isUndefined(this.get('prosrc_c')) || String(this.get('prosrc_c')).replace(/^\s+|\s+$/g, '') == '') {
              err['prosrc_c'] = gettext('Link Symbol cannot be empty.');
              errmsg = errmsg || err['prosrc_c'];
            }
          } else {
            if (_.isUndefined(this.get('prosrc')) || String(this.get('prosrc')).replace(/^\s+|\s+$/g, '') == '') {
              err['prosrc'] = gettext('Code cannot be empty.');
              errmsg = errmsg || err['prosrc'];
            }
          }

          if (seclabels) {
            var secLabelsErr;
            for (var i = 0; i < seclabels.models.length && !secLabelsErr; i++) {
              secLabelsErr = seclabels.models[i].validate.apply(seclabels.models[i]);
              if (secLabelsErr) {
                err['seclabels'] = secLabelsErr;
                errmsg = errmsg || secLabelsErr;
              }
            }
          }

          this.errorModel.clear().set(err);

          if (_.size(err)) {
            this.trigger('on-status', { msg: errmsg });
            return errmsg;
          }

          return null;
        },
        isVisible: function isVisible(m) {
          if (this.name == 'sysproc') {
            return false;
          }
          return true;
        },
        isDisabled: function isDisabled(m) {
          if (this.node_info && 'catalog' in this.node_info) {
            return true;
          }
          name = this.name;
          switch (name) {
            case 'proargs':
            case 'proargtypenames':
            case 'prorettypename':
            case 'proretset':
            case 'proiswindow':
              return !m.isNew();
              break;
            case 'prorows':
              if (m.get('proretset') == true) {
                return false;
              } else {
                return true;
              }
              break;
            default:
              return false;
              break;
          }
          return false;
        },
        canVarAdd: function canVarAdd(m) {
          if (this.node_info && 'catalog' in this.node_info) {
            return false;
          }
          return true;
        }
      }),
      canCreate: function canCreate(itemData, item, data) {
        //If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        // To iterate over tree to check parent node
        while (i) {
          // If it is schema then allow user to create Function
          if (_.indexOf(['schema'], d._type) > -1) return true;

          if ('coll-function' == d._type) {
            //Check if we are not child of catalog
            var prev_i = t.hasParent(i) ? t.parent(i) : null,
                prev_d = prev_i ? t.itemData(prev_i) : null;
            if (prev_d._type == 'catalog') {
              return false;
            } else {
              return true;
            }
          }
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // by default we do not want to allow create menu
        return true;
      }
    });
  }

  return pgBrowser.Nodes['function'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/* Create and Register Function Collection and Node. */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  if (!pgBrowser.Nodes['coll-edbfunc']) {
    pgBrowser.Nodes['coll-edbfunc'] = pgBrowser.Collection.extend({
      node: 'edbfunc',
      label: gettext('Functions'),
      type: 'coll-edbfunc',
      columns: ['name', 'funcowner', 'description']
    });
  };

  if (!pgBrowser.Nodes['edbfunc']) {
    pgBrowser.Nodes['edbfunc'] = pgBrowser.Node.extend({
      type: 'edbfunc',
      dialogHelp: url_for('help.static', { 'filename': 'edbfunc_dialog.html' }),
      label: gettext('Function'),
      collection_type: 'coll-edbfunc',
      hasDepends: true,
      canEdit: false,
      hasSQL: true,
      hasScriptTypes: [],
      parent_type: ['package'],
      Init: function Init(args) {
        /* Avoid multiple registration of menus */
        if (this.initialized) return;

        this.initialized = true;
      },
      canDrop: false,
      canDropCascade: false,
      model: pgBrowser.Node.Model.extend({
        defaults: {
          name: undefined,
          oid: undefined,
          funcowner: undefined,
          pronargs: undefined, /* Argument Count */
          proargs: undefined, /* Arguments */
          proargtypenames: undefined, /* Argument Signature */
          prorettypename: undefined, /* Return Type */
          lanname: 'sql', /* Language Name in which function is being written */
          prosrc: undefined,
          proacl: undefined,
          visibility: 'Unknown'
        },
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', mode: ['properties'],
          disabled: true
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', mode: ['properties']
        }, {
          id: 'funcowner', label: gettext('Owner'), cell: 'string',
          type: 'text', disabled: true
        }, {
          id: 'pronargs', label: gettext('Argument count'), cell: 'string',
          type: 'text', group: gettext('Definition'), mode: ['properties']
        }, {
          id: 'proargs', label: gettext('Arguments'), cell: 'string',
          type: 'text', group: gettext('Definition'), mode: ['properties'],
          disabled: true
        }, {
          id: 'proargtypenames', label: gettext('Signature arguments'), cell: 'string', type: 'text', group: gettext('Definition'), mode: ['properties'],
          disabled: true
        }, {
          id: 'prorettypename', label: gettext('Return type'), cell: 'string',
          type: 'text', group: gettext('Definition'), disabled: true,
          mode: ['properties'], visible: 'isVisible'
        }, {
          id: 'visibility', label: gettext('Visibility'), cell: 'string',
          type: 'text', mode: ['properties'],
          disabled: true
        }, {
          id: 'lanname', label: gettext('Language'), cell: 'string',
          type: 'text', group: gettext('Definition'), disabled: true
        }, {
          id: 'prosrc', label: gettext('Code'), cell: 'string',
          type: 'text', mode: ['properties'],
          group: gettext('Definition'),
          control: Backform.SqlFieldControl,
          extraClasses: ['custom_height_css_class'],
          visible: function visible(m) {
            if (m.get('lanname') == 'c') {
              return false;
            }
            return true;
          }, disabled: true
        }],
        validate: function validate() {
          return null;
        },
        isVisible: function isVisible(m) {
          if (this.name == 'sysproc') {
            return false;
          }
          return true;
        }
      })
    });
  }

  return pgBrowser.Nodes['edbfunc'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(14)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, CodeMirror) {

  /**
    Create and add a rule collection into nodes
    @param {variable} label - Label for Node
    @param {variable} type - Type of Node
    @param {variable} columns - List of columns to
      display under under properties.
   */
  if (!pgBrowser.Nodes['coll-rule']) {
    var rules = pgAdmin.Browser.Nodes['coll-rule'] = pgAdmin.Browser.Collection.extend({
      node: 'rule',
      label: gettext('Rules'),
      type: 'coll-rule',
      getTreeNodeHierarchy: pgBrowser.tableChildTreeNodeHierarchy,
      columns: ["name", "owner", "comment"]
    });
  }

  /**
    Create and Add an Rule Node into nodes
    @param {variable} parent_type - The list of nodes
    under which this node to display
    @param {variable} type - Type of Node
    @param {variable} hasSQL - To show SQL tab
    @param {variable} canDrop - Adds drop rule option
    in the context menu
    @param {variable} canDropCascade - Adds drop Cascade
    rule option in the context menu
   */
  if (!pgBrowser.Nodes['rule']) {
    pgAdmin.Browser.Nodes['rule'] = pgBrowser.Node.extend({
      getTreeNodeHierarchy: pgBrowser.tableChildTreeNodeHierarchy,
      parent_type: ['table', 'view', 'partition'],
      type: 'rule',
      sqlAlterHelp: 'sql-alterrule.html',
      sqlCreateHelp: 'sql-createrule.html',
      dialogHelp: url_for('help.static', { 'filename': 'rule_dialog.html' }),
      label: gettext('rule'),
      collection_type: 'coll-table',
      hasSQL: true,
      hasDepends: true,
      canDrop: function canDrop(itemData, item, data) {
        pgBrowser.Nodes['schema'].canChildDrop.apply(this, [itemData, item, data]);
        if (_.has(itemData, 'label') && itemData.label === '_RETURN') return false;else {
          return true;
        }
      },
      canDropCascade: function canDropCascade(itemData, item, data) {
        pgBrowser.Nodes['schema'].canChildDrop.apply(this, [itemData, item, data]);
        if (_.has(itemData, 'label') && itemData.label === '_RETURN') return false;else {
          return true;
        }
      },
      Init: function Init() {

        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        /**
          Add "create rule" menu option into context and object menu
          for the following nodes:
          coll-rule, rule and view and table.
          @property {data} - Allow create rule option on schema node or
          system rules node.
         */
        pgBrowser.add_menus([{
          name: 'create_rule_on_coll', node: 'coll-rule', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 1, label: gettext('Rule...'),
          icon: 'wcTabIcon icon-rule', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_rule_onView', node: 'view', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 5, label: gettext('Rule...'),
          icon: 'wcTabIcon icon-rule', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_rule', node: 'rule', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 1, label: gettext('Rule...'),
          icon: 'wcTabIcon icon-rule', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_rule', node: 'table', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Rule...'),
          icon: 'wcTabIcon icon-rule', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_rule', node: 'partition', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Rule...'),
          icon: 'wcTabIcon icon-rule', data: { action: 'create', check: true },
          enable: 'canCreate'
        }]);
      },

      /**
        Define model for the rule node and specify the node
        properties of the model in schema.
       */
      model: pgAdmin.Browser.Node.Model.extend({
        schema: [{
          id: 'name', label: gettext('Name'),
          type: 'text', disabled: function disabled(m) {
            // disable name field it it is system rule
            if (m && m.get('name') == "_RETURN") {
              return true;
            }
            if (m.isNew()) {
              return false;
            } else if (m.node_info.server.version >= 90400) {
              return false;
            }
            return true;
          }
        }, {
          id: 'oid', label: gettext('OID'),
          type: 'text', disabled: true, mode: ['properties']
        }, {
          id: 'schema', label: '',
          type: 'text', visible: false, disabled: function disabled(m) {
            // It is used while generating sql
            m.set('schema', m.node_info.schema.label);
          }
        }, {
          id: 'view', label: '',
          type: 'text', visible: false, disabled: function disabled(m) {

            // It is used while generating sql
            m.set('view', this.node_data.label);
          }
        }, {
          id: 'event', label: gettext('Event'), control: 'select2',
          group: gettext('Definition'), type: 'text',
          select2: {
            width: '100%',
            allowClear: false
          },
          options: [{ label: 'Select', value: 'Select' }, { label: 'Insert', value: 'Insert' }, { label: 'Update', value: 'Update' }, { label: 'Delete', value: 'Delete' }]
        }, {
          id: 'do_instead', label: gettext('Do Instead'), group: gettext('Definition'),
          type: 'switch'
        }, {
          id: 'condition', label: gettext('Condition'),
          type: 'text', group: gettext('Definition'),
          control: Backform.SqlFieldControl
        }, {
          id: 'statements', label: gettext('Commands'),
          type: 'text', group: gettext('Definition'),
          control: Backform.SqlFieldControl
        }, {
          id: 'system_rule', label: gettext('System rule?'),
          type: 'switch', mode: ['properties']
        }, {
          id: 'enabled', label: gettext('Enabled?'),
          type: 'switch', mode: ['properties']
        }, {
          id: 'comment', label: gettext('Comment'), cell: 'string', type: 'multiline'
        }],
        validate: function validate() {

          // Triggers specific error messages for fields
          var err = {},
              errmsg,
              field_name = this.get('name');
          if (_.isUndefined(field_name) || _.isNull(field_name) || String(field_name).replace(/^\s+|\s+$/g, '') === '') {
            err['name'] = gettext('Please specify name.');
            errmsg = errmsg || err['name'];
            this.errorModel.set('name', errmsg);
            return errmsg;
          } else {
            this.errorModel.unset('name');
          }
          return null;
        }
      }),

      // Show or hide create rule menu option on parent node
      canCreate: function canCreate(itemData, item, data) {

        // If check is false then , we will allow create menu
        if (data && data.check === false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData;

        // To iterate over tree to check parent node
        while (i) {

          // If it is schema then allow user to create rule
          if (_.indexOf(['schema'], d._type) > -1) return true;

          if ('coll-rule' == d._type) {

            //Check if we are not child of rule
            var prev_i = t.hasParent(i) ? t.parent(i) : null,
                prev_d = prev_i ? t.itemData(prev_i) : null,
                prev_j = t.hasParent(prev_i) ? t.parent(prev_i) : null,
                prev_e = prev_j ? t.itemData(prev_j) : null,
                prev_k = t.hasParent(prev_j) ? t.parent(prev_j) : null,
                prev_f = prev_k ? t.itemData(prev_k) : null;
            if (prev_f._type == 'catalog') {
              return false;
            } else {
              return true;
            }
          }

          /**
            Check if it is view and its parent node is schema
            then allow to create Rule
           */
          else if ('view' == d._type || 'table' == d._type) {
              prev_i = t.hasParent(i) ? t.parent(i) : null;
              prev_d = prev_i ? t.itemData(prev_i) : null;
              prev_j = t.hasParent(prev_i) ? t.parent(prev_i) : null;
              prev_e = prev_j ? t.itemData(prev_j) : null;
              if (prev_e._type == 'schema') {
                return true;
              } else {
                return false;
              }
            }
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }

        // By default we do not want to allow create menu
        return true;
      }

    });
  }

  return pgBrowser.Nodes['coll-rule'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backbone) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(0), __webpack_require__(1), __webpack_require__(6), __webpack_require__(16), __webpack_require__(13), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, $, _, pgBrowser, Backform, Backgrid) {

  Backgrid.PartitionRow = Backgrid.Row.extend({
    modelDuplicateColor: "lightYellow",

    modelUniqueColor: "#fff",

    initialize: function initialize() {
      Backgrid.Row.prototype.initialize.apply(this, arguments);
      var self = this;
      self.model.on("change:is_attach", function () {
        setTimeout(function () {
          self.columns.each(function (col) {
            if (col.get('name') == 'partition_name') {
              var idx = self.columns.indexOf(col),
                  cf = col.get("cellFunction"),
                  cell = new (cf.apply(col, [self.model]))({
                column: col,
                model: self.model
              }),
                  oldCell = self.cells[idx];
              oldCell.remove();
              self.cells[idx] = cell;
              self.render();
            }
          });
        }, 10);
      });
      self.listenTo(self.model, 'pgadmin-session:model:duplicate', self.modelDuplicate);
      self.listenTo(self.model, 'pgadmin-session:model:unique', self.modelUnique);
    },
    modelDuplicate: function modelDuplicate() {
      $(this.el).removeClass("new");
      this.el.style.backgroundColor = this.modelDuplicateColor;
    },
    modelUnique: function modelUnique() {
      this.el.style.backgroundColor = this.modelUniqueColor;
    }
  });

  var getPartitionCell = function getPartitionCell(model) {
    var is_attach = model.get("is_attach");
    if (is_attach) {
      var options = [];
      model.set({ 'partition_name': undefined }, { silent: true });
      _.each(model.top.table_options, function (t) {
        options.push([t.label, t.value]);
      });
      return Backgrid.Extension.Select2Cell.extend({ optionValues: options });
    } else {
      return Backgrid.StringCell;
    }
  };

  Backform.PartitionKeyModel = pgBrowser.Node.Model.extend({
    defaults: {
      key_type: 'column',
      pt_column: undefined,
      expression: undefined
    },
    keys: ['pt_column'],
    schema: [{
      id: 'key_type', label: 'Key type', type: 'select2', editable: true,
      cell: 'select2', cellHeaderClasses: 'width_percent_25',
      select2: { allowClear: false },
      options: [{
        label: 'Column', value: 'column'
      }, {
        label: 'Expression', value: 'expression'
      }]
    }, {
      id: 'pt_column', label: gettext('Column'), type: 'text',
      cell: Backgrid.Extension.Select2DepCell.extend({
        keyPathAccessor: function keyPathAccessor(obj, path) {
          var res = obj;
          if (_.isArray(res)) {
            return _.map(res, function (o) {
              return o['pt_column'];
            });
          }
          path = path.split('.');
          for (var i = 0; i < path.length; i++) {
            if (_.isNull(res)) return null;
            if (_.isEmpty(path[i])) continue;
            if (!_.isUndefined(res[path[i]])) res = res[path[i]];
          }
          return _.isObject(res) && !_.isArray(res) ? null : res;
        },
        initialize: function initialize() {
          // Here we will decide if we need to call URL
          // Or fetch the data from parent columns collection
          var self = this;
          if (this.model.handler) {
            Backgrid.Extension.Select2DepCell.prototype.initialize.apply(this, arguments);
            // Do not listen for any event(s) for existing constraint.
            if (_.isUndefined(self.model.get('oid'))) {
              var tableCols = self.model.top.get('columns');
              self.listenTo(tableCols, 'remove', self.resetColOptions);
              self.listenTo(tableCols, 'change:name', self.resetColOptions);
            }

            self.custom_options();
          }
        },
        resetColOptions: function resetColOptions(m) {
          var self = this;

          setTimeout(function () {
            self.custom_options();
            self.render.apply(self);
          }, 50);
        },
        custom_options: function custom_options() {
          // We will add all the columns entered by user in table model
          var columns = this.model.top.get('columns'),
              typename = this.model.top.get('typname'),
              of_types_tables = this.model.top.of_types_tables,
              added_columns_from_tables = [];

          if (columns.length > 0) {
            _.each(columns.models, function (m) {
              var col = m.get('name');
              if (!_.isUndefined(col) && !_.isNull(col)) {
                added_columns_from_tables.push({ label: col, value: col, image: 'icon-column' });
              }
            });
          } else if (!_.isUndefined(typename) && !_.isNull(typename) && !_.isUndefined(of_types_tables) && of_types_tables.length > 0) {
            // Iterate through all the of_type tables
            _.each(of_types_tables, function (type) {
              if (type.label == typename) {
                // Iterate all the columns of selected "OF TYPE".
                _.each(type.oftype_columns, function (col) {
                  added_columns_from_tables.push({ label: col.name, value: col.name, image: 'icon-column' });
                });
              }
            });
          }

          // Set the values in to options so that user can select
          this.column.set('options', added_columns_from_tables);
        },
        remove: function remove() {
          if (this.model.handler) {
            var self = this,
                tableCols = self.model.top.get('columns');
            self.stopListening(tableCols, 'remove', self.resetColOptions);
            self.stopListening(tableCols, 'change:name', self.resetColOptions);
            Backgrid.Extension.Select2DepCell.prototype.remove.apply(this, arguments);
          }
        }
      }),
      deps: ['key_type'],
      cellHeaderClasses: 'width_percent_30',
      transform: function transform(data) {
        var res = [];
        if (data && _.isArray(data)) {
          _.each(data, function (d) {
            res.push({ label: d.label, value: d.label, image: 'icon-column' });
          });
        }
        return res;
      },
      select2: { allowClear: false },
      editable: function editable(m) {
        if (m.get('key_type') == 'expression') {
          setTimeout(function () {
            m.set('pt_column', undefined);
          }, 10);
          return false;
        }
        return true;
      }
    }, {
      id: 'expression', label: 'Expression', type: 'text',
      cell: Backgrid.Extension.StringDepCell,
      cellHeaderClasses: 'width_percent_45',
      deps: ['key_type'],
      editable: function editable(m) {
        if (m.get('key_type') == 'column') {
          setTimeout(function () {
            m.set('expression', undefined);
          }, 10);
          return false;
        }
        return true;
      }
    }],
    validate: function validate(keys) {
      var col_type = this.get('key_type'),
          pt_column = this.get('pt_column'),
          expression = this.get('expression');

      // Have to clear existing validation before initiating current state
      // validation only
      this.errorModel.clear();

      if (_.isUndefined(col_type) || _.isNull(col_type) || String(col_type).replace(/^\s+|\s+$/g, '') == '') {
        var msg = gettext('Partition key type cannot be empty.');
        this.errorModel.set('key_type', msg);
        return msg;
      } else if (col_type == 'column' && _.isUndefined(pt_column) || _.isNull(pt_column) || String(pt_column).replace(/^\s+|\s+$/g, '') == '') {
        var msg = gettext('Partition key column cannot be empty.');
        this.errorModel.set('pt_column', msg);
        return msg;
      } else if (col_type == 'expression' && _.isUndefined(expression) || _.isNull(expression) || String(expression).replace(/^\s+|\s+$/g, '') == '') {
        var msg = gettext('Partition key expression cannot be empty.');
        this.errorModel.set('expression', msg);
        return msg;
      }

      return null;
    }
  });

  Backform.PartitionsModel = pgBrowser.Node.Model.extend({
    defaults: {
      oid: undefined,
      is_attach: false,
      partition_name: undefined,
      values_from: undefined,
      values_to: undefined,
      values_in: undefined
    },
    keys: ['partition_name'],
    schema: [{
      id: 'oid', label: gettext('OID'), type: 'text'
    }, {
      id: 'is_attach', label: gettext('Operation'), cell: 'switch',
      type: 'switch', options: { 'onText': 'Attach', 'offText': 'Create' },
      cellHeaderClasses: 'width_percent_5',
      editable: function editable(m) {
        if (m instanceof Backbone.Model && m.isNew() && !m.top.isNew()) return true;
        return false;
      }
    }, {
      id: 'partition_name', label: gettext('Name'), type: 'text', cell: 'string',
      cellHeaderClasses: 'width_percent_25',
      editable: function editable(m) {
        if (m instanceof Backbone.Model && m.isNew()) return true;
        return false;
      }, cellFunction: getPartitionCell
    }, {
      id: 'values_from', label: 'From', type: 'text',
      cell: Backgrid.Extension.StringDepCell,
      cellHeaderClasses: 'width_percent_20',
      editable: function editable(m) {
        if (m.handler && m.handler.top && m.handler.top.attributes && m.handler.top.attributes.partition_type == 'range' && m instanceof Backbone.Model && m.isNew()) return true;
        return false;
      }
    }, {
      id: 'values_to', label: 'To', type: 'text',
      cell: Backgrid.Extension.StringDepCell,
      cellHeaderClasses: 'width_percent_20',
      editable: function editable(m) {
        if (m.handler && m.handler.top && m.handler.top.attributes && m.handler.top.attributes.partition_type == 'range' && m instanceof Backbone.Model && m.isNew()) return true;
        return false;
      }
    }, {
      id: 'values_in', label: 'In', type: 'text',
      cell: Backgrid.Extension.StringDepCell,
      cellHeaderClasses: 'width_percent_25',
      editable: function editable(m) {
        if (m.handler && m.handler.top && m.handler.top.attributes && m.handler.top.attributes.partition_type == 'list' && m instanceof Backbone.Model && m.isNew()) return true;
        return false;
      }
    }],
    validate: function validate(keys) {
      var partition_name = this.get('partition_name'),
          values_from = this.get('values_from'),
          values_to = this.get('values_to'),
          values_in = this.get('values_in');

      // Have to clear existing validation before initiating current state
      // validation only
      this.errorModel.clear();

      if (_.isUndefined(partition_name) || _.isNull(partition_name) || String(partition_name).replace(/^\s+|\s+$/g, '') == '') {
        var msg = gettext('Partition name cannot be empty.');
        this.errorModel.set('partition_name', msg);
        return msg;
      }

      if (this.top.get('partition_type') == 'range') {
        if (_.isUndefined(values_from) || _.isNull(values_from) || String(values_from).replace(/^\s+|\s+$/g, '') == '') {
          var msg = gettext('For range partition From field cannot be empty.');
          this.errorModel.set('values_from', msg);
          return msg;
        } else if (_.isUndefined(values_to) || _.isNull(values_to) || String(values_to).replace(/^\s+|\s+$/g, '') == '') {
          var msg = gettext('For range partition To field cannot be empty.');
          this.errorModel.set('values_to', msg);
          return msg;
        }
      } else if (this.top.get('partition_type') == 'list') {
        if (_.isUndefined(values_in) || _.isNull(values_in) || String(values_in).replace(/^\s+|\s+$/g, '') == '') {
          var msg = gettext('For list partition In field cannot be empty.');
          this.errorModel.set('values_in', msg);
          return msg;
        }
      }

      return null;
    }
  });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(pgAdmin) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(187), __webpack_require__(3), __webpack_require__(234), __webpack_require__(268)], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
  var initializeModules = function initializeModules(Object) {
    for (var key in Object) {
      var module = Object[key];
      if (module.init && typeof module.init == 'function') {
        module.init();
      } else if (module.Init && typeof module.Init == 'function') {
        module.Init();
      }
    }
  };

  // Initialize modules registered to pgAdmin, pgAdmin.Browser and Tools object.
  initializeModules(pgAdmin);
  initializeModules(pgAdmin.Browser);
  initializeModules(pgAdmin.Tools);

  // create menus after all modules are initialized.
  pgAdmin.Browser.create_menus();
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*** IMPORTS FROM imports-loader ***/
var pgadmin = pgadmin || {};
pgadmin.about = __webpack_require__(235);
var pgadmin = pgadmin || {};
pgadmin.preferences = __webpack_require__(236);
var pgadmin = pgadmin || {};
pgadmin.file_manager = __webpack_require__(191);
var pgadmin = pgadmin || {};
pgadmin.settings = __webpack_require__(257);
var pgadmin = pgadmin || {};
pgadmin.tools = {};
pgadmin.tools.backup = __webpack_require__(258);
var pgadmin = pgadmin || {};
pgadmin.tools = {};
pgadmin.tools.restore = __webpack_require__(259);
var pgadmin = pgadmin || {};
pgadmin.tools = {};
pgadmin.tools.grant_wizard = __webpack_require__(260);
var pgadmin = pgadmin || {};
pgadmin.tools = {};
pgadmin.tools.maintenance = __webpack_require__(262);
var pgadmin = pgadmin || {};
pgadmin.tools = {};
pgadmin.tools.import_export = __webpack_require__(263);
var pgadmin = pgadmin || {};
pgadmin.tools = {};
pgadmin.tools.debugger = {};
pgadmin.tools.debugger.controller = __webpack_require__(264);
var pgadmin = pgadmin || {};
pgadmin.tools = {};
pgadmin.tools.debugger = {};
pgadmin.tools.debugger.direct = __webpack_require__(160);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.pga_job = __webpack_require__(265);

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function (pgBrowser) {
  pgBrowser.init();
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0), __webpack_require__(8), __webpack_require__(3), __webpack_require__(4), __webpack_require__(2), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, alertify, pgAdmin, S, gettext, url_for) {
  pgAdmin = pgAdmin || window.pgAdmin || {};

  /* Return back, this has been called more than once */
  if (pgAdmin.About) return;

  pgAdmin.About = {
    about_show: function about_show() {
      if (!alertify.aboutDialog) {
        alertify.dialog('aboutDialog', function factory() {
          return {
            main: function main(title, message) {
              this.set('title', title);
              this.message = message;
            },
            setup: function setup() {
              return {
                buttons: [{ text: gettext("OK"), key: 27, className: "btn btn-primary" }],
                options: {
                  modal: false,
                  resizable: true,
                  maximizable: true,
                  pinnable: false,
                  closableByDimmer: false
                }
              };
            },
            build: function build() {
              alertify.pgDialogBuild.apply(this);
            },
            prepare: function prepare() {
              this.setContent(this.message);
            }
          };
        });
      }

      var content = '';
      $.get(url_for('about.index'), function (data) {
        alertify.aboutDialog(S(gettext("About %s")).sprintf(pgAdmin.Browser.utils.app_name).value(), data).resizeTo(800, 450);
      });
    }
  };

  return pgAdmin.About;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(pgAdmin) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

// Backup dialog
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(17), __webpack_require__(6), __webpack_require__(10), __webpack_require__(13), __webpack_require__(16), __webpack_require__(31)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, alertify, pgBrowser, Backbone, Backgrid, Backform, pgNode) {

  // if module is already initialized, refer to that.
  if (pgBrowser.Backup) {
    return pgBrowser.Backup;
  }

  /*
  =====================
  TODO LIST FOR BACKUP:
  =====================
  1) Add Object tree on object tab which allows user to select
     objects which can be backed up
  2) Allow user to select/deselect objects
  3) If database is selected in browser
     show all database children objects selected in Object tree
  4) If schema is selected in browser
     show all schema children objects selected in Object tree
  5) If table is selected then show table/schema/database selected
     in Object tree
  6) if root objects like database/schema is not selected and their
     children are selected then add them separately with in tables attribute
     with schema.
  */

  var CustomSwitchControl = Backform.CustomSwitchControl = Backform.SwitchControl.extend({
    template: _.template(['<label class="<%=Backform.controlLabelClassName%> custom_switch_label_class"><%=label%></label>', '<div class="<%=Backform.controlsClassName%> custom_switch_control_class">', '  <div class="checkbox">', '    <label>', '      <input type="checkbox" class="<%=extraClasses.join(\' \')%>"', '        name="<%=name%>" <%=value ? "checked=\'checked\'" : ""%>', '        <%=disabled ? "disabled" : ""%> <%=required ? "required" : ""%> />', '    </label>', '  </div>', '</div>', '<% if (helpMessage && helpMessage.length) { %>', '  <span class="<%=Backform.helpMessageClassName%>"><%=helpMessage%></span>', '<% } %>'].join("\n")),
    className: 'pgadmin-control-group form-group pg-el-md-6 pg-el-xs-12'
  });

  //Backup Model (Server Node)
  var BackupModel = Backbone.Model.extend({
    idAttribute: 'id',
    defaults: {
      file: undefined,
      role: undefined,
      dqoute: false,
      verbose: true,
      type: undefined /* global, server */
    },
    schema: [{
      id: 'file', label: gettext('Filename'),
      type: 'text', disabled: false, control: Backform.FileControl,
      dialog_type: 'create_file', supp_types: ['*', 'sql', 'backup']
    }, {
      id: 'role', label: gettext('Role name'),
      control: 'node-list-by-name', node: 'role',
      select2: { allowClear: false }
    }, {
      type: 'nested', control: 'fieldset', label: gettext('Miscellaneous'),
      schema: [{
        id: 'verbose', label: gettext('Verbose messages'),
        control: Backform.CustomSwitchControl, disabled: false,
        group: gettext('Miscellaneous')
      }, {
        id: 'dqoute', label: gettext('Force double quote on identifiers'),
        control: Backform.CustomSwitchControl, disabled: false,
        group: gettext('Miscellaneous')
      }]
    }, {
      id: 'server_note', label: gettext('Note'),
      text: gettext('The backup format will be PLAIN'),
      type: 'note', visible: function visible(m) {
        return m.get('type') === 'server';
      }
    }, {
      id: 'globals_note', label: gettext('Note'),
      text: gettext('Only objects global to the entire database will be backed up in PLAIN format'),
      type: 'note', visible: function visible(m) {
        return m.get('type') === 'globals';
      }
    }, {}],
    validate: function validate() {
      // TODO: HOW TO VALIDATE ???
      return null;
    }
  });

  //Backup Model (Objects like Database/Schema/Table)
  var BackupObjectModel = Backbone.Model.extend({
    idAttribute: 'id',
    defaults: {
      file: undefined,
      role: undefined,
      format: 'custom',
      verbose: true,
      blobs: true,
      encoding: undefined,
      schemas: [],
      tables: [],
      database: undefined
    },
    schema: [{
      id: 'file', label: gettext('Filename'),
      type: 'text', disabled: false, control: Backform.FileControl,
      dialog_type: 'create_file', supp_types: ['*', 'sql', 'backup']
    }, {
      id: 'format', label: gettext('Format'),
      type: 'text', disabled: false,
      control: 'select2', select2: {
        allowClear: false,
        width: "100%"
      },
      options: [{ label: gettext('Custom'), value: "custom" }, { label: gettext('Tar'), value: "tar" }, { label: gettext('Plain'), value: "plain" }, { label: gettext('Directory'), value: "directory" }]
    }, {
      id: 'ratio', label: gettext('Compression ratio'),
      type: 'int', min: 0, max: 9, disabled: false
    }, {
      id: 'encoding', label: gettext('Encoding'),
      type: 'text', disabled: false, node: 'database',
      control: 'node-ajax-options', url: 'get_encodings'
    }, {
      id: 'no_of_jobs', label: gettext('Number of jobs'),
      type: 'int', deps: ['format'], disabled: function disabled(m) {
        return !(m.get('format') === "Directory");
      }
    }, {
      id: 'role', label: gettext('Role name'),
      control: 'node-list-by-name', node: 'role',
      select2: { allowClear: false }
    }, {
      type: 'nested', control: 'fieldset', label: gettext('Sections'),
      group: gettext('Dump options'),
      schema: [{
        id: 'pre_data', label: gettext('Pre-data'),
        control: Backform.CustomSwitchControl, group: gettext('Sections'),
        deps: ['only_data', 'only_schema'], disabled: function disabled(m) {
          return m.get('only_data') || m.get('only_schema');
        }
      }, {
        id: 'data', label: gettext('Data'),
        control: Backform.CustomSwitchControl, group: gettext('Sections'),
        deps: ['only_data', 'only_schema'], disabled: function disabled(m) {
          return m.get('only_data') || m.get('only_schema');
        }
      }, {
        id: 'post_data', label: gettext('Post-data'),
        control: Backform.CustomSwitchControl, group: gettext('Sections'),
        deps: ['only_data', 'only_schema'], disabled: function disabled(m) {
          return m.get('only_data') || m.get('only_schema');
        }
      }]
    }, {
      type: 'nested', control: 'fieldset', label: gettext('Type of objects'),
      group: gettext('Dump options'),
      schema: [{
        id: 'only_data', label: gettext('Only data'),
        control: Backform.CustomSwitchControl, group: gettext('Type of objects'),
        deps: ['pre_data', 'data', 'post_data', 'only_schema'], disabled: function disabled(m) {
          return m.get('pre_data') || m.get('data') || m.get('post_data') || m.get('only_schema');
        }
      }, {
        id: 'only_schema', label: gettext('Only schema'),
        control: Backform.CustomSwitchControl, group: gettext('Type of objects'),
        deps: ['pre_data', 'data', 'post_data', 'only_data'], disabled: function disabled(m) {
          return m.get('pre_data') || m.get('data') || m.get('post_data') || m.get('only_data');
        }
      }, {
        id: 'blobs', label: gettext('Blobs'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Type of objects')
      }]
    }, {
      type: 'nested', control: 'fieldset', label: gettext('Do not save'),
      group: gettext('Dump options'),
      schema: [{
        id: 'dns_owner', label: gettext('Owner'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Do not save')
      }, {
        id: 'dns_privilege', label: gettext('Privilege'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Do not save')
      }, {
        id: 'dns_tablespace', label: gettext('Tablespace'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Do not save')
      }, {
        id: 'dns_unlogged_tbl_data', label: gettext('Unlogged table data'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Do not save')
      }]
    }, {
      type: 'nested', control: 'fieldset', label: gettext('Queries'),
      group: gettext('Dump options'),
      schema: [{
        id: 'use_column_inserts', label: gettext('Use Column Inserts'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Queries')
      }, {
        id: 'use_insert_commands', label: gettext('Use Insert Commands'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Queries')
      }, {
        id: 'include_create_database', label: gettext('Include CREATE DATABASE statement'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Queries')
      }, {
        id: 'include_drop_database', label: gettext('Include DROP DATABASE statement'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Queries')
      }]
    }, {
      type: 'nested', control: 'fieldset', label: gettext('Disable'),
      group: gettext('Dump options'),
      schema: [{
        id: 'disable_trigger', label: gettext('Trigger'),
        control: Backform.CustomSwitchControl, group: gettext('Disable'),
        deps: ['only_data'], disabled: function disabled(m) {
          return !m.get('only_data');
        }
      }, {
        id: 'disable_quoting', label: gettext('$ quoting'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Disable')
      }]
    }, {
      type: 'nested', control: 'fieldset', label: gettext('Miscellaneous'),
      group: gettext('Dump options'),
      schema: [{
        id: 'with_oids', label: gettext('With OID(s)'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Miscellaneous')
      }, {
        id: 'verbose', label: gettext('Verbose messages'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Miscellaneous')
      }, {
        id: 'dqoute', label: gettext('Force double quote on identifiers'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Miscellaneous')
      }, {
        id: 'use_set_session_auth', label: gettext('Use SET SESSION AUTHORIZATION'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Miscellaneous')
      }]
    }],
    validate: function validate() {
      return null;
    }
  });

  // Create an Object Backup of pgBrowser class
  pgBrowser.Backup = {
    init: function init() {
      if (this.initialized) return;

      this.initialized = true;

      // Define list of nodes on which backup context menu option appears
      var backup_supported_nodes = ['database', 'schema', 'table', 'partition'];

      /**
        Enable/disable backup menu in tools based
        on node selected
        if selected node is present in supported_nodes,
        menu will be enabled otherwise disabled.
        Also, hide it for system view in catalogs
      */
      var menu_enabled = function menu_enabled(itemData, item, data) {
        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        var parent_item = t.hasParent(i) ? t.parent(i) : null,
            parent_data = parent_item ? t.itemData(parent_item) : null;
        if (!_.isUndefined(d) && !_.isNull(d) && !_.isNull(parent_data)) {
          if (_.indexOf(backup_supported_nodes, d._type) !== -1 && parent_data._type != 'catalog') {
            if (d._type == 'database' && d.allowConn) return true;else if (d._type != 'database') return true;else return false;
          } else return false;
        } else return false;
      };

      var menu_enabled_server = function menu_enabled_server(itemData, item, data) {
        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        var parent_item = t.hasParent(i) ? t.parent(i) : null,
            parent_data = parent_item ? t.itemData(parent_item) : null;
        // If server node selected && connected
        if (!_.isUndefined(d) && !_.isNull(d)) return 'server' === d._type && d.connected;else false;
      };

      // Define the nodes on which the menus to be appear
      var menus = [{
        name: 'backup_global', module: this,
        applies: ['tools'], callback: 'start_backup_global',
        priority: 12, label: gettext('Backup Globals...'),
        icon: 'fa fa-floppy-o', enable: menu_enabled_server
      }, {
        name: 'backup_server', module: this,
        applies: ['tools'], callback: 'start_backup_server',
        priority: 12, label: gettext('Backup Server...'),
        icon: 'fa fa-floppy-o', enable: menu_enabled_server
      }, {
        name: 'backup_global_ctx', module: this, node: 'server',
        applies: ['context'], callback: 'start_backup_global',
        priority: 12, label: gettext('Backup Globals...'),
        icon: 'fa fa-floppy-o', enable: menu_enabled_server
      }, {
        name: 'backup_server_ctx', module: this, node: 'server',
        applies: ['context'], callback: 'start_backup_server',
        priority: 12, label: gettext('Backup Server...'),
        icon: 'fa fa-floppy-o', enable: menu_enabled_server
      }, {
        name: 'backup_object', module: this,
        applies: ['tools'], callback: 'backup_objects',
        priority: 11, label: gettext('Backup...'),
        icon: 'fa fa-floppy-o', enable: menu_enabled
      }];

      for (var idx = 0; idx < backup_supported_nodes.length; idx++) {
        menus.push({
          name: 'backup_' + backup_supported_nodes[idx],
          node: backup_supported_nodes[idx], module: this,
          applies: ['context'], callback: 'backup_objects',
          priority: 11, label: gettext('Backup...'),
          icon: 'fa fa-floppy-o', enable: menu_enabled
        });
      }

      pgAdmin.Browser.add_menus(menus);
      return this;
    },
    start_backup_global: function start_backup_global(action, item) {
      var params = { 'globals': true };
      this.start_backup_global_server.apply(this, [action, item, params]);
    },
    start_backup_server: function start_backup_server(action, item) {
      var params = { 'server': true };
      this.start_backup_global_server.apply(this, [action, item, params]);
    },

    // Callback to draw Backup Dialog for globals/server
    start_backup_global_server: function start_backup_global_server(action, item, params) {
      var i = item || pgBrowser.tree.selected(),
          server_data = null;

      while (i) {
        var node_data = pgBrowser.tree.itemData(i);
        if (node_data._type == 'server') {
          server_data = node_data;
          break;
        }

        if (pgBrowser.tree.hasParent(i)) {
          i = $(pgBrowser.tree.parent(i));
        } else {
          alertify.alert(gettext("Please select server or child node from the browser tree."));
          break;
        }
      }

      if (!server_data) {
        return;
      }

      var module = 'paths',
          preference_name = 'pg_bin_dir',
          msg = gettext('Please configure the PostgreSQL Binary Path in the Preferences dialog.');

      if (server_data.type && server_data.type == 'ppas' || server_data.server_type == 'ppas') {
        preference_name = 'ppas_bin_dir';
        msg = gettext('Please configure the EDB Advanced Server Binary Path in the Preferences dialog.');
      }

      var preference = pgBrowser.get_preference(module, preference_name);

      if (preference) {
        if (!preference.value) {
          alertify.alert(gettext('Configuration required'), msg);
          return;
        }
      } else {
        alertify.alert(S(gettext('Failed to load preference %s of module %s')).sprintf(preference_name, module).value());
        return;
      }

      var of_type = undefined;

      // Set Notes according to type of backup
      if (!_.isUndefined(params['globals']) && params['globals']) {
        of_type = 'globals';
      } else {
        of_type = 'server';
      }

      var DialogName = 'BackupDialog_' + of_type,
          DialogTitle = of_type == 'globals' ? gettext('Backup Globals...') : gettext('Backup Server...');

      if (!alertify[DialogName]) {
        alertify.dialog(DialogName, function factory() {
          return {
            main: function main(title) {
              this.set('title', title);
            },
            build: function build() {
              alertify.pgDialogBuild.apply(this);
            },
            setup: function setup() {
              return {
                buttons: [{
                  text: '', className: 'btn btn-default pull-left fa fa-lg fa-info',
                  attrs: { name: 'object_help', type: 'button', url: 'backup.html', label: gettext('Backup') }
                }, {
                  text: '', key: 112, className: 'btn btn-default pull-left fa fa-lg fa-question',
                  attrs: {
                    name: 'dialog_help', type: 'button', label: gettext('Backup'),
                    url: url_for('help.static', { 'filename': 'backup_dialog.html' })
                  }
                }, {
                  text: gettext('Backup'), key: 13, className: 'btn btn-primary fa fa-lg fa-save pg-alertify-button',
                  'data-btn-name': 'backup'
                }, {
                  text: gettext('Cancel'), key: 27, className: 'btn btn-danger fa fa-lg fa-times pg-alertify-button',
                  'data-btn-name': 'cancel'
                }],
                // Set options for dialog
                options: {
                  title: DialogTitle,
                  //disable both padding and overflow control.
                  padding: !1,
                  overflow: !1,
                  model: 0,
                  resizable: true,
                  maximizable: true,
                  pinnable: false,
                  closableByDimmer: false,
                  modal: false
                }
              };
            },
            hooks: {
              // Triggered when the dialog is closed
              onclose: function onclose() {
                if (this.view) {
                  // clear our backform model/view
                  this.view.remove({ data: true, internal: true, silent: true });
                }
              }
            },
            prepare: function prepare() {
              var self = this;
              // Disable Backup button until user provides Filename
              this.__internal.buttons[2].element.disabled = true;

              var $container = $("<div class='backup_dialog'></div>");
              // Find current/selected node
              var t = pgBrowser.tree,
                  i = t.selected(),
                  d = i && i.length == 1 ? t.itemData(i) : undefined,
                  node = d && pgBrowser.Nodes[d._type];

              if (!d) return;
              // Create treeInfo
              var treeInfo = node.getTreeNodeHierarchy.apply(node, [i]);
              // Instance of backbone model
              var newModel = new BackupModel({ type: of_type }, { node_info: treeInfo }),
                  fields = Backform.generateViewSchema(treeInfo, newModel, 'create', node, treeInfo.server, true);

              var view = this.view = new Backform.Dialog({
                el: $container, model: newModel, schema: fields
              });
              // Add our class to alertify
              $(this.elements.body.childNodes[0]).addClass('alertify_tools_dialog_properties obj_properties');
              // Render dialog
              view.render();

              this.elements.content.appendChild($container.get(0));

              // Listen to model & if filename is provided then enable Backup button
              this.view.model.on('change', function () {
                if (!_.isUndefined(this.get('file')) && this.get('file') !== '') {
                  this.errorModel.clear();
                  self.__internal.buttons[2].element.disabled = false;
                } else {
                  self.__internal.buttons[2].element.disabled = true;
                  this.errorModel.set('file', gettext('Please provide a filename'));
                }
              });
            },
            // Callback functions when click on the buttons of the Alertify dialogs
            callback: function callback(e) {
              // Fetch current server id
              var t = pgBrowser.tree,
                  i = t.selected(),
                  d = i && i.length == 1 ? t.itemData(i) : undefined,
                  node = d && pgBrowser.Nodes[d._type];

              if (e.button.element.name == "dialog_help" || e.button.element.name == "object_help") {
                e.cancel = true;
                pgBrowser.showHelp(e.button.element.name, e.button.element.getAttribute('url'), node, i, e.button.element.getAttribute('label'));
                return;
              }

              if (e.button['data-btn-name'] === "backup") {

                if (!d) return;

                var treeInfo = node.getTreeNodeHierarchy.apply(node, [i]);

                var self = this,
                    baseUrl = url_for('backup.create_server_job', { 'sid': treeInfo.server._id }),
                    args = this.view.model.toJSON();

                $.ajax({
                  url: baseUrl,
                  method: 'POST',
                  data: { 'data': JSON.stringify(args) },
                  success: function success(res) {
                    if (res.success) {
                      alertify.success(gettext('Backup job created.'), 5);
                      pgBrowser.Events.trigger('pgadmin-bgprocess:created', self);
                    } else {
                      console.log(res);
                    }
                  },
                  error: function error(xhr, status, _error) {
                    try {
                      var err = $.parseJSON(xhr.responseText);
                      alertify.alert(gettext('Backup job failed.'), err.errormsg);
                    } catch (e) {}
                  }
                });
              }
            }
          };
        });
      }
      alertify[DialogName](true).resizeTo('60%', '50%');
    },

    // Callback to draw Backup Dialog for objects
    backup_objects: function backup_objects(action, treeItem) {

      var i = treeItem || pgBrowser.tree.selected(),
          server_data = null;

      while (i) {
        var node_data = pgBrowser.tree.itemData(i);
        if (node_data._type == 'server') {
          server_data = node_data;
          break;
        }

        if (pgBrowser.tree.hasParent(i)) {
          i = $(pgBrowser.tree.parent(i));
        } else {
          alertify.alert(gettext("Please select server or child node from tree."));
          break;
        }
      }

      if (!server_data) {
        return;
      }

      var module = 'paths',
          preference_name = 'pg_bin_dir',
          msg = gettext('Please set binary path for PostgreSQL Server from preferences.');

      if (server_data.type && server_data.type == 'ppas' || server_data.server_type == 'ppas') {
        preference_name = 'ppas_bin_dir';
        msg = gettext('Please set binary path for EDB Postgres Advanced Server from preferences.');
      }

      var preference = pgBrowser.get_preference(module, preference_name);

      if (preference) {
        if (!preference.value) {
          alertify.alert(msg);
          return;
        }
      } else {
        alertify.alert(S(gettext('Failed to load preference %s of module %s')).sprintf(preference_name, module).value());
        return;
      }

      var title = S(gettext('Backup (%s: %s)')),
          tree = pgBrowser.tree,
          item = treeItem || tree.selected(),
          data = item && item.length == 1 && tree.itemData(item),
          node = data && data._type && pgBrowser.Nodes[data._type];

      if (!node) return;

      title = title.sprintf(node.label, data.label).value();

      if (!alertify.backup_objects) {
        // Create Dialog title on the fly with node details
        alertify.dialog('backup_objects', function factory() {
          return {
            main: function main(title) {
              this.set('title', title);
            },
            build: function build() {
              alertify.pgDialogBuild.apply(this);
            },
            setup: function setup() {
              return {
                buttons: [{
                  text: '', className: 'btn btn-default pull-left fa fa-lg fa-info',
                  attrs: { name: 'object_help', type: 'button', url: 'backup.html', label: gettext('Backup') }
                }, {
                  text: '', key: 112, className: 'btn btn-default pull-left fa fa-lg fa-question',
                  attrs: {
                    name: 'dialog_help', type: 'button', label: gettext('Backup'),
                    url: url_for('help.static', { 'filename': 'backup_dialog.html' })
                  }
                }, {
                  text: gettext('Backup'), key: 13, className: 'btn btn-primary fa fa-lg fa-save pg-alertify-button',
                  'data-btn-name': 'backup'
                }, {
                  text: gettext('Cancel'), key: 27, className: 'btn btn-danger fa fa-lg fa-times pg-alertify-button',
                  'data-btn-name': 'cancel'
                }],
                // Set options for dialog
                options: {
                  title: title,
                  //disable both padding and overflow control.
                  padding: !1,
                  overflow: !1,
                  model: 0,
                  resizable: true,
                  maximizable: true,
                  pinnable: false,
                  closableByDimmer: false,
                  modal: false
                }
              };
            },
            hooks: {
              // triggered when the dialog is closed
              onclose: function onclose() {
                if (this.view) {
                  this.view.remove({ data: true, internal: true, silent: true });
                }
              }
            },
            prepare: function prepare() {
              var self = this;
              // Disable Backup button until user provides Filename
              this.__internal.buttons[2].element.disabled = true;
              var $container = $("<div class='backup_dialog'></div>");
              var t = pgBrowser.tree,
                  i = t.selected(),
                  d = i && i.length == 1 ? t.itemData(i) : undefined,
                  node = d && pgBrowser.Nodes[d._type];

              if (!d) return;

              var treeInfo = node.getTreeNodeHierarchy.apply(node, [i]);

              var newModel = new BackupObjectModel({}, { node_info: treeInfo }),
                  fields = Backform.generateViewSchema(treeInfo, newModel, 'create', node, treeInfo.server, true);

              var view = this.view = new Backform.Dialog({
                el: $container, model: newModel, schema: fields
              });

              $(this.elements.body.childNodes[0]).addClass('alertify_tools_dialog_properties obj_properties');

              view.render();

              this.elements.content.appendChild($container.get(0));

              // Listen to model & if filename is provided then enable Backup button
              this.view.model.on('change', function () {
                if (!_.isUndefined(this.get('file')) && this.get('file') !== '') {
                  this.errorModel.clear();
                  self.__internal.buttons[2].element.disabled = false;
                } else {
                  self.__internal.buttons[2].element.disabled = true;
                  this.errorModel.set('file', gettext('Please provide filename'));
                }
              });
            },
            // Callback functions when click on the buttons of the Alertify dialogs
            callback: function callback(e) {
              // Fetch current server id
              var t = pgBrowser.tree,
                  i = t.selected(),
                  d = i && i.length == 1 ? t.itemData(i) : undefined,
                  node = d && pgBrowser.Nodes[d._type];

              if (e.button.element.name == "dialog_help" || e.button.element.name == "object_help") {
                e.cancel = true;
                pgBrowser.showHelp(e.button.element.name, e.button.element.getAttribute('url'), node, i, e.button.element.getAttribute('label'));
                return;
              }

              if (e.button['data-btn-name'] === "backup") {
                if (!d) return;

                var treeInfo = node.getTreeNodeHierarchy.apply(node, [i]);

                // Set current database into model
                this.view.model.set('database', treeInfo.database._label);

                // We will remove once object tree is implemented
                // If selected node is Schema then add it in model
                if (d._type == 'schema') {
                  var schemas = [];
                  schemas.push(d._label);
                  this.view.model.set('schemas', schemas);
                }
                // If selected node is Table then add it in model along with
                // its schema
                if (d._type == 'table') {
                  this.view.model.set('tables', [[treeInfo.schema._label, d._label]]);
                }

                // Remove ratio attribute from model if it has empty string.
                // The valid value can be between 0 to 9.
                if (_.isEmpty(this.view.model.get('ratio'))) {
                  this.view.model.unset('ratio');
                }

                var self = this,
                    baseUrl = url_for('backup.create_object_job', { 'sid': treeInfo.server._id }),
                    args = this.view.model.toJSON();

                $.ajax({
                  url: baseUrl,
                  method: 'POST',
                  data: { 'data': JSON.stringify(args) },
                  success: function success(res) {
                    if (res.success) {
                      alertify.success(gettext('Backup job created.'), 5);
                      pgBrowser.Events.trigger('pgadmin-bgprocess:created', self);
                    }
                  },
                  error: function error(xhr, status, _error2) {
                    try {
                      var err = $.parseJSON(xhr.responseText);
                      alertify.alert(gettext('Backup job failed.'), err.errormsg);
                    } catch (e) {}
                  }
                });
              }
            }
          };
        });
      }
      alertify.backup_objects(title).resizeTo('65%', '60%');
    }
  };
  return pgBrowser.Backup;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(pgAdmin) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

// Restore dialog
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(17), __webpack_require__(6), __webpack_require__(10), __webpack_require__(13), __webpack_require__(16), __webpack_require__(31)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, alertify, pgBrowser, Backbone, Backgrid, Backform, pgNode) {

  // if module is already initialized, refer to that.
  if (pgBrowser.Restore) {
    return pgBrowser.Restore;
  }

  var CustomSwitchControl = Backform.CustomSwitchControl = Backform.SwitchControl.extend({
    template: _.template(['<label class="<%=Backform.controlLabelClassName%> custom_switch_label_class"><%=label%></label>', '<div class="<%=Backform.controlsClassName%> custom_switch_control_class">', '  <div class="checkbox">', '    <label>', '      <input type="checkbox" class="<%=extraClasses.join(\' \')%>" name="<%=name%>" <%=value ? "checked=\'checked\'" : ""%> <%=disabled ? "disabled" : ""%> <%=required ? "required" : ""%> />', '    </label>', '  </div>', '</div>', '<% if (helpMessage && helpMessage.length) { %>', '  <span class="<%=Backform.helpMessageClassName%>"><%=helpMessage%></span>', '<% } %>'].join("\n")),
    className: 'pgadmin-control-group form-group pg-el-xs-4'
  });

  //Restore Model (Objects like Database/Schema/Table)
  var RestoreObjectModel = Backbone.Model.extend({
    idAttribute: 'id',
    defaults: {
      custom: false,
      file: undefined,
      role: undefined,
      format: 'custom',
      verbose: true,
      blobs: true,
      encoding: undefined,
      database: undefined,
      schemas: undefined,
      tables: undefined,
      functions: undefined,
      triggers: undefined,
      trigger_funcs: undefined,
      indexes: undefined
    },

    // Default values!
    initialize: function initialize(attrs, args) {
      // Set default options according to node type selection by user
      var node_type = attrs.node_data.type;

      if (node_type) {
        // Only_Schema option
        if (node_type === 'function' || node_type === 'index' || node_type === 'trigger') {
          this.set({ 'only_schema': true }, { silent: true });
        }

        // Only_Data option
        if (node_type === 'table') {
          this.set({ 'only_data': true }, { silent: true });
        }

        // Clean option
        if (node_type === 'function' || node_type === 'trigger_function') {
          this.set({ 'clean': true }, { silent: true });
        }
      }
      Backbone.Model.prototype.initialize.apply(this, arguments);
    },
    schema: [{
      id: 'format', label: gettext('Format'),
      type: 'text', disabled: false,
      control: 'select2', select2: {
        allowClear: false,
        width: "100%"
      },
      options: [{ label: gettext('Custom or tar'), value: "custom" }, { label: gettext('Directory'), value: "directory" }]
    }, {
      id: 'file', label: gettext('Filename'),
      type: 'text', disabled: false, control: Backform.FileControl,
      dialog_type: 'select_file', supp_types: ['*', 'backup', 'sql', 'patch']
    }, {
      id: 'no_of_jobs', label: gettext('Number of jobs'),
      type: 'int'
    }, {
      id: 'role', label: gettext('Role name'),
      control: 'node-list-by-name', node: 'role',
      select2: { allowClear: false }
    }, {
      type: 'nested', control: 'fieldset', label: gettext('Sections'),
      group: gettext('Restore options'),
      schema: [{
        id: 'pre_data', label: gettext('Pre-data'),
        control: Backform.CustomSwitchControl, group: gettext('Sections'),
        deps: ['only_data', 'only_schema'], disabled: function disabled(m) {
          return this.node.type !== 'function' && this.node.type !== 'table' && this.node.type !== 'trigger' && this.node.type !== 'trigger_function' && (m.get('only_data') || m.get('only_schema'));
        }
      }, {
        id: 'data', label: gettext('Data'),
        control: Backform.CustomSwitchControl, group: gettext('Sections'),
        deps: ['only_data', 'only_schema'], disabled: function disabled(m) {
          return this.node.type !== 'function' && this.node.type !== 'table' && this.node.type !== 'trigger' && this.node.type !== 'trigger_function' && (m.get('only_data') || m.get('only_schema'));
        }
      }, {
        id: 'post_data', label: gettext('Post-data'),
        control: Backform.CustomSwitchControl, group: gettext('Sections'),
        deps: ['only_data', 'only_schema'], disabled: function disabled(m) {
          return this.node.type !== 'function' && this.node.type !== 'table' && this.node.type !== 'trigger' && this.node.type !== 'trigger_function' && (m.get('only_data') || m.get('only_schema'));
        }
      }]
    }, {
      type: 'nested', control: 'fieldset', label: gettext('Type of objects'),
      group: gettext('Restore options'),
      schema: [{
        id: 'only_data', label: gettext('Only data'),
        control: Backform.CustomSwitchControl, group: gettext('Type of objects'),
        deps: ['pre_data', 'data', 'post_data', 'only_schema'], disabled: function disabled(m) {
          return this.node.type !== 'database' && this.node.type !== 'schema' || m.get('pre_data') || m.get('data') || m.get('post_data') || m.get('only_schema');
        }
      }, {
        id: 'only_schema', label: gettext('Only schema'),
        control: Backform.CustomSwitchControl, group: gettext('Type of objects'),
        deps: ['pre_data', 'data', 'post_data', 'only_data'], disabled: function disabled(m) {
          return this.node.type !== 'database' && this.node.type !== 'schema' || m.get('pre_data') || m.get('data') || m.get('post_data') || m.get('only_data');
        }
      }]
    }, {
      type: 'nested', control: 'fieldset', label: gettext('Do not save'),
      group: gettext('Restore options'),
      schema: [{
        id: 'dns_owner', label: gettext('Owner'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Do not save')
      }, {
        id: 'dns_privilege', label: gettext('Privilege'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Do not save')
      }, {
        id: 'dns_tablespace', label: gettext('Tablespace'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Do not save')
      }]
    }, {
      type: 'nested', control: 'fieldset', label: gettext('Queries'),
      group: gettext('Restore options'),
      schema: [{
        id: 'include_create_database', label: gettext('Include CREATE DATABASE statement'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Queries')
      }, {
        id: 'clean', label: gettext('Clean before restore'),
        control: Backform.CustomSwitchControl, group: gettext('Queries'),
        disabled: function disabled(m) {
          return this.node.type === 'function' || this.node.type === 'trigger_function';
        }
      }, {
        id: 'single_transaction', label: gettext('Single transaction'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Queries')
      }]
    }, {
      type: 'nested', control: 'fieldset', label: gettext('Disable'),
      group: gettext('Restore options'),
      schema: [{
        id: 'disable_trigger', label: gettext('Trigger'),
        control: Backform.CustomSwitchControl, group: gettext('Disable')
      }, {
        id: 'no_data_fail_table', label: gettext('No data for Failed Tables'),
        control: Backform.CustomSwitchControl, disabled: false, group: gettext('Disable')
      }]
    }, {
      type: 'nested', control: 'fieldset', label: gettext('Miscellaneous / Behavior'),
      group: gettext('Restore options'),
      schema: [{
        id: 'verbose', label: gettext('Verbose messages'),
        control: Backform.CustomSwitchControl, disabled: false,
        group: gettext('Miscellaneous / Behavior')
      }, {
        id: 'use_set_session_auth', label: gettext('Use SET SESSION AUTHORIZATION'),
        control: Backform.CustomSwitchControl, disabled: false,
        group: gettext('Miscellaneous / Behavior')
      }, {
        id: 'exit_on_error', label: gettext('Exit on error'),
        control: Backform.CustomSwitchControl, disabled: false,
        group: gettext('Miscellaneous / Behavior')
      }]
    }],
    validate: function validate() {
      return null;
    }
  });

  // Create an Object Restore of pgBrowser class
  pgBrowser.Restore = {
    init: function init() {
      if (this.initialized) return;

      this.initialized = true;

      // Define list of nodes on which restore context menu option appears
      var restore_supported_nodes = ['database', 'schema', 'table', 'function', 'trigger', 'index', 'partition'];

      /**
        Enable/disable restore menu in tools based
        on node selected
        if selected node is present in supported_nodes,
        menu will be enabled otherwise disabled.
        Also, hide it for system view in catalogs
      */
      var menu_enabled = function menu_enabled(itemData, item, data) {
        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        var parent_item = t.hasParent(i) ? t.parent(i) : null,
            parent_data = parent_item ? t.itemData(parent_item) : null;
        if (!_.isUndefined(d) && !_.isNull(d) && !_.isNull(parent_data)) {
          if (_.indexOf(restore_supported_nodes, d._type) !== -1 && is_parent_catalog(itemData, item, data)) {
            if (d._type == 'database' && d.allowConn) return true;else if (d._type != 'database') return true;else return false;
          } else return false;
        } else return false;
      };

      var is_parent_catalog = function is_parent_catalog(itemData, item, data) {
        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        // To iterate over tree to check parent node
        while (i) {
          // If it is schema then allow user to restore
          if (_.indexOf(['catalog'], d._type) > -1) return false;
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // by default we do not want to allow create menu
        return true;
      };

      // Define the nodes on which the menus to be appear
      var menus = [{
        name: 'restore_object', module: this,
        applies: ['tools'], callback: 'restore_objects',
        priority: 13, label: gettext('Restore...'),
        icon: 'fa fa-upload', enable: menu_enabled
      }];

      for (var idx = 0; idx < restore_supported_nodes.length; idx++) {
        menus.push({
          name: 'restore_' + restore_supported_nodes[idx],
          node: restore_supported_nodes[idx], module: this,
          applies: ['context'], callback: 'restore_objects',
          priority: 13, label: gettext('Restore...'),
          icon: 'fa fa-upload', enable: menu_enabled
        });
      }

      pgAdmin.Browser.add_menus(menus);
      return this;
    },
    // Callback to draw Backup Dialog for objects
    restore_objects: function restore_objects(action, treeItem) {

      var i = treeItem || pgBrowser.tree.selected(),
          server_data = null;

      while (i) {
        var node_data = pgBrowser.tree.itemData(i);
        if (node_data._type == 'server') {
          server_data = node_data;
          break;
        }

        if (pgBrowser.tree.hasParent(i)) {
          i = $(pgBrowser.tree.parent(i));
        } else {
          alertify.alert(gettext("Please select server or child node from tree."));
          break;
        }
      }

      if (!server_data) {
        return;
      }

      var module = 'paths',
          preference_name = 'pg_bin_dir',
          msg = gettext('Please configure the PostgreSQL Binary Path in the Preferences dialog.');

      if (server_data.type && server_data.type == 'ppas' || server_data.server_type == 'ppas') {
        preference_name = 'ppas_bin_dir';
        msg = gettext('Please configure the EDB Advanced Server Binary Path in the Preferences dialog.');
      }

      var preference = pgBrowser.get_preference(module, preference_name);

      if (preference) {
        if (!preference.value) {
          alertify.alert(gettext('Configuration required'), msg);
          return;
        }
      } else {
        alertify.alert(S(gettext('Failed to load preference %s of module %s')).sprintf(preference_name, module).value());
        return;
      }

      var title = S(gettext('Restore (%s: %s)')),
          tree = pgBrowser.tree,
          item = treeItem || tree.selected(),
          data = item && item.length == 1 && tree.itemData(item),
          node = data && data._type && pgBrowser.Nodes[data._type];

      if (!node) return;

      title = title.sprintf(node.label, data.label).value();

      if (!alertify.pg_restore) {
        // Create Dialog title on the fly with node details
        alertify.dialog('pg_restore', function factory() {
          return {
            main: function main(title, item, data, node) {
              this.set('title', title);
              this.setting('pg_node', node);
              this.setting('pg_item', item);
              this.setting('pg_item_data', data);
            },
            build: function build() {
              alertify.pgDialogBuild.apply(this);
            },
            setup: function setup() {
              return {
                buttons: [{
                  text: '', className: 'btn btn-default pull-left fa fa-lg fa-info',
                  attrs: { name: 'object_help', type: 'button', url: 'backup.html', label: gettext('Restore') }
                }, {
                  text: '', key: 112, className: 'btn btn-default pull-left fa fa-lg fa-question',
                  attrs: {
                    name: 'dialog_help', type: 'button', label: gettext('Restore'),
                    url: url_for('help.static', { 'filename': 'restore_dialog.html' })
                  }
                }, {
                  text: gettext('Restore'), key: 13,
                  className: 'btn btn-primary fa fa-upload pg-alertify-button', restore: true,
                  'data-btn-name': 'restore'
                }, {
                  text: gettext('Cancel'), key: 27,
                  className: 'btn btn-danger fa fa-lg fa-times pg-alertify-button', restore: false,
                  'data-btn-name': 'cancel'
                }],
                // Set options for dialog
                options: {
                  title: title,
                  //disable both padding and overflow control.
                  padding: !1,
                  overflow: !1,
                  model: 0,
                  resizable: true,
                  maximizable: true,
                  pinnable: false,
                  closableByDimmer: false,
                  modal: false
                }
              };
            },
            hooks: {
              // triggered when the dialog is closed
              onclose: function onclose() {
                if (this.view) {
                  this.view.remove({ data: true, internal: true, silent: true });
                }
              }
            },
            settings: {
              pg_node: null,
              pg_item: null,
              pg_item_data: null
            },
            prepare: function prepare() {

              var self = this;
              // Disable Backup button until user provides Filename
              this.__internal.buttons[2].element.disabled = true;
              var $container = $("<div class='restore_dialog'></div>");
              var t = pgBrowser.tree,
                  i = t.selected(),
                  d = i && i.length == 1 ? t.itemData(i) : undefined,
                  node = d && pgBrowser.Nodes[d._type];

              if (!d) return;

              var treeInfo = node.getTreeNodeHierarchy.apply(node, [i]);

              var newModel = new RestoreObjectModel({ node_data: node }, { node_info: treeInfo }),
                  fields = Backform.generateViewSchema(treeInfo, newModel, 'create', node, treeInfo.server, true);

              var view = this.view = new Backform.Dialog({
                el: $container, model: newModel, schema: fields
              });

              $(this.elements.body.childNodes[0]).addClass('alertify_tools_dialog_properties obj_properties');

              view.render();

              this.elements.content.appendChild($container.get(0));

              // Listen to model & if filename is provided then enable Backup button
              this.view.model.on('change', function () {
                if (!_.isUndefined(this.get('file')) && this.get('file') !== '') {
                  this.errorModel.clear();
                  self.__internal.buttons[2].element.disabled = false;
                } else {
                  self.__internal.buttons[2].element.disabled = true;
                  this.errorModel.set('file', gettext('Please provide filename'));
                }
              });
            },
            // Callback functions when click on the buttons of the Alertify dialogs
            callback: function callback(e) {
              // Fetch current server id
              var t = pgBrowser.tree,
                  i = this.settings['pg_item'] || t.selected(),
                  d = this.settings['pg_item_data'] || (i && i.length == 1 ? t.itemData(i) : undefined),
                  node = this.settings['pg_node'] || d && pgBrowser.Nodes[d._type];

              if (e.button.element.name == "dialog_help" || e.button.element.name == "object_help") {
                e.cancel = true;
                pgBrowser.showHelp(e.button.element.name, e.button.element.getAttribute('url'), node, i, e.button.element.getAttribute('label'));
                return;
              }

              if (e.button['data-btn-name'] === "restore") {
                if (!d) return;

                var info = node.getTreeNodeHierarchy.apply(node, [i]),
                    m = this.view.model;
                // Set current node info into model
                m.set('database', info.database._label);
                if (!m.get('custom')) {
                  switch (d._type) {
                    case 'schema':
                      m.set('schemas', [d._label]);
                      break;
                    case 'table':
                      m.set('schemas', [info.schema._label]);
                      m.set('tables', [d._label]);
                      break;
                    case 'function':
                      m.set('schemas', [info.schema._label]);
                      m.set('functions', [d._label]);
                      break;
                    case 'index':
                      m.set('schemas', [info.schema._label]);
                      m.set('indexes', [d._label]);
                      break;
                    case 'trigger':
                      m.set('schemas', [info.schema._label]);
                      m.set('triggers', [d._label]);
                      break;
                    case 'trigger_func':
                      m.set('schemas', [info.schema._label]);
                      m.set('trigger_funcs', [d._label]);
                      break;
                  }
                } else {
                  // TODO::
                  // When we will implement the object selection in the
                  // import dialog, we will need to select the objects from
                  // the tree selection tab.
                }

                var self = this,
                    baseUrl = url_for('restore.create_job', { 'sid': info.server._id }),
                    args = this.view.model.toJSON();

                $.ajax({
                  url: baseUrl,
                  method: 'POST',
                  data: { 'data': JSON.stringify(args) },
                  success: function success(res) {
                    if (res.success) {
                      alertify.success(gettext('Restore job created.'), 5);
                      pgBrowser.Events.trigger('pgadmin-bgprocess:created', self);
                    } else {
                      console.log(res);
                    }
                  },
                  error: function error(xhr, status, _error) {
                    try {
                      var err = $.parseJSON(xhr.responseText);
                      alertify.alert(gettext('Restore failed.'), err.errormsg);
                    } catch (e) {}
                  }
                });
              }
            }
          };
        });
      }

      alertify.pg_restore(title, item, data, node).resizeTo('65%', '60%');
    }
  };
  return pgBrowser.Restore;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(pgAdmin) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

// Grant Wizard
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(8), __webpack_require__(6), __webpack_require__(10), __webpack_require__(13), __webpack_require__(31), __webpack_require__(192), __webpack_require__(159), __webpack_require__(22), __webpack_require__(261)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, alertify, pgBrowser, Backbone, Backgrid, pgNode) {

  // if module is already initialized, refer to that.
  if (pgBrowser.GrantWizard) {
    return pgBrowser.GrantWizard;
  }

  /**
    It is sub model for field "Objects". It has fields
    for database object types such as Schemas, Views and
    Sequence etc.
  */
  var DatabaseObjectModel = pgNode.Model.extend({
    defaults: {
      selected: false,
      icon: 'icon-unknown',
      name: undefined,
      name_with_args: undefined,
      nspname: undefined,
      proargs: undefined,
      object_type: undefined,
      object_id: undefined
    },
    idAttribute: 'object_id', // to uniquely identify a model object
    toJSON: function toJSON(obj) {
      var d = pgNode.Model.prototype.toJSON.apply(this);
      delete d.icon;
      return d;
    },
    parse: function parse(res) {

      // Create unique object id
      res.object_id = res.name_with_args;

      // create name with args if its object is function
      if (!_.isUndefined(res.object_type) && (res.object_type == 'Function' || res.object_type == 'Trigger Function' || res.object_type == 'Procedure')) res.name_with_args = res.name + '(' + (typeof res.proargs != 'undefined' ? res.proargs : '') + ')';else res.name_with_args = res.name;

      return res;
    },

    validate: function validate() {

      /*
      * Triggers error messages for object types "selected"
      * if it is empty/undefined/null
      */
      var err = {},
          errmsg,
          node = this.get('objects').toJSON();
      if (_.isEmpty(node)) {
        err['selected'] = gettext('Please select any database object type.');
        errmsg = errmsg || err['selected'];
        this.errorModel.set('selected', errmsg);
        return errmsg;
      } else {
        this.errorModel.unset('selected');
      }
      return null;
    }
  });

  // Define columns for the Db Object Types grid
  var columns = [{
    name: "selected",

    /*
    Override render method of Backgrid.Extension.SelectRowCell
    class. It has an issue: It doesn't mark rows checked if we move to next
    page and then go back to previous page. but it must show.
    so we handle this case by overriding the render method.
    */
    cell: Backgrid.Extension.SelectRowCell.extend({
      render: function render() {

        // Use the Backform Control's render function
        Backgrid.Extension.SelectRowCell.prototype.render.apply(this, arguments);

        var col = this.column.get('name');
        if (this.model && this.model.has(col)) {
          if (this.model.get(col)) {
            this.$el.parent().toggleClass("selected", true);
            this.model.trigger("backgrid:selected", this.model, true);
          }
        }
        return this;
      }
    }),

    headerCell: "select-all"

  }, {
    name: "object_type",
    label: "Object Type",
    editable: false,
    cell: Backgrid.Cell.extend({
      render: function render() {

        // Override render to add icon to Db Object column
        Backgrid.Cell.prototype.render.apply(this, arguments);
        this.$el.addClass(this.model.get('icon')).css({ "padding-left": "24px" });

        return this;
      }
    })
  }, {
    name: "nspname",
    label: "Schema",
    cell: "string",
    editable: false
  }, {
    name: "name_with_args",
    label: "Name",
    cell: "string",
    editable: false
  }];

  // Create an Object GrantWizard of pgBrowser class
  pgBrowser.GrantWizard = {
    init: function init() {
      if (this.initialized) return;

      this.initialized = true;

      // Define list of nodes on which grant wizard context menu option appears
      var supported_nodes = ['schema', 'coll-function', 'coll-sequence', 'coll-table', 'coll-view', 'coll-procedure', 'coll-mview', 'database', 'coll-trigger_function'],


      /**
        Enable/disable grantwizard menu in tools based
        on node selected
        if selected node is present in supported_nodes,
        menu will be enabled otherwise disabled.
        Also, hide it for system view in catalogs
      */
      menu_enabled = function menu_enabled(itemData, item, data) {
        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        var parent_item = t.hasParent(i) ? t.parent(i) : null,
            parent_data = parent_item ? t.itemData(parent_item) : null;
        if (!_.isUndefined(d) && !_.isNull(d) && !_.isNull(parent_data)) {
          if (_.indexOf(supported_nodes, d._type) !== -1 && parent_data._type != 'catalog') {
            if (d._type == 'database' && d.allowConn) return true;else if (d._type != 'database') return true;else return false;
          } else return false;
        } else return false;
      };

      // Define the nodes on which the menus to be appear
      var menus = [{
        name: 'grant_wizard_schema', module: this,
        applies: ['tools'], callback: 'start_grant_wizard',
        priority: 14, label: gettext('Grant Wizard...'),
        icon: 'fa fa-unlock-alt', enable: menu_enabled
      }];

      // Add supported menus into the menus list
      for (var idx = 0; idx < supported_nodes.length; idx++) {
        menus.push({
          name: 'grant_wizard_schema_context_' + supported_nodes[idx],
          node: supported_nodes[idx], module: this,
          applies: ['context'], callback: 'start_grant_wizard',
          priority: 14, label: gettext('Grant Wizard...'),
          icon: 'fa fa-unlock-alt', enable: menu_enabled
        });
      }
      pgAdmin.Browser.add_menus(menus);

      return this;
    },

    // Callback to draw Wizard Dialog
    start_grant_wizard: function start_grant_wizard(action, item) {

      // Declare Wizard dialog
      if (!alertify.wizardDialog) {
        alertify.dialog('wizardDialog', function factory() {

          // Generate wizard main container
          var $container = $("<div class='wizard_dlg'></div>");

          return {
            main: function main(title) {
              this.set('title', title);
            },
            setup: function setup() {
              return {
                // Set options for dialog
                options: {
                  frameless: true,
                  resizable: true,
                  autoReset: false,
                  maximizable: false,
                  closable: false,
                  closableByDimmer: false,
                  modal: false,
                  pinnable: false
                }
              };
            },
            hooks: {
              onshow: function onshow() {

                // Add pgadmin_grant_wizard_body class to dialog
                $(this.elements.body).addClass('pgadmin_grant_wizard_body');
              }
            },

            /**
              Returns a Paginator Class Object which is again to be rendered
               @class {Backgrid.Extension.Paginator}
              @param {Backbone.Collection} coll - from which data is fetched
              @return {Object} paginator
            */
            DbPaginator: function DbPaginator(coll) {
              var paginator = this.paginator = new Backgrid.Extension.Paginator({
                collection: coll,
                windowSize: 8
              });
              return paginator;
            },

            /**
              Create new Filter which will filter the
              rendered grid for Select Type Tabular Data
              @param {Backbone.PageableCollection} coll
            */
            DbObjectFilter: function DbObjectFilter(coll) {
              var clientSideFilter = this.clientSideFilter = new Backgrid.Extension.ClientSideFilter({
                collection: coll,
                placeholder: _('Search by object type or name'),

                // The model fields to search for matches
                fields: ['object_type', 'name'],

                // How long to wait after typing has stopped before searching can start
                wait: 150
              });
              return clientSideFilter;
            },

            //Enable Disable Next button of PrivilegePage
            updateButtons: function updateButtons(modified) {
              if (!modified) $('.wizard-next').prop('disabled', true);else $('.wizard-next').prop('disabled', false);
            },

            /**
              Callback called when an errorModel is set
              with invalid value and errormsg is set into
              status bar element and next button is disabled
            */
            onSessionInvalid: function onSessionInvalid(msg) {
              $('.error_msg_div p').html(msg).removeClass("hide");

              // Enable disable Next button
              this.updateButtons(false);
              return true;
            },

            /**
              Callback called when anything is set into model
              thus hide error msg element and enable next button
              status bar element and next button is disabled
            */
            onSessionValidated: function onSessionValidated(sessHasChanged) {
              $('.error_msg_div p').empty().addClass("hide");

              // Enable disable Next button
              this.updateButtons(sessHasChanged);
            },

            /**
              Remove/Delete objects, attributes
              in wizard on wizard close or finish
              to reclaim memory
            */
            releaseObjects: function releaseObjects() {
              var self = this;

              if (!_.isUndefined(self.dbObjectFilter)) {
                self.dbObjectFilter.remove();
                self.dbObjectFilter = undefined;
              }

              if (!_.isUndefined(self.clientSideFilter)) {
                self.clientSideFilter.remove();
                self.clientSideFilter = undefined;
              }

              // clear object priv array
              if (!_.isNull(self.obj_priv) && !_.isUndefined(self.obj_priv)) {
                self.obj_priv = [];
                delete self.obj_priv;
              }

              // Delete Wizard Pages, clear model and cleanup view
              if (!_.isUndefined(self.dbObjectTypePage) && !_.isNull(self.dbObjectTypePage)) {
                if (!_.isUndefined(self.dbObjectTypePage.get('model')) && !_.isNull(self.dbObjectTypePage.get('model'))) {
                  self.dbObjectTypePage.get('model').clear();
                  self.dbObjectTypePage.get('view').cleanup();
                  self.dbObjectTypePage = undefined;
                }
              }

              if (!_.isUndefined(self.privilegePage) && !_.isNull(self.privilegePage)) {
                if (!_.isUndefined(self.privilegePage.get('model')) && !_.isNull(self.privilegePage.get('model'))) {
                  self.privilegePage.get('model').clear();
                  self.privilegePage.get('view').cleanup();
                  self.privilegePage = undefined;
                }
              }

              if (!_.isUndefined(self.reviewSQLPage) && !_.isNull(self.reviewSQLPage)) {
                if (!_.isUndefined(self.reviewSQLPage.get('model')) && !_.isNull(self.reviewSQLPage.get('model'))) {
                  self.reviewSQLPage.get('model').clear();
                  self.reviewSQLPage = undefined;
                }
              }

              // Remove Sql control
              if (!_.isUndefined(self.sqlControl)) {
                self.sqlControl.remove();
              }

              // Clear privModel
              if (!_.isNull(self.privModel) && !_.isUndefined(self.privModel)) {
                self.privModel.clear();
              }

              // Remove collection containing db object data
              if (!_.isNull(self.coll) && !_.isUndefined(self.coll)) {
                self.coll.reset();
                self.coll = undefined;
              }
              // Delete Wizard
              if (!_.isNull(self.wizard) && !_.isUndefined(self.wizard)) {
                self.wizard.collection.reset();
                self.wizard.curr_page = undefined;
              }
            },

            /**
              Every time a wizard is opened, this function
              is called everytime. It has Wizard Pages which
              are rendered by the Wizard Class:
               @class {pgBrowser.WizardPage} dbObjectType1 - This page
              @extends {Backbone.Model}
              renders a grid of Database Object Types such as
                Schemas, Views and Sequences etc.
               @class {pgBrowser.WizardPage} WizardPage2 - This page
              @extends {Backbone.Model}
              adds Privilege Control which provides grant privileges
              such as "Create, Insert, Delete, Update" so on the
              database objects selected on Wizard Pages.
               @class {pgBrowser.WizardPage} WizardPage3 - This page
              displays the generated GRANT SQL query for the Db
              objects selected with the specific privileges added to it.
              @extends {Backbone.Model}
               @class {Backbone.Collection} WizardCollection - It is the
              collection of wizard pages
               @class {pgBrowser.Wizard} wizard - Its task is:
              - Create a Wizard
              - Add Buttons, Callbacks to it.
              - Render WizardPages
              @extends {Backbone.View}
             */
            build: function build() {
              this.elements.content.appendChild($container.get(0));
              alertify.pgDialogBuild.apply(this);
            },

            //Returns list of Acls defined for nodes
            get_json_data: function get_json_data(gid, sid, did) {
              return $.ajax({
                async: false,
                url: url_for('grant_wizard.acl', { 'sid': encodeURI(sid), 'did': encodeURI(did) }),
                dataType: 'jsonp'
              });
            },
            prepare: function prepare() {
              var that = this;
              $container.empty().append("<div class='grant_wizard_container'></div>");

              // Define el for wizard view
              var el = $('.grant_wizard_container');

              // Extract the data from the selected tree node
              var t = pgBrowser.tree,
                  i = t.selected(),
                  d = this.d = i && i.length == 1 ? t.itemData(i) : undefined,
                  info = this.info = pgBrowser.Node.getTreeNodeHierarchy(i),
                  icon = d.icon;

              /**
                Generate a URL using:
                gid, did, sid(server id), node_id(node id),
                node_(node name), node_type(node type)
                and pass it to collection which will fetch Object Type properties.
              */
              var gid = info['server_group']._id,
                  sid = info.server._id,
                  did = info.database._id,
                  node_id = d._id,


              /**
                get node name only. used in mapping with object types defined
                in allowed_acl.json
               */
              node_type = d._type.replace('coll-', '').replace('materialized_', ''),
                  node_label = d.label;

              // Fetch privileges specific to nodes
              var json_data = this.get_json_data(gid, sid, did);
              var privDict = JSON.parse(json_data.responseText);

              // Collection url to fetch database object types for objects field
              var baseUrl = url_for('grant_wizard.objects', {
                'sid': encodeURI(sid), 'did': encodeURI(did),
                'node_id': encodeURI(node_id),
                'node_type': encodeURI(node_type)
              }),

              // Model's save url
              saveUrl = url_for('grant_wizard.apply', {
                'sid': encodeURI(sid), 'did': encodeURI(did)
              }),

              // generate encoded url based on wizard type
              msql_url = this.msql_url = url_for('grant_wizard.modified_sql', {
                'sid': encodeURI(sid), 'did': encodeURI(did)
              }),
                  Coll = Backbone.Collection.extend({
                model: DatabaseObjectModel,
                url: baseUrl
              }),


              // Create instances of collection and filter
              coll = this.coll = new Coll(),
                  self = this;

              coll.comparator = function (model) {
                return model.get('object_type');
              };

              coll.sort();
              var dbObjectFilter = this.dbObjectFilter = this.DbObjectFilter(coll);

              /**
                privArray holds objects selected which further helps
                in creating privileges Model
              */
              self.privArray = [];

              /**
                Override backgrid listener "backgrid:selected" to
                Add/Remove model to/from objects collection
              */
              coll.on('backgrid:selected', function (model, selected) {
                model.set('selected', selected);

                var object_type = model.get('object_type');
                switch (object_type) {
                  case 'Function':
                    object_type = 'function';
                    break;
                  case 'Trigger Function':
                    object_type = 'function';
                    break;
                  case 'Procedure':
                    object_type = 'procedure';
                    break;
                  case 'Table':
                    object_type = 'table';
                    break;
                  case 'Sequence':
                    object_type = 'sequence';
                    break;
                  case 'View':
                    object_type = 'table';
                    break;
                  case 'Materialized View':
                    object_type = 'table';
                    break;
                  default:
                    break;
                }

                /**
                  if a row (checkbox) is checked, add that model
                  into collection, when unchecked remove it from
                  model.
                   Also push/pop object type in/from privArray
                */
                if (selected) {
                  if (_.indexOf(self.privArray, object_type) == -1) self.privArray.push(object_type);
                  newModel.get('objects').add(model, { silent: true });
                } else {
                  var idx = self.privArray.indexOf(object_type);
                  if (idx != -1) self.privArray.splice(idx, 1);
                  newModel.get('objects').remove(model);
                }

                // validate model on checkbox check/uncheck
                var msg = model.validate.call(newModel);

                /**
                  If no object type is selected, set error msg
                  and disable next button, else enable next button
                */
                if (msg) self.onSessionInvalid.call(self, msg);else self.onSessionValidated.call(self, true);
              });

              /**
                It is the main model with schema defined
                Every time a new wizard is opened,
                a new model should create.
              */
              var GrantWizardModel = pgNode.Model.extend({
                defaults: {
                  objects: undefined,
                  acl: undefined
                },
                schema: [{
                  id: 'objects', label: gettext('Objects'), model: DatabaseObjectModel,
                  type: 'collection', group: gettext('Objects')
                }, {
                  id: 'acl', label: gettext('Privileges'),
                  model: pgAdmin.Browser.Node.PrivilegeRoleModel,
                  type: 'collection', canAdd: true,
                  canDelete: true, control: 'unique-col-collection'
                }],
                urlRoot: saveUrl
              });

              /**
                Create instance of GrantWizard Model, provide urlRoot
                node_info object, Generate fields objects
              */
              var newModel = new GrantWizardModel({}, { node_info: info });

              /**
                Fetch data from server and set into grid
                and show/hide progress bar
              */
              $('.wizard-progress-bar p').show();

              coll.fetch({
                success: function success(collection, data) {
                  $('.wizard-progress-bar p').html('');
                  $('.wizard-progress-bar').hide();
                },
                reset: true
              }, this);

              //////////////////////////////////////////////////////////////////////
              //                                                                  //
              //            Wizard Page for Db Object Type                        //
              //                                                                  //
              //////////////////////////////////////////////////////////////////////

              /**
                Create wizard page. It renders a grid of
                Database Object Types such as
                Schemas, Views and Sequences etc.
                Set default values
              */
              var dbObjectTypePage = self.dbObjectTypePage = new pgBrowser.WizardPage({
                id: 1,
                page_title: _('Object Selection (step 1 of 3)'),
                disable_prev: true,
                disable_next: true,
                show_description: _('Please select objects from the list below.'),
                show_progress_bar: _('Please wait while fetching records...'),
                model: newModel,
                view: new function () {

                  // Set page Instance
                  var pageView = this;

                  _.extend(pageView, {

                    // Remove grid if it is before render
                    cleanup: function cleanup() {
                      if (this.grid) {
                        this.grid.remove();
                        delete this.grid;
                        this.grid = null;
                      }

                      // Remove grid element if exists
                      if (this.el) {
                        $(this.el).remove();
                        delete this.el;
                      }
                    },

                    // Delete grid before render
                    grid: null,

                    render: function render() {

                      // Create a grid container
                      var gridBody = $('<div class="db_objects_container pg-el-xs-12"></div>');

                      // Remove grid if exits before render
                      if (this.grid) {
                        this.cleanup();
                      }

                      // Initialize a new Grid instance
                      this.grid = new Backgrid.Grid({
                        columns: _.clone(columns),
                        collection: coll,
                        className: "backgrid table-bordered object_type_table pg-el-xs-12"
                      });

                      // Render selection Type grid and paginator
                      gridBody.append(this.grid.render().$el);

                      // Render Search Filter
                      gridBody.prepend(self.clientSideFilter.render().el);

                      // Assign gridBody content to page element
                      this.el = gridBody;

                      /**
                        Fetch selected models from collection and
                        make rows checked in grid
                      */
                      newModel.get('objects').each(function (m) {
                        var model = coll.get(m.get('object_id'));
                        if (model) {
                          coll.trigger('backgrid:selected', model, true);
                        }
                      });

                      // Refresh grid to re render rows.
                      coll.trigger('backgrid:refresh');

                      return this;
                    }
                  });
                }(),

                beforeNext: function beforeNext(obj) {
                  var self = this;
                  obj.options.disable_next = true;

                  /**
                    Enable/Disable next button of privilegePage if objects
                    are present in model
                  */
                  if (!_.isNull(newModel.get('acl')) && !_.isUndefined(newModel.get('acl'))) {
                    if (newModel.get('acl').length > 0) obj.collection.at(1).set('disable_next', false);
                  }

                  // Clean the view
                  if (self.view) {
                    self.view.cleanup();
                    delete self.view;
                    self.view = null;
                  }
                  return true;
                }

              });

              //////////////////////////////////////////////////////////////////////
              //                                                                  //
              //            Wizard Page for Privilege Control                     //
              //                                                                  //
              //////////////////////////////////////////////////////////////////////

              // Wizard for Privelege control
              var privilegePage = self.privilegePage = new pgBrowser.WizardPage({
                id: 2,
                page_title: _('Privileges Selection (step 2 of 3)'),
                show_description: _('Please select privileges for the selected objects.'),
                disable_next: true,
                model: newModel,

                // Create a view function object
                view: new function () {
                  var pageView = this;
                  _.extend(pageView, {

                    // Render Privelege control to generate its html markup
                    render: function render() {

                      var obj_priv = [];
                      self.privArray = _.uniq(self.privArray);
                      _.each(self.privArray, function (priv) {
                        self.obj_priv = obj_priv = _.union(obj_priv, privDict[priv].acl);
                      });

                      /**
                        Define PrivModel and its instance.
                        Privileges array is generated based on
                        the type of nodes selected.
                       */
                      var privModel = self.privModel;
                      var PrivModel = pgNode.Model.extend({
                        defaults: {
                          acl: undefined
                        },
                        schema: [{
                          id: 'acl', label: gettext('Privileges'),
                          model: pgAdmin.Browser.Node.PrivilegeRoleModel.extend({

                            // privileges are selected based on node clicked
                            privileges: obj_priv
                          }), uniqueCol: ['grantee', 'grantor'], editable: true,
                          type: 'collection', canAdd: true,
                          canDelete: true, control: 'unique-col-collection'
                        }]
                      });

                      /**
                        When privelege control is re-rendered, in order to
                        render privileges based on object type selected,
                        delete privileges from privModel which are now not
                        present in object privileges array(object_priv)
                       */
                      var data = {};
                      if (privModel) {
                        data = privModel.toJSON();
                        var rolePrivs = data['acl'];
                        if (!_.isUndefined(rolePrivs) && rolePrivs.length > 0) {
                          for (var idx in rolePrivs) {
                            var rolePriv = rolePrivs[idx]['privileges'],
                                removeIdx = [],
                                j;

                            for (j in rolePriv) {
                              var p = rolePriv[j];
                              if (_.indexOf(obj_priv, p['privilege_type']) == -1) {
                                removeIdx.push(j);
                              }
                            }

                            for (j in removeIdx) {
                              rolePriv.splice(j, 1);
                            }
                          }
                        } else {
                          console.log('Acls are not defined');
                        }
                      }

                      // Instantiate privModel
                      privModel = self.privModel = new PrivModel(data, { node_info: self.info });

                      /*
                      To track changes into model, start new session
                      and Add event listener for privileges control
                      */
                      self.privModel.startNewSession();
                      self.privModel.on('pgadmin-session:valid', self.onSessionValidated.bind(self));
                      self.privModel.on('pgadmin-session:invalid', self.onSessionInvalid.bind(self));

                      /**
                        Create Field Object which has properties like
                        node_data, node_info which is required for rendering
                        Privilege control
                        */
                      var fields = Backform.generateViewSchema(self.info, self.privModel, 'create', self.d._type, self.d);
                      var privilegesField = new Backform.Field(fields[0].fields[0]);

                      this.privControl = new (privilegesField.get('control'))({
                        field: privilegesField,
                        model: self.privModel
                      });

                      return { el: this.privControl.render().$el };
                    },

                    // Remove the privilege control
                    cleanup: function cleanup() {
                      if (this.privControl) {
                        this.privControl.remove();
                        delete this.privControl;
                        this.privControl = null;
                      }
                    }
                  });
                }(),

                beforePrev: function beforePrev(wizardObj) {

                  // Remove the privilege control
                  if (this.view) {
                    this.view.cleanup();
                    delete this.view;
                    this.view = null;
                  }

                  /**
                    Enable/Disable next button of DbObjectType page if objects
                    are present in model
                   */
                  var objectsModel = newModel.get('objects');

                  if (!_.isUndefined(objectsModel) && !_.isEmpty(objectsModel) && objectsModel.length > 0) {
                    wizardObj.collection.at(0).set('disable_next', false);

                    // Don't show progress bar
                    wizardObj.collection.at(0).set('show_progress_bar', '');
                  }

                  /**
                    We're re-rendering the controls as they are deleted
                    before heading to next page
                    Refresh Backgrid to re-render the elements selected
                    re-render Filter
                  */
                  newModel.trigger("backgrid:refresh", newModel, false);
                  self.clientSideFilter.render();
                  return true;
                },

                beforeNext: function beforeNext() {
                  return true;
                },

                onNext: function onNext(obj) {

                  // Assign acls of privModel to main model newModel
                  if (!_.isUndefined(self.privModel)) {
                    newModel.set({ 'acl': self.privModel.get('acl') });
                  }

                  // Remove the privilege control
                  if (this.view) {
                    this.view.cleanup();
                    delete this.view;
                    this.view = null;
                  }

                  // Enable finish button
                  self.wizard.options.disable_finish = false;

                  /**
                    triggers to get SQL queries data to render
                    into the reviewSQLPage
                  */
                  newModel.trigger('pgadmin-wizard:nextpage:sql', { 'node_type': node_type });
                }
              });

              //////////////////////////////////////////////////////////////////////
              //                                                                  //
              //            Review SQL Query Page                                 //
              //                                                                  //
              //////////////////////////////////////////////////////////////////////

              //Create SqlField Object
              var sqlField = new Backform.Field({
                id: 'sqltab',
                label: _('Sql Tab'),

                /**
                  Extend 'SqlTabControl' to define new
                  function 'onWizardNextPageChange'
                  which gets triggered on next button
                  click to fetch generated SQL query
                  for the selected db objects.
                */
                control: Backform.SqlTabControl.extend({
                  initialize: function initialize() {

                    // Initialize parent class
                    Backform.SqlTabControl.prototype.initialize.apply(this, arguments);

                    this.msql_url = self.msql_url;

                    // define trigger events for prev and next page
                    this.model.on('pgadmin-wizard:nextpage:sql', this.onWizardNextPageChange, this);
                    this.model.on('pgadmin-wizard:prevpage:sql', this.onWizardPrevPageChange, this);
                  },

                  // This method fetches the modified SQL for the wizard
                  onWizardNextPageChange: function onWizardNextPageChange() {

                    var self = this;

                    // Fetches modified SQL
                    $.ajax({
                      url: this.msql_url,
                      type: 'GET',
                      cache: false,
                      data: self.model.toJSON(true, 'GET'),
                      dataType: "json",
                      contentType: "application/json"
                    }).done(function (res) {
                      self.sqlCtrl.clearHistory();
                      self.sqlCtrl.setValue(res.data);
                      self.sqlCtrl.refresh();
                    }).fail(function () {
                      self.model.trigger('pgadmin-view:msql:error');
                    }).always(function () {
                      self.model.trigger('pgadmin-view:msql:fetched');
                    });
                  },

                  remove: function remove() {

                    // Clear html dom elements of CodeMirror sql tab
                    self.sqlControl.unbind(); // Unbind all local event bindings
                    var cmElem = self.sqlControl.sqlCtrl.getWrapperElement();
                    $(cmElem).remove();
                    self.sqlControl.sqlCtrl = undefined;
                  }

                })
              }),


              /**
                Create sqlField view instance
                to render it into wizard page
              */
              sqlControl = self.sqlControl = new (sqlField.get('control'))({
                field: sqlField,
                model: newModel
              });

              // Wizard for SQL tab control
              var reviewSQLPage = self.reviewSQLPage = new pgBrowser.WizardPage({
                id: 3,
                page_title: _('Final (Review Selection) (step 3 of 3)'),
                show_description: _('The SQL below will be executed on the ' + 'database server to grant the selected privileges. ' + 'Please click on <b>Finish</b> to complete the process. '),
                model: newModel,
                view: new function () {

                  // Render SqlTab control to generate its html markup
                  var sqlCtrlHtml = sqlControl.render().$el;
                  this.render = function () {
                    return { el: sqlCtrlHtml };
                  };
                }(),

                beforePrev: function beforePrev(wizardObj) {

                  /**
                    Enable next button if privilege
                    model is not empty else disable
                    next button
                   */
                  var aclModel = newModel.get('acl');

                  if (!_.isUndefined(wizardObj.collection) && wizardObj.collection.models.length > 0) {
                    if (!_.isUndefined(aclModel) && !_.isEmpty(aclModel) && aclModel.length > 0) {
                      wizardObj.collection.at(1).set('disable_next', false);
                    } else {
                      wizardObj.collection.at(1).set('disable_next', true);
                    }

                    return true;
                  }
                }
              });

              // Create Wizard Collection of Wizard Pages
              var WizardCollection = Backbone.Collection.extend({
                model: pgBrowser.WizardPage
              });

              // It holds all the wizard pages to be rendered
              this.wizardCollection = new WizardCollection([dbObjectTypePage, privilegePage, reviewSQLPage]);

              /**
                Create wizard which has following operations:
                - renders wizard pages
                - defines the first page to render in wizard
                - Save the model on finishbutton
                - Remove wizard on cancel button
                */
              self.wizard = new (pgBrowser.Wizard.extend({
                options: {
                  title: _('Grant Wizard'), /* Main Wizard Title */
                  width: '',
                  height: '',
                  curr_page: 0,
                  show_left_panel: false,
                  show_header_cancel_btn: true,
                  show_header_maximize_btn: true,
                  disable_finish: true,
                  dialog_api: that,
                  wizard_help: url_for('help.static', { 'filename': 'grant_wizard.html' })
                },

                // Callback for finish button
                onFinish: function onFinish() {
                  var m = newModel,
                      d = m.toJSON('GET');

                  // Save model
                  if (d && !_.isEmpty(d) && !_.isUndefined(d.objects)) {
                    m.save({}, {
                      attrs: d,
                      validate: false,
                      cache: false,
                      success: function success(res) {

                        // Release wizard objects
                        self.releaseObjects();
                        self.close();
                      },
                      error: function error(m, jqxhr) {
                        alertify.pgNotifier("error", jqxhr, S(gettext("Error saving properties: %s")).sprintf(jqxhr.statusText).value());

                        // Release wizard objects
                        self.releaseObjects();
                        self.close();
                      }
                    });
                  }
                },

                // Callback for cancel button
                onCancel: function onCancel() {

                  // Release wizard objects
                  self.releaseObjects();
                  self.close();
                }
              }))({
                collection: this.wizardCollection,
                el: el,
                model: newModel
              });

              // Render wizard
              self.wizard.render();
            }
          };
        });
      }

      // Call Grant Wizard Dialog and set dimensions for wizard
      alertify.wizardDialog(true).resizeTo('55%', '75%');
    }
  };

  return pgBrowser.GrantWizard;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 261 */,
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(17), __webpack_require__(3), __webpack_require__(6), __webpack_require__(10), __webpack_require__(13), __webpack_require__(16), __webpack_require__(24), __webpack_require__(28), __webpack_require__(54)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, Alertify, pgAdmin, pgBrowser, Backbone, Backgrid, Backform) {

  pgAdmin = pgAdmin || window.pgAdmin || {};

  var pgTools = pgAdmin.Tools = pgAdmin.Tools || {};

  // Return back, this has been called more than once
  if (pgAdmin.Tools.maintenance) return pgAdmin.Tools.maintenance;

  var CustomSwitchControl = Backform.CustomSwitchControl = Backform.SwitchControl.extend({
    template: _.template(['<label class="<%=Backform.controlLabelClassName%> custom_switch_label_class"><%=label%></label>', '<div class="<%=Backform.controlsClassName%> custom_switch_control_class">', '  <div class="checkbox">', '    <label>', '      <input type="checkbox" class="<%=extraClasses.join(\' \')%>" name="<%=name%>" <%=value ? "checked=\'checked\'" : ""%> <%=disabled ? "disabled" : ""%> <%=required ? "required" : ""%> />', '    </label>', '  </div>', '</div>', '<% if (helpMessage && helpMessage.length) { %>', '  <span class="<%=Backform.helpMessageClassName%>"><%=helpMessage%></span>', '<% } %>'].join("\n")),
    className: 'pgadmin-control-group form-group col-xs-6'
  });

  // Main model for Maintenance functionality
  var MaintenanceModel = Backbone.Model.extend({
    defaults: {
      op: 'VACUUM',
      vacuum_full: false,
      vacuum_freeze: false,
      vacuum_analyze: false,
      verbose: true
    },
    initialize: function initialize() {
      var node_info = arguments[1]['node_info'];
      // If node is Unique or Primary key then set op to reindex
      if ('primary_key' in node_info || 'unique_constraint' in node_info || 'index' in node_info) {
        this.set('op', 'REINDEX');
        this.set('verbose', false);
      }
    },
    schema: [{
      id: 'op', label: gettext('Maintenance operation'), cell: 'string',
      type: 'text', group: gettext('Options'),
      options: [{ 'label': "VACUUM", 'value': "VACUUM" }, { 'label': "ANALYZE", 'value': "ANALYZE" }, { 'label': "REINDEX", 'value': "REINDEX" }, { 'label': "CLUSTER", 'value': "CLUSTER" }],
      control: Backform.RadioControl.extend({
        template: _.template(['<label class="control-label col-sm-4 col-xs-12"><%=label%></label>', '<div class="pgadmin-controls col-xs-12 col-sm-8 btn-group pg-maintenance-op" data-toggle="buttons">', ' <% for (var i=0; i < options.length; i++) { %>', ' <% var option = options[i]; %>', ' <label class="btn btn-primary<% if (i == 0) { %> active<%}%>">', '  <input type="radio" name="op" id="op" autocomplete="off" value=<%-formatter.fromRaw(option.value)%><% if (i == 0) { %> selected<%}%> > <%-option.label%>', ' </label>', ' <% } %>', '</div>'].join("\n"))
      }),
      select2: {
        allowClear: false,
        width: "100%",
        placeholder: gettext('Select from list...')
      }
    }, {
      type: 'nested', control: 'fieldset', label: gettext('Vacuum'), group: gettext('Options'),
      schema: [{
        id: 'vacuum_full', group: gettext('Vacuum'), disabled: 'isDisabled',
        control: Backform.CustomSwitchControl, label: gettext('FULL'), deps: ['op']
      }, {
        id: 'vacuum_freeze', deps: ['op'], disabled: 'isDisabled',
        control: Backform.CustomSwitchControl, label: gettext('FREEZE'), group: gettext('Vacuum')
      }, {
        id: 'vacuum_analyze', deps: ['op'], disabled: 'isDisabled',
        control: Backform.CustomSwitchControl, label: gettext('ANALYZE'), group: gettext('Vacuum')
      }]
    }, {
      id: 'verbose', group: gettext('Options'), deps: ['op'],
      control: Backform.CustomSwitchControl, label: gettext('Verbose Messages'), disabled: 'isDisabled'
    }],

    // Enable/Disable the items based on the user maintenance operation selection
    isDisabled: function isDisabled(m) {
      var name = this.name,
          node_info = this.node_info;
      switch (name) {
        case 'vacuum_full':
        case 'vacuum_freeze':
        case 'vacuum_analyze':
          if (m.get('op') != 'VACUUM') {
            return true;
          } else {
            return false;
          }
          break;
        case 'verbose':
          if ('primary_key' in node_info || 'unique_constraint' in node_info || 'index' in node_info) {
            if (m.get('op') == 'REINDEX') {
              setTimeout(function () {
                m.set('verbose', false);
              }, 10);
              return true;
            }
          }
          if (m.get('op') == 'REINDEX') {
            return true;
          } else {
            return false;
          }
          break;
        default:
          return false;
      }
      return false;
    }
  });

  pgTools.maintenance = {
    init: function init() {

      // We do not want to initialize the module multiple times.
      if (this.initialized) return;

      this.initialized = true;

      var maintenance_supported_nodes = ['database', 'table', 'primary_key', 'unique_constraint', 'index', 'partition'];

      /**
       Enable/disable Maintenance menu in tools based on node selected.
       Maintenance menu will be enabled only when user select table and database node.
      */
      var menu_enabled = function menu_enabled(itemData, item, data) {
        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        var parent_item = t.hasParent(i) ? t.parent(i) : null,
            parent_data = parent_item ? t.itemData(parent_item) : null;
        if (!_.isUndefined(d) && !_.isNull(d) && !_.isNull(parent_data)) {
          if (_.indexOf(maintenance_supported_nodes, d._type) !== -1 && parent_data._type != 'catalog') {
            if (d._type == 'database' && d.allowConn) return true;else if (d._type != 'database') return true;else return false;
          } else return false;
        } else return false;
      };

      var menus = [{
        name: 'maintenance', module: this,
        applies: ['tools'], callback: 'callback_maintenance',
        priority: 10, label: gettext('Maintenance...'),
        icon: 'fa fa-wrench', enable: menu_enabled
      }];

      // Add supported menus into the menus list
      for (var idx = 0; idx < maintenance_supported_nodes.length; idx++) {
        menus.push({
          name: 'maintenance_context_' + maintenance_supported_nodes[idx],
          node: maintenance_supported_nodes[idx], module: this,
          applies: ['context'], callback: 'callback_maintenance',
          priority: 10, label: gettext('Maintenance...'),
          icon: 'fa fa-wrench', enable: menu_enabled
        });
      }
      pgBrowser.add_menus(menus);
    },

    /*
      Open the dialog for the maintenance functionality
    */
    callback_maintenance: function callback_maintenance(args, item) {
      var i = item || pgBrowser.tree.selected(),
          server_data = null;

      while (i) {
        var node_data = pgBrowser.tree.itemData(i);
        if (node_data._type == 'server') {
          server_data = node_data;
          break;
        }

        if (pgBrowser.tree.hasParent(i)) {
          i = $(pgBrowser.tree.parent(i));
        } else {
          Alertify.alert(gettext("Please select server or child node from tree."));
          break;
        }
      }

      if (!server_data) {
        return;
      }

      var module = 'paths',
          preference_name = 'pg_bin_dir',
          msg = gettext('Please configure the PostgreSQL Binary Path in the Preferences dialog.');

      if (server_data.type && server_data.type == 'ppas' || server_data.server_type == 'ppas') {
        preference_name = 'ppas_bin_dir';
        msg = gettext('Please configure the EDB Advanced Server Binary Path in the Preferences dialog.');
      }

      var preference = pgBrowser.get_preference(module, preference_name);

      if (preference) {
        if (!preference.value) {
          Alertify.alert(gettext('Configuration required'), msg);
          return;
        }
      } else {
        Alertify.alert(S(gettext('Failed to load preference %s of module %s')).sprintf(preference_name, module).value());
        return;
      }

      var self = this,
          input = args || {},
          t = pgBrowser.tree,
          i = item || t.selected(),
          d = i && i.length == 1 ? t.itemData(i) : undefined,
          node = d && pgBrowser.Nodes[d._type];

      if (!d) return;

      var objName = d.label;
      var treeInfo = node.getTreeNodeHierarchy.apply(node, [i]);

      if (!Alertify.MaintenanceDialog) {
        Alertify.dialog('MaintenanceDialog', function factory() {

          return {
            main: function main(title) {
              this.set('title', title);
            },
            setup: function setup() {
              return {
                buttons: [{
                  text: '', className: 'btn btn-default pull-left fa fa-lg fa-info',
                  attrs: { name: 'object_help', type: 'button', url: 'maintenance.html', label: gettext('Maintenance') }
                }, {
                  text: '', key: 112,
                  className: 'btn btn-default pull-left fa fa-lg fa-question',
                  attrs: {
                    name: 'dialog_help', type: 'button',
                    label: gettext('Maintenance'),
                    url: url_for('help.static', { 'filename': 'maintenance_dialog.html' })
                  }
                }, {
                  text: gettext("OK"), key: 13, className: "btn btn-primary fa fa-lg fa-save pg-alertify-button",
                  'data-btn-name': 'ok'
                }, {
                  text: gettext("Cancel"), key: 27, className: "btn btn-danger fa fa-lg fa-times pg-alertify-button",
                  'data-btn-name': 'cancel'
                }],
                options: { modal: 0, pinnable: false }
              };
            },
            // Callback functions when click on the buttons of the Alertify dialogs
            callback: function callback(e) {
              var i = pgBrowser.tree.selected(),
                  d = i && i.length == 1 ? pgBrowser.tree.itemData(i) : undefined,
                  node = d && pgBrowser.Nodes[d._type];

              if (e.button.element.name == "dialog_help" || e.button.element.name == "object_help") {
                e.cancel = true;
                pgBrowser.showHelp(e.button.element.name, e.button.element.getAttribute('url'), node, i, e.button.element.getAttribute('label'));
                return;
              }

              if (e.button['data-btn-name'] === "ok") {

                var schema = undefined,
                    table = undefined,
                    primary_key = undefined,
                    unique_constraint = undefined,
                    index = undefined;

                if (!d) return;

                var treeInfo = node.getTreeNodeHierarchy.apply(node, [i]);

                if (treeInfo.schema != undefined) {
                  schema = treeInfo.schema._label;
                }

                if (treeInfo.partition != undefined) {
                  table = treeInfo.partition._label;
                } else if (treeInfo.table != undefined) {
                  table = treeInfo.table._label;
                }

                if (treeInfo.primary_key != undefined) {
                  primary_key = treeInfo.primary_key._label;
                } else if (treeInfo.unique_constraint != undefined) {
                  unique_constraint = treeInfo.unique_constraint._label;
                } else if (treeInfo.index != undefined) {
                  index = treeInfo.index._label;
                }

                this.view.model.set({ 'database': treeInfo.database._label,
                  'schema': schema,
                  'table': table,
                  'primary_key': primary_key,
                  'unique_constraint': unique_constraint,
                  'index': index });

                $.ajax({
                  url: url_for('maintenance.create_job', {
                    'sid': treeInfo.server._id,
                    'did': treeInfo.database._id
                  }),
                  method: 'POST',
                  data: { 'data': JSON.stringify(this.view.model.toJSON()) },
                  success: function success(res) {
                    if (res.data && res.data.status) {
                      //Do nothing as we are creating the job and exiting from the main dialog
                      Alertify.success(res.data.info);
                      pgBrowser.Events.trigger('pgadmin-bgprocess:created', self);
                    } else {
                      Alertify.error(res.data.errmsg);
                    }
                  },
                  error: function error(e) {
                    Alertify.alert(gettext("Maintenance job creation failed."));
                  }
                });
              }
            },
            build: function build() {
              Alertify.pgDialogBuild.apply(this);
            },
            hooks: {
              onclose: function onclose() {
                if (this.view) {
                  this.view.remove({ data: true, internal: true, silent: true });
                }
              }
            },
            prepare: function prepare() {
              // Main maintenance tool dialog container
              var $container = $("<div class='maintenance_dlg'></div>");

              var t = pgBrowser.tree,
                  i = t.selected(),
                  d = i && i.length == 1 ? t.itemData(i) : undefined,
                  node = d && pgBrowser.Nodes[d._type];

              if (!d) return;

              var treeInfo = node.getTreeNodeHierarchy.apply(node, [i]);

              var newModel = new MaintenanceModel({}, { node_info: treeInfo }),
                  fields = Backform.generateViewSchema(treeInfo, newModel, 'create', node, treeInfo.server, true);

              var view = this.view = new Backform.Dialog({
                el: $container, model: newModel, schema: fields
              });

              $(this.elements.body.childNodes[0]).addClass('alertify_tools_dialog_properties obj_properties');
              view.render();

              // If node is Index, Unique or Primary key then disable vacuum & analyze button
              if (d._type == 'primary_key' || d._type == 'unique_constraint' || d._type == 'index') {
                var vacuum_analyze_btns = $container.find('.pgadmin-controls label:lt(2)').removeClass('active').addClass('disabled');
                // Find reindex button element & add active class to it
                var reindex_btn = vacuum_analyze_btns[1].nextElementSibling;
                $(reindex_btn).addClass('active');
              }

              this.elements.content.appendChild($container.get(0));
            }
          };
        });
      }

      // Open the Alertify dialog
      Alertify.MaintenanceDialog('Maintenance...').set('resizable', true).resizeTo('60%', '80%');
    }
  };

  return pgAdmin.Tools.maintenance;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(17), __webpack_require__(3), __webpack_require__(6), __webpack_require__(10), __webpack_require__(13), __webpack_require__(16), __webpack_require__(24), __webpack_require__(28), __webpack_require__(54)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, Alertify, pgAdmin, pgBrowser, Backbone, Backgrid, Backform) {

  pgAdmin = pgAdmin || window.pgAdmin || {};

  var pgTools = pgAdmin.Tools = pgAdmin.Tools || {};

  // Return back, this has been called more than once
  if (pgAdmin.Tools.import_utility) return pgAdmin.Tools.import_utility;

  // Main model for Import/Export functionality
  var ImportExportModel = Backbone.Model.extend({
    defaults: {
      is_import: false, /* false for Export */
      filename: undefined,
      format: 'csv',
      encoding: undefined,
      oid: undefined,
      header: undefined,
      delimiter: '',
      quote: '\"',
      escape: '\'',
      null_string: undefined,
      columns: null,
      icolumns: [],
      database: undefined,
      schema: undefined,
      table: undefined
    },
    schema: [{
      id: 'is_import', label: gettext('Import/Export'), cell: 'switch',
      type: 'switch', group: gettext('Options'),
      options: {
        'onText': gettext('Import'), 'offText': gettext('Export'),
        'onColor': 'success', 'offColor': 'primary'
      }
    }, {
      type: 'nested', control: 'fieldset', label: gettext('File Info'),
      group: gettext('Options'),
      schema: [{ /* select file control for import */
        id: 'filename', label: gettext('Filename'), deps: ['is_import'],
        type: 'text', control: Backform.FileControl, group: gettext('File Info'),
        dialog_type: 'select_file', supp_types: ['csv', 'txt', '*'],
        visible: 'importing'
      }, { /* create file control for export */
        id: 'filename', label: gettext('Filename'), deps: ['is_import'],
        type: 'text', control: Backform.FileControl, group: gettext('File Info'),
        dialog_type: 'create_file', supp_types: ['csv', 'txt', '*'],
        visible: 'exporting'
      }, {
        id: 'format', label: gettext('Format'), cell: 'string',
        control: 'select2', group: gettext('File Info'),
        options: [{ 'label': 'binary', 'value': 'binary' }, { 'label': 'csv', 'value': 'csv' }, { 'label': 'text', 'value': 'text' }],
        disabled: 'isDisabled', select2: { allowClear: false, width: "100%" }
      }, {
        id: 'encoding', label: gettext('Encoding'), cell: 'string',
        control: 'node-ajax-options', node: 'database', url: 'get_encodings', first_empty: true,
        group: gettext('File Info')
      }]
    }, {
      id: 'columns', label: gettext('Columns to import'), cell: 'string',
      deps: ['is_import'], type: 'array', first_empty: false,
      control: Backform.NodeListByNameControl.extend({
        // By default, all the import columns should be selected
        initialize: function initialize() {
          Backform.NodeListByNameControl.prototype.initialize.apply(this, arguments);
          var self = this,
              options = self.field.get('options'),
              op_vals = [];

          if (_.isFunction(options)) {
            try {
              var all_cols = options.apply(self);
              for (var idx in all_cols) {
                op_vals.push(all_cols[idx]['value']);
              }
            } catch (e) {
              // Do nothing
              options = [];
            }
          } else {
            for (idx in options) {
              op_vals.push(options[idx]['value']);
            }
          }

          self.model.set('columns', op_vals);
        }
      }),
      transform: function transform(rows) {
        var self = this,
            node = self.field.get('schema_node'),
            res = [];

        _.each(rows, function (r) {
          var l = _.isFunction(node['node_label']) ? node['node_label'].apply(node, [r, self.model, self]) : r.label,
              image = _.isFunction(node['node_image']) ? node['node_image'].apply(node, [r, self.model, self]) : node['node_image'] || 'icon-' + node.type;
          res.push({
            'value': r.label,
            'image': image,
            'label': l
          });
        });

        return res;
      },
      node: 'column', url: 'nodes', group: gettext('Columns'),
      select2: {
        multiple: true, allowClear: false,
        placeholder: gettext('Columns for importing...'),
        first_empty: false
      }, visible: 'importing',
      helpMessage: gettext('An optional list of columns to be copied. If no column list is specified, all columns of the table will be copied.')
    }, {
      id: 'columns', label: gettext('Columns to export'), cell: 'string',
      deps: ['is_import'], type: 'array',
      control: 'node-list-by-name', first_empty: false,
      node: 'column', url: 'nodes', group: gettext('Columns'),
      select2: {
        multiple: true, allowClear: true,
        placeholder: gettext('Colums for exporting...')
      }, visible: 'exporting',
      transform: function transform(rows) {
        var self = this,
            node = self.field.get('schema_node'),
            res = [];

        _.each(rows, function (r) {
          var l = _.isFunction(node['node_label']) ? node['node_label'].apply(node, [r, self.model, self]) : r.label,
              image = _.isFunction(node['node_image']) ? node['node_image'].apply(node, [r, self.model, self]) : node['node_image'] || 'icon-' + node.type;
          res.push({
            'value': r.label,
            'image': image,
            'label': l
          });
        });

        return res;
      },
      helpMessage: gettext('An optional list of columns to be copied. If no column list is specified, all columns of the table will be copied.')
    }, {
      id: 'null_string', label: gettext('NULL Strings'), cell: 'string',
      type: 'text', group: gettext('Columns'), disabled: 'isDisabled',
      deps: ['format'],
      helpMessage: gettext("Specifies the string that represents a null value. The default is \\N (backslash-N) in text format, and an unquoted empty string in CSV format. You might prefer an empty string even in text format for cases where you don't want to distinguish nulls from empty strings. This option is not allowed when using binary format.")
    }, {
      id: 'icolumns', label: gettext('Not null columns'), cell: 'string',
      control: 'node-list-by-name', node: 'column',
      group: gettext('Columns'), deps: ['format', 'is_import'], disabled: 'isDisabled',
      type: 'array', first_empty: false,
      select2: {
        multiple: true, allowClear: true, first_empty: true,
        placeholder: gettext('Not null columns...')
      },
      helpMessage: gettext('Do not match the specified column values against the null string. In the default case where the null string is empty, this means that empty values will be read as zero-length strings rather than nulls, even when they are not quoted. This option is allowed only in import, and only when using CSV format.')
    }, {
      type: 'nested', control: 'fieldset', label: gettext('Miscellaneous'),
      group: gettext('Options'),
      schema: [{
        id: 'oid', label: gettext('OID'), cell: 'string',
        type: 'switch', group: gettext('Miscellaneous')
      }, {
        id: 'header', label: gettext('Header'), cell: 'string',
        type: 'switch', group: gettext('Miscellaneous'), deps: ['format'], disabled: 'isDisabled'
      }, {
        id: 'delimiter', label: gettext('Delimiter'), cell: 'string', first_empty: true,
        type: 'text', control: 'node-ajax-options', group: gettext('Miscellaneous'), disabled: 'isDisabled',
        deps: ['format'],
        options: [{ 'label': ';', 'value': ';' }, { 'label': ',', 'value': ',' }, { 'label': '|', 'value': '|' }, { 'label': '[tab]', 'value': '[tab]' }],
        select2: {
          tags: true,
          allowClear: false,
          width: "100%",
          placeholder: gettext('Select from list...')
        }, helpMessage: gettext('Specifies the character that separates columns within each row (line) of the file. The default is a tab character in text format, a comma in CSV format. This must be a single one-byte character. This option is not allowed when using binary format.')
      }, {
        id: 'quote', label: gettext('Quote'), cell: 'string', first_empty: true, deps: ['format'],
        type: 'text', control: 'node-ajax-options', group: gettext('Miscellaneous'), disabled: 'isDisabled',
        options: [{ 'label': '\"', 'value': '\"' }, { 'label': '\'', 'value': '\'' }],
        select2: {
          tags: true,
          allowClear: false,
          width: "100%",
          placeholder: gettext('Select from list...')
        }, helpMessage: gettext('Specifies the quoting character to be used when a data value is quoted. The default is double-quote. This must be a single one-byte character. This option is allowed only when using CSV format.')
      }, {
        id: 'escape', label: gettext('Escape'), cell: 'string', first_empty: true, deps: ['format'],
        type: 'text', control: 'node-ajax-options', group: gettext('Miscellaneous'), disabled: 'isDisabled',
        options: [{ 'label': '\"', 'value': '\"' }, { 'label': '\'', 'value': '\'' }],
        select2: {
          tags: true,
          allowClear: false,
          width: "100%",
          placeholder: gettext('Select from list...')
        }, helpMessage: gettext('Specifies the character that should appear before a data character that matches the QUOTE value. The default is the same as the QUOTE value (so that the quoting character is doubled if it appears in the data). This must be a single one-byte character. This option is allowed only when using CSV format.')
      }]
    }],

    // Enable/Disable the items based on the user file format selection
    isDisabled: function isDisabled(m) {
      name = this.name;
      switch (name) {
        case 'quote':
        case 'escape':
        case 'header':
          return m.get('format') != 'csv';
        case 'icolumns':
          return m.get('format') != 'csv' || !m.get('is_import');
        case 'null_string':
        case 'delimiter':
          return m.get('format') == 'binary';
        default:
          return false;
      }
    },
    importing: function importing(m) {
      return m.get('is_import');
    },
    exporting: function exporting(m) {
      return !m.importing.apply(this, arguments);
    }
  });

  pgTools.import_utility = {
    init: function init() {
      // We do not want to initialize the module multiple times.
      if (this.initialized) return;

      this.initialized = true;

      /**
       Enable/disable import menu in tools based on node selected
       Import menu will be enabled only when user select table node.
      */
      var menu_enabled = function menu_enabled(itemData, item, data) {
        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        var parent_item = t.hasParent(i) ? t.parent(i) : null,
            parent_data = parent_item ? t.itemData(parent_item) : null;
        if (!_.isUndefined(d) && !_.isNull(d) && !_.isNull(parent_data)) return _.indexOf(['table'], d._type) !== -1 && parent_data._type != 'catalog' ? true : false;else return false;
      };

      // Initialize the context menu to display the import options when user open the context menu for table
      pgBrowser.add_menus([{
        name: 'import', node: 'table', module: this,
        applies: ['tools', 'context'], callback: 'callback_import_export',
        category: 'import', priority: 10, label: gettext('Import/Export...'),
        icon: 'fa fa-shopping-cart', enable: menu_enabled
      }]);
    },

    /*
      Open the dialog for the import functionality
    */
    callback_import_export: function callback_import_export(args, item) {
      var i = item || pgBrowser.tree.selected(),
          server_data = null;

      while (i) {
        var node_data = pgBrowser.tree.itemData(i);
        if (node_data._type == 'server') {
          server_data = node_data;
          break;
        }

        if (pgBrowser.tree.hasParent(i)) {
          i = $(pgBrowser.tree.parent(i));
        } else {
          Alertify.alert(gettext("Please select server or child node from tree."));
          break;
        }
      }

      if (!server_data) {
        return;
      }

      var module = 'paths',
          preference_name = 'pg_bin_dir',
          msg = gettext('Please configure the PostgreSQL Binary Path in the Preferences dialog.');

      if (server_data.type && server_data.type == 'ppas' || server_data.server_type == 'ppas') {
        preference_name = 'ppas_bin_dir';
        msg = gettext('Please configure the EDB Advanced Server Binary Path in the Preferences dialog.');
      }

      var preference = pgBrowser.get_preference(module, preference_name);

      if (preference) {
        if (!preference.value) {
          Alertify.alert(gettext('Configuration required'), msg);
          return;
        }
      } else {
        Alertify.alert(S(gettext('Failed to load preference %s of module %s')).sprintf(preference_name, module).value());
        return;
      }

      var self = this;
      var input = args || {},
          t = pgBrowser.tree,
          i = item || t.selected(),
          d = i && i.length == 1 ? t.itemData(i) : undefined,
          node = d && pgBrowser.Nodes[d._type];

      if (!d) return;

      var objName = d.label;
      var treeInfo = node.getTreeNodeHierarchy.apply(node, [i]);

      if (!Alertify.ImportDialog) {
        Alertify.dialog('ImportDialog', function factory() {

          return {
            main: function main(title, node, item, data) {
              this.set('title', title);
              this.setting('pg_node', node);
              this.setting('pg_item', item);
              this.setting('pg_item_data', data);
            },

            build: function build() {
              Alertify.pgDialogBuild.apply(this);
            },

            setup: function setup() {
              return {
                buttons: [{
                  text: gettext("OK"), key: 13, disable: true,
                  'data-btn-name': 'ok',
                  className: "btn btn-primary fa fa-lg fa-save pg-alertify-button"
                }, {
                  text: gettext("Cancel"), key: 27,
                  'data-btn-name': 'cancel',
                  className: "btn btn-danger fa fa-lg fa-times pg-alertify-button"
                }],
                options: { modal: true }
              };
            },

            settings: {
              pg_node: null,
              pg_item: null,
              pg_item_data: null
            },

            // Callback functions when click on the buttons of the Alertify dialogs
            callback: function callback(e) {
              if (e.button['data-btn-name'] === "ok") {

                var n = this.settings['pg_node'],
                    i = this.settings['pg_item'],
                    treeInfo = n.getTreeNodeHierarchy.apply(n, [i]);

                this.view.model.set({
                  'database': treeInfo.database._label,
                  'schema': treeInfo.schema._label,
                  'table': treeInfo.table._label
                });
                var self = this;

                $.ajax({
                  url: url_for('import_export.create_job', { 'sid': treeInfo.server._id }),
                  method: 'POST',
                  data: { 'data': JSON.stringify(this.view.model.toJSON()) },
                  success: function success(res) {
                    if (res.success) {
                      Alertify.success(gettext('Import/export job created.'), 5);
                      pgBrowser.Events.trigger('pgadmin-bgprocess:created', self);
                    }
                  },
                  error: function error(xhr, status, _error) {
                    try {
                      var err = $.parseJSON(xhr.responseText);
                      Alertify.alert(gettext('Import/export job failed.'), err.errormsg);
                    } catch (e) {}
                  }
                });
              }
            },

            hooks: {
              onclose: function onclose() {
                if (this.view) {
                  this.view.remove({ data: true, internal: true, silent: true });
                }
              },

              // triggered when a dialog option gets update.
              onupdate: function onupdate(option, oldValue, newValue) {

                switch (option) {
                  case 'resizable':
                    if (newValue) {
                      this.elements.content.removeAttribute('style');
                    } else {
                      this.elements.content.style.minHeight = 'inherit';
                    }
                    break;
                }
              }
            },

            prepare: function prepare() {
              // Main import module container
              var self = this;

              // Disable OK button until user provides valid Filename
              this.__internal.buttons[0].element.disabled = true;

              var $container = $("<div class='import_dlg'></div>"),
                  n = this.settings.pg_node,
                  i = this.settings.pg_item,
                  treeInfo = n.getTreeNodeHierarchy.apply(n, [i]),
                  newModel = new ImportExportModel({}, {
                node_info: treeInfo
              }),
                  fields = Backform.generateViewSchema(treeInfo, newModel, 'create', node, treeInfo.server, true),
                  view = this.view = new Backform.Dialog({
                el: $container, model: newModel, schema: fields
              });

              $(this.elements.body.childNodes[0]).addClass('alertify_tools_dialog_properties obj_properties');
              view.render();

              this.elements.content.appendChild($container.get(0));

              // Listen to model & if filename is provided then enable OK button
              // For the 'Quote', 'escape' and 'delimiter' only one character is allowed to enter
              this.view.model.on('change', function () {
                if (!_.isUndefined(this.get('filename')) && this.get('filename') !== '') {
                  this.errorModel.clear();
                  if (!_.isUndefined(this.get('delimiter')) && !_.isNull(this.get('delimiter'))) {
                    this.errorModel.clear();
                    if (!_.isUndefined(this.get('quote')) && this.get('quote') !== '' && this.get('quote').length == 1) {
                      this.errorModel.clear();
                      if (!_.isUndefined(this.get('escape')) && this.get('escape') !== '' && this.get('escape').length == 1) {
                        this.errorModel.clear();
                        self.__internal.buttons[0].element.disabled = false;
                      } else {
                        self.__internal.buttons[0].element.disabled = true;
                        this.errorModel.set('escape', gettext('Escape should contain only one character'));
                      }
                    } else {
                      self.__internal.buttons[0].element.disabled = true;
                      this.errorModel.set('quote', gettext('Quote should contain only one character'));
                    }
                  } else {
                    self.__internal.buttons[0].element.disabled = true;
                    this.errorModel.set('delimiter', gettext('Delimiter should contain only one character'));
                  }
                } else {
                  self.__internal.buttons[0].element.disabled = true;
                  this.errorModel.set('filename', gettext('Please provide filename'));
                }
              });

              // Give the dialog initial height & width
              this.elements.dialog.style.minHeight = '80%';
              this.elements.dialog.style.minWidth = '70%';
            }
          };
        });
      }

      // Open the Alertify dialog for the import/export module
      Alertify.ImportDialog(S(gettext("Import/Export data - table '%s'")).sprintf(treeInfo.table.label).value(), node, i, d).set('resizable', true).resizeTo('70%', '80%');
    }
  };

  return pgAdmin.Tools.import_utility;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(8), __webpack_require__(3), __webpack_require__(6), __webpack_require__(10), __webpack_require__(13), __webpack_require__(14), __webpack_require__(16), __webpack_require__(98), __webpack_require__(30), __webpack_require__(24), __webpack_require__(28), __webpack_require__(190)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, Alertify, pgAdmin, pgBrowser, Backbone, Backgrid, CodeMirror, Backform, get_function_arguments) {

  pgAdmin = pgAdmin || window.pgAdmin || {};

  var pgTools = pgAdmin.Tools = pgAdmin.Tools || {};

  /* Return back, this has been called more than once */
  if (pgAdmin.Tools.Debugger) return pgAdmin.Tools.Debugger;

  pgTools.Debugger = {
    init: function init() {
      // We do not want to initialize the module multiple times.
      if (this.initialized) return;

      this.initialized = true;

      // Initialize the context menu to display the debugging options when user open the context menu for functions
      pgBrowser.add_menus([{
        name: 'direct_debugger', node: 'function', module: this,
        applies: ['object', 'context'], callback: 'get_function_information',
        category: gettext('Debugging'), priority: 10, label: gettext('Debug'),
        data: { object: 'function' }, icon: 'fa fa-arrow-circle-right',
        enable: 'can_debug'
      }, {
        name: 'global_debugger', node: 'function', module: this,
        applies: ['object', 'context'], callback: 'check_func_debuggable',
        category: gettext('Debugging'), priority: 10, label: gettext('Set breakpoint'),
        data: { object: 'function', debug_type: 'indirect' },
        icon: 'fa fa-arrow-circle-right', enable: 'can_debug'
      }, {
        name: 'procedure_direct_debugger', node: 'procedure', module: this,
        applies: ['object', 'context'], callback: 'get_function_information',
        category: gettext('Debugging'), priority: 10, label: gettext('Debug'),
        data: { object: 'procedure' }, icon: 'fa fa-arrow-circle-right',
        enable: 'can_debug'
      }, {
        name: 'procedure_indirect_debugger', node: 'procedure', module: this,
        applies: ['object', 'context'], callback: 'check_func_debuggable',
        category: gettext('Debugging'), priority: 10, label: gettext('Set breakpoint'),
        data: { object: 'procedure', debug_type: 'indirect' },
        icon: 'fa fa-arrow-circle-right', enable: 'can_debug'
      }, {
        name: 'trigger_function_indirect_debugger', node: 'trigger_function', module: this,
        applies: ['object', 'context'], callback: 'check_func_debuggable',
        priority: 10, label: gettext('Set breakpoint'), category: gettext('Debugging'),
        icon: 'fa fa-arrow-circle-right',
        data: { object: 'trigger_function', debug_type: 'indirect' }, enable: 'can_debug'
      }, {
        name: 'trigger_indirect_debugger', node: 'trigger', module: this,
        applies: ['object', 'context'], callback: 'check_func_debuggable',
        priority: 10, label: gettext('Set breakpoint'), category: gettext('Debugging'),
        icon: 'fa fa-arrow-circle-right',
        data: { object: 'trigger', debug_type: 'indirect' }, enable: 'can_debug'
      }, {
        name: 'package_function_direct_debugger', node: 'edbfunc', module: this,
        applies: ['object', 'context'], callback: 'get_function_information',
        category: gettext('Debugging'), priority: 10, label: gettext('Debug'),
        data: { object: 'edbfunc' }, icon: 'fa fa-arrow-circle-right',
        enable: 'can_debug'
      }, {
        name: 'package_function_global_debugger', node: 'edbfunc', module: this,
        applies: ['object', 'context'], callback: 'check_func_debuggable',
        category: gettext('Debugging'), priority: 10, label: gettext('Set breakpoint'),
        data: { object: 'edbfunc', debug_type: 'indirect' },
        icon: 'fa fa-arrow-circle-right', enable: 'can_debug'
      }, {
        name: 'package_procedure_direct_debugger', node: 'edbproc', module: this,
        applies: ['object', 'context'], callback: 'get_function_information',
        category: gettext('Debugging'), priority: 10, label: gettext('Debug'),
        data: { object: 'edbproc' }, icon: 'fa fa-arrow-circle-right',
        enable: 'can_debug'
      }, {
        name: 'package_procedure_global_debugger', node: 'edbproc', module: this,
        applies: ['object', 'context'], callback: 'check_func_debuggable',
        category: gettext('Debugging'), priority: 10, label: gettext('Set breakpoint'),
        data: { object: 'edbproc', debug_type: 'indirect' },
        icon: 'fa fa-arrow-circle-right', enable: 'can_debug'
      }]);

      // Create and load the new frame required for debugger panel
      this.frame = new pgBrowser.Frame({
        name: 'frm_debugger',
        title: gettext('Debugger'),
        width: 500,
        isCloseable: true,
        isPrivate: true,
        icon: 'fa fa-arrow-circle-right',
        url: 'about:blank'
      });

      this.frame.load(pgBrowser.docker);
    },
    // It will check weather the function is actually debuggable or not with pre-required condition.
    can_debug: function can_debug(itemData, item, data) {
      var t = pgBrowser.tree,
          i = item,
          d = itemData;
      // To iterate over tree to check parent node
      while (i) {
        if ('catalog' == d._type) {
          //Check if we are not child of catalog
          return false;
        }
        i = t.hasParent(i) ? t.parent(i) : null;
        d = i ? t.itemData(i) : null;
      }

      // Find the function is really available in database
      var tree = pgBrowser.tree,
          info = tree.selected(),
          d_ = info && info.length == 1 ? tree.itemData(info) : undefined,
          node = d_ && pgBrowser.Nodes[d_._type];

      if (!d_) return false;

      var treeInfo = node.getTreeNodeHierarchy.apply(node, [info]);

      // For indirect debugging user must be super user
      if (data && data.debug_type && data.debug_type == 'indirect' && !treeInfo.server.user.is_superuser) return false;

      // Fetch object owner
      var obj_owner = treeInfo.function && treeInfo.function.funcowner || treeInfo.procedure && treeInfo.procedure.funcowner || treeInfo.edbfunc && treeInfo.edbfunc.funcowner || treeInfo.edbproc && treeInfo.edbproc.funcowner;

      // Must be a super user or object owner to create breakpoints of any kind
      if (!(treeInfo.server.user.is_superuser || obj_owner == treeInfo.server.user.name)) return false;

      // For trigger node, language will be undefined - we should allow indirect debugging for trigger node
      if (d_.language == undefined && d_._type == 'trigger' || d_.language == undefined && d_._type == 'edbfunc' || d_.language == undefined && d_._type == 'edbproc') {
        return true;
      }

      if (d_.language != 'plpgsql' && d_.language != 'edbspl') {
        return false;
      }

      return true;
    },
    /*
      For the direct debugging, we need to fetch the function information to display in the dialog so "generate_url"
      will dynamically generate the URL from the server_id, database_id, schema_id and function id.
    */
    generate_url: function generate_url(_url, treeInfo, node) {
      var url = '{BASEURL}{URL}/{OBJTYPE}{REF}',
          ref = '';

      _.each(_.sortBy(_.values(_.pick(treeInfo, function (v, k, o) {
        return k != 'server_group';
      })), function (o) {
        return o.priority;
      }), function (o) {
        ref = S('%s/%s').sprintf(ref, encodeURI(o._id)).value();
      });

      var args = {
        'URL': _url,
        'BASEURL': url_for('debugger.index'),
        'REF': ref,
        'OBJTYPE': encodeURI(node.type)
      };

      return url.replace(/{(\w+)}/g, function (match, arg) {
        return args[arg];
      });
    },

    check_func_debuggable: function check_func_debuggable(args, item) {
      var input = args || {},
          t = pgBrowser.tree,
          i = item || t.selected(),
          d = i && i.length == 1 ? t.itemData(i) : undefined,
          node = d && pgBrowser.Nodes[d._type];

      if (!d) return;

      var objName = d.label,
          treeInfo = node.getTreeNodeHierarchy.apply(node, [i]),
          _url = this.generate_url('init', treeInfo, node);

      var self = this;
      $.ajax({
        url: _url,
        cache: false,
        success: function success(res) {
          self.start_global_debugger();
        },
        error: function error(xhr, status, _error) {
          try {
            var err = $.parseJSON(xhr.responseText);
            if (err.success == 0) {
              Alertify.alert(err.errormsg);
            }
          } catch (e) {}
        }
      });
    },

    //Callback function when user start the indirect debugging ( Listen to another session to invoke the target )
    start_global_debugger: function start_global_debugger(args, item) {
      // Initialize the target and create asynchronous connection and unique transaction ID
      var t = pgBrowser.tree,
          i = t.selected(),
          d = i && i.length == 1 ? t.itemData(i) : undefined,
          node = d && pgBrowser.Nodes[d._type];

      if (!d) return;

      var treeInfo = node.getTreeNodeHierarchy.apply(node, [i]);

      if (d._type == "function") {
        var baseUrl = url_for('debugger.initialize_target_for_function', {
          'debug_type': 'indirect',
          'sid': treeInfo.server._id,
          'did': treeInfo.database._id,
          'scid': treeInfo.schema._id,
          'func_id': treeInfo.function._id
        });
      } else if (d._type == "procedure") {
        var baseUrl = url_for('debugger.initialize_target_for_function', {
          'debug_type': 'indirect',
          'sid': treeInfo.server._id,
          'did': treeInfo.database._id,
          'scid': treeInfo.schema._id,
          'func_id': treeInfo.procedure._id
        });
      } else if (d._type == "trigger_function") {
        var baseUrl = url_for('debugger.initialize_target_for_function', {
          'debug_type': 'indirect',
          'sid': treeInfo.server._id,
          'did': treeInfo.database._id,
          'scid': treeInfo.schema._id,
          'func_id': treeInfo.trigger_function._id
        });
      } else if (d._type == "trigger" && "table" in treeInfo) {
        var baseUrl = url_for('debugger.initialize_target_for_trigger', {
          'debug_type': 'indirect',
          'sid': treeInfo.server._id,
          'did': treeInfo.database._id,
          'scid': treeInfo.schema._id,
          'func_id': treeInfo.table._id,
          'tri_id': treeInfo.trigger._id
        });
      } else if (d._type == "trigger" && "view" in treeInfo) {
        var baseUrl = url_for('debugger.initialize_target_for_trigger', {
          'debug_type': 'indirect',
          'sid': treeInfo.server._id,
          'did': treeInfo.database._id,
          'scid': treeInfo.schema._id,
          'func_id': treeInfo.view._id,
          'tri_id': treeInfo.trigger._id
        });
      }

      $.ajax({
        url: baseUrl,
        method: 'GET',
        success: function success(res) {
          var url = url_for('debugger.direct', { 'trans_id': res.data.debuggerTransId });

          if (res.data.newBrowserTab) {
            window.open(url, '_blank');
          } else {
            pgBrowser.Events.once('pgadmin-browser:frame:urlloaded:frm_debugger', function (frame) {
              frame.openURL(url);
            });

            // Create the debugger panel as per the data received from user input dialog.
            var dashboardPanel = pgBrowser.docker.findPanels('properties'),
                panel = pgBrowser.docker.addPanel('frm_debugger', wcDocker.DOCK.STACKED, dashboardPanel[0]);

            panel.focus();

            // Panel Closed event
            panel.on(wcDocker.EVENT.CLOSED, function () {
              var closeUrl = url_for('debugger.close', { 'trans_id': res.data.debuggerTransId });
              $.ajax({
                url: closeUrl,
                method: 'DELETE'
              });
            });
          }
        },
        error: function error(xhr, status, _error2) {
          try {
            var err = $.parseJSON(xhr.responseText);
            if (err.success == 0) {
              Alertify.alert(err.errormsg);
            }
          } catch (e) {}
        }
      });
    },

    /*
      Get the function information for the direct debugging to display the functions arguments and  other informations
      in the user input dialog
    */
    get_function_information: function get_function_information(args, item) {
      var input = args || {},
          t = pgBrowser.tree,
          i = item || t.selected(),
          d = i && i.length == 1 ? t.itemData(i) : undefined,
          node = d && pgBrowser.Nodes[d._type];

      if (!d) return;

      var objName = d.label,
          treeInfo = node.getTreeNodeHierarchy.apply(node, [i]),
          _url = this.generate_url('init', treeInfo, node);

      var self = this;
      $.ajax({
        url: _url,
        cache: false,
        success: function success(res) {

          // Open Alertify the dialog to take the input arguments from user if function having input arguments
          if (res.data[0]['require_input']) {
            get_function_arguments(res.data[0], 0);
          } else {
            // Initialize the target and create asynchronous connection and unique transaction ID
            // If there is no arguments to the functions then we should not ask for for function arguments and
            // Directly open the panel
            var t = pgBrowser.tree,
                i = t.selected(),
                d = i && i.length == 1 ? t.itemData(i) : undefined,
                node = d && pgBrowser.Nodes[d._type];

            if (!d) return;

            var treeInfo = node.getTreeNodeHierarchy.apply(node, [i]);

            if (d._type == "function") {
              var baseUrl = url_for('debugger.initialize_target_for_function', {
                'debug_type': 'direct',
                'sid': treeInfo.server._id,
                'did': treeInfo.database._id,
                'scid': treeInfo.schema._id,
                'func_id': treeInfo.function._id
              });
            } else {
              var baseUrl = url_for('debugger.initialize_target_for_function', {
                'debug_type': 'direct',
                'sid': treeInfo.server._id,
                'did': treeInfo.database._id,
                'scid': treeInfo.schema._id,
                'func_id': treeInfo.procedure._id
              });
            }

            $.ajax({
              url: baseUrl,
              method: 'GET',
              success: function success(res) {

                var url = url_for('debugger.direct', { 'trans_id': res.data.debuggerTransId });

                if (res.data.newBrowserTab) {
                  window.open(url, '_blank');
                } else {
                  pgBrowser.Events.once('pgadmin-browser:frame:urlloaded:frm_debugger', function (frame) {
                    frame.openURL(url);
                  });

                  // Create the debugger panel as per the data received from user input dialog.
                  var dashboardPanel = pgBrowser.docker.findPanels('properties'),
                      panel = pgBrowser.docker.addPanel('frm_debugger', wcDocker.DOCK.STACKED, dashboardPanel[0]);

                  panel.focus();

                  // Register Panel Closed event
                  panel.on(wcDocker.EVENT.CLOSED, function () {
                    var closeUrl = url_for('debugger.close', { 'trans_id': res.data.debuggerTransId });
                    $.ajax({
                      url: closeUrl,
                      method: 'DELETE'
                    });
                  });
                }
              },
              error: function error(e) {
                Alertify.alert('Debugger target Initialize Error', e.responseJSON.errormsg);
              }
            });
          }
        },
        error: function error(xhr, status, _error3) {
          try {
            var err = $.parseJSON(xhr.responseText);
            if (err.success == 0) {
              Alertify.alert('Debugger Error', err.errormsg);
            }
          } catch (e) {}
        }
      });
    }
  };

  return pgAdmin.Tools.Debugger;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(17), __webpack_require__(266), __webpack_require__(267)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  if (!pgBrowser.Nodes['coll-pga_job']) {
    var pga_jobs = pgBrowser.Nodes['coll-pga_job'] = pgBrowser.Collection.extend({
      node: 'pga_job',
      label: gettext('pga_jobs'),
      type: 'coll-pga_job',
      columns: ['jobid', 'jobname', 'jobenabled', 'jlgstatus', 'jobnextrun', 'joblastrun', 'jobdesc'],
      hasStatistics: false
    });
  };

  if (!pgBrowser.Nodes['pga_job']) {
    pgBrowser.Nodes['pga_job'] = pgBrowser.Node.extend({
      parent_type: 'server',
      type: 'pga_job',
      dialogHelp: url_for('help.static', { 'filename': 'pgagent_jobs.html' }),
      hasSQL: true,
      hasDepends: false,
      hasStatistics: true,
      hasCollectiveStatistics: true,
      width: '80%',
      height: '80%',
      canDrop: function canDrop(node) {
        return true;
      },
      label: gettext('pgAgent Job'),
      node_image: function node_image() {
        return 'icon-pga_job';
      },
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_pga_job_on_coll', node: 'coll-pga_job', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('pgAgent Job...'),
          icon: 'wcTabIcon icon-pga_job', data: { action: 'create' }
        }, {
          name: 'create_pga_job', node: 'pga_job', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('pgAgent Job...'),
          icon: 'wcTabIcon icon-pga_job', data: { action: 'create' }
        }, {
          name: 'run_now_pga_job', node: 'pga_job', module: this,
          applies: ['object', 'context'], callback: 'run_pga_job_now',
          priority: 4, label: gettext('Run now'), data: { action: 'create' },
          icon: 'fa fa-play-circle'
        }]);
      },
      model: pgBrowser.Node.Model.extend({
        defaults: {
          jobname: '',
          jobid: undefined,
          jobenabled: true,
          jobhostagent: '',
          jobjclid: 1,
          jobcreated: undefined,
          jobchanged: undefined,
          jobnextrun: undefined,
          joblastrun: undefined,
          jlgstatus: undefined,
          jobrunningat: undefined,
          jobdesc: '',
          jsteps: [],
          jschedules: []
        },
        idAttribute: 'jobid',
        parse: function parse() {
          var d = pgBrowser.Node.Model.prototype.parse.apply(this, arguments);

          if (d) {
            d.jobrunningat = d.jaghostagent || gettext("Not running currently.");
            d.jlgstatus = d.jlgstatus || gettext("Unknown");
          }
          return d;
        },
        schema: [{
          id: 'jobname', label: gettext('Name'), type: 'text',
          cellHeaderClasses: 'width_percent_30'
        }, {
          id: 'jobid', label: gettext('ID'), mode: ['properties'],
          type: 'int'
        }, {
          id: 'jobenabled', label: gettext('Enabled?'), type: 'switch',
          cellHeaderClasses: 'width_percent_5'
        }, {
          id: 'jobclass', label: gettext('Job class'), type: 'text',
          mode: ['properties']
        }, {
          id: 'jobjclid', label: gettext('Job class'), type: 'int',
          control: 'node-ajax-options', url: 'classes', url_with_id: false,
          cache_node: 'server', mode: ['create', 'edit'],
          select2: { allowClear: false },
          helpMessage: gettext('Please select a class to categorize the job. This option will not affect the way the job runs.')
        }, {
          id: 'jobhostagent', label: gettext('Host agent'), type: 'text',
          mode: ['edit', 'create'],
          helpMessage: gettext('Enter the hostname of a machine running pgAgent if you wish to ensure only that machine will run this job. Leave blank if any host may run the job.')
        }, {
          id: 'jobhostagent', label: gettext('Host agent'), type: 'text',
          mode: ['properties']
        }, {
          id: 'jobcreated', type: 'text', mode: ['properties'],
          label: gettext('Created')
        }, {
          id: 'jobchanged', type: 'text', mode: ['properties'],
          label: gettext('Changed')
        }, {
          id: 'jobnextrun', type: 'text', mode: ['properties'],
          label: gettext('Next run'), cellHeaderClasses: 'width_percent_20'
        }, {
          id: 'joblastrun', type: 'text', mode: ['properties'],
          label: gettext('Last run'), cellHeaderClasses: 'width_percent_20'
        }, {
          id: 'jlgstatus', type: 'text', label: gettext('Last result'),
          cellHeaderClasses: 'width_percent_5', mode: ['properties']
        }, {
          id: 'jobrunningat', type: 'text', mode: ['properties'],
          label: gettext('Running at')
        }, {
          id: 'jobdesc', label: gettext('Comment'), type: 'multiline',
          cellHeaderClasses: 'width_percent_15'
        }, {
          id: 'jsteps', label: '', group: gettext('Steps'),
          type: 'collection', mode: ['edit', 'create'],
          model: pgBrowser.Nodes['pga_jobstep'].model, canEdit: true,
          control: 'sub-node-collection', canAdd: true, canDelete: true,
          columns: ['jstname', 'jstenabled', 'jstkind', 'jstconntype', 'jstonerror']
        }, {
          id: 'jschedules', label: '', group: gettext('Schedules'),
          type: 'collection', mode: ['edit', 'create'],
          control: 'sub-node-collection', canAdd: true, canDelete: true,
          canEdit: true, model: pgBrowser.Nodes['pga_schedule'].model,
          columns: ['jscname', 'jscenabled', 'jscstart', 'jscend']
        }],
        validate: function validate(keys) {
          var name = this.get('jobname');
          if (_.isUndefined(name) || _.isNull(name) || String(name).replace(/^\s+|\s+$/g, '') == '') {
            var msg = gettext('Name cannot be empty.');
            this.errorModel.set('jobname', msg);
            return msg;
          } else {
            this.errorModel.unset('jobname');
          }
          return null;
        }
      }),
      /* Run pgagent job now */
      run_pga_job_now: function run_pga_job_now(args) {
        var input = args || {},
            obj = this,
            t = pgBrowser.tree,
            i = input.item || t.selected(),
            d = i && i.length == 1 ? t.itemData(i) : undefined;

        if (!d) return false;

        $.ajax({
          url: obj.generate_url(i, 'run_now', d, true),
          method: 'PUT',
          success: function success(res) {
            // 'pgagent.pga_job' table updated with current time
            // to run the job now.
            t.unload(i);
          },
          error: function error(xhr, status, _error) {
            var error_msg = "Unable to run pgagent job.";
            if (xhr.readyState == 0) {
              alertify.error(gettext('Not connected to the server or the connection to the server has been closed.'));
            } else {
              if (_.isUndefined(xhr.responseText)) {
                alertify.error(error_msg);
              } else {
                var err = $.parseJSON(xhr.responseText);
                if (err.success == 0) {
                  alertify.error(err.errormsg);
                }
              }
            }
            t.unload(i);
          }
        });

        return false;
      }
    });
  }

  return pgBrowser.Nodes['pga_job'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(16), __webpack_require__(13), __webpack_require__(24), __webpack_require__(28)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, Alertify, Backform, Backgrid) {

  if (!pgBrowser.Nodes['coll-pga_jobstep']) {
    pgBrowser.Nodes['coll-pga_jobstep'] = pgBrowser.Collection.extend({
      node: 'pga_jobstep',
      label: gettext('Steps'),
      type: 'coll-pga_jobstep',
      columns: ['jstid', 'jstname', 'jstenabled', 'jstkind', 'jstconntype', 'jstonerror'],
      hasStatistics: false
    });
  }

  // Switch Cell with Deps, Needed for SubNode control
  var SwitchDepsCell = Backgrid.Extension.SwitchCell.extend({
    initialize: function initialize() {
      Backgrid.Extension.SwitchCell.prototype.initialize.apply(this, arguments);
      Backgrid.Extension.DependentCell.prototype.initialize.apply(this, arguments);
    },
    dependentChanged: function dependentChanged() {
      var model = this.model,
          column = this.column,
          editable = this.column.get("editable"),
          input = this.$el.find('input[type=checkbox]').first(),
          self_name = column.get('name'),
          is_editable;

      is_editable = _.isFunction(editable) ? !!editable.apply(column, [model]) : !!editable;
      if (is_editable) {
        this.$el.addClass("editable");
        input.bootstrapSwitch('disabled', false);
      } else {
        this.$el.removeClass("editable");
        input.bootstrapSwitch('disabled', true);
        // Set self value into model
        setTimeout(function () {
          model.set(self_name, true);
        }, 10);
      }

      this.delegateEvents();
      return this;
    },
    remove: Backgrid.Extension.DependentCell.prototype.remove
  });

  if (!pgBrowser.Nodes['pga_jobstep']) {
    pgBrowser.Nodes['pga_jobstep'] = pgBrowser.Node.extend({
      parent_type: 'pga_job',
      type: 'pga_jobstep',
      dialogHelp: url_for('help.static', { 'filename': 'pgagent_jobs.html' }),
      hasSQL: true,
      hasDepends: false,
      hasStatistics: true,
      hasCollectiveStatistics: true,
      width: '70%',
      height: '80%',
      canDrop: function canDrop(node) {
        return true;
      },
      label: gettext('Step'),
      node_image: function node_image() {
        return 'icon-pga_jobstep';
      },
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_pga_jobstep_on_job', node: 'pga_job', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Job Step...'),
          data: { 'action': 'create' }, icon: 'wcTabIcon icon-pga_jobstep'
        }, {
          name: 'create_pga_jobstep_on_coll', node: 'coll-pga_jobstep', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Job Step...'),
          data: { 'action': 'create' }, icon: 'wcTabIcon icon-pga_jobstep'
        }, {
          name: 'create_pga_jobstep', node: 'pga_jobstep', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Job Step...'),
          data: { 'action': 'create' }, icon: 'wcTabIcon icon-pga_jobstep'
        }]);
      },
      model: pgBrowser.Node.Model.extend({
        defaults: {
          jstid: null,
          jstjobid: null,
          jstname: '',
          jstdesc: '',
          jstenabled: true,
          jstkind: true,
          jstconntype: true,
          jstcode: '',
          jstconnstr: null,
          jstdbname: null,
          jstonerror: 'f',
          jstnextrun: ''
        },
        initialize: function initialize() {
          pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
          if (this.isNew() && this.get('jstconntype')) {
            var args = arguments && arguments.length > 1 && arguments[1];

            if (args) {
              this.set('jstdbname', (args['node_info'] || args.collection.top['node_info'])['server']['db']);
            }
          }
        },
        idAttribute: 'jstid',
        schema: [{
          id: 'jstid', label: gettext('ID'), type: 'int',
          cellHeaderClasses: 'width_percent_5', mode: ['properties']
        }, {
          id: 'jstname', label: gettext('Name'), type: 'text',
          disabled: function disabled(m) {
            return false;
          },
          cellHeaderClasses: 'width_percent_60'
        }, {
          id: 'jstenabled', label: gettext('Enabled?'), type: 'switch',
          disabled: function disabled(m) {
            return false;
          }
        }, {
          id: 'jstkind', label: gettext('Kind'), type: 'switch',
          options: {
            'onText': gettext('SQL'), 'offText': gettext('Batch'),
            'onColor': 'primary', 'offColor': 'primary'
          }, control: Backform.SwitchControl,
          disabled: function disabled(m) {
            return false;
          }
        }, {
          id: 'jstconntype', label: gettext('Connection type'),
          type: 'switch', deps: ['jstkind'], mode: ['properties'],
          disabled: function disabled(m) {
            return !m.get('jstkind');
          },
          options: {
            'onText': gettext('Local'), 'offText': gettext('Remote'),
            'onColor': 'primary', 'offColor': 'primary'
          }
        }, {
          id: 'jstconntype', label: gettext('Connection type'),
          type: 'switch', deps: ['jstkind'], mode: ['create', 'edit'],
          disabled: function disabled(m) {
            return !m.get('jstkind');
          },
          cell: SwitchDepsCell,
          editable: function editable(m) {
            // If jstkind is Batch then disable it
            return m.get('jstkind');
          },
          options: {
            'onText': gettext('Local'), 'offText': gettext('Remote'),
            'onColor': 'primary', 'offColor': 'primary'
          }, helpMessage: gettext('Select <b>Local</b> if the job step will execute on the local database server, or <b>Remote</b> to specify a remote database server.')
        }, {
          id: 'jstdbname', label: gettext('Database'), type: 'text',
          mode: ['properties'], disabled: function disabled(m) {
            return false;
          }
        }, {
          id: 'jstconnstr', type: 'text', mode: ['properties'],
          label: gettext('Connection string')
        }, {
          id: 'jstdbname', label: gettext('Database'), type: 'text',
          control: 'node-list-by-name', node: 'database',
          cache_node: 'database', select2: { allowClear: true, placeholder: '' },
          disabled: function disabled(m) {
            return !m.get('jstkind') || !m.get('jstconntype');
          }, deps: ['jstkind', 'jstconntype'], mode: ['create', 'edit'],
          helpMessage: gettext('Please select the database on which the job step will run.')
        }, {
          id: 'jstconnstr', label: gettext('Connection string'), type: 'text',
          deps: ['jstkind', 'jstconntype'], disabled: function disabled(m) {
            return !m.get('jstkind') || m.get('jstconntype');
          }, helpMessage: S(gettext("Please specify the connection string for the remote database server. Each parameter setting is in the form keyword = value. Spaces around the equal sign are optional. To write an empty value, or a value containing spaces, surround it with single quotes, e.g., keyword = 'a value'. Single quotes and backslashes within the value must be escaped with a backslash, i.e., \' and \\.<br>For more information, please see the documentation on %s")).sprintf('<a href="https://www.postgresql.org/docs/current/static/libpq-connect.html#LIBPQ-CONNSTRING" target="_blank">libpq connection strings</a>').value(), mode: ['create', 'edit']
        }, {
          id: 'jstonerror', label: gettext('On error'), cell: 'select2',
          control: 'select2', options: [{ 'label': gettext('Fail'), 'value': "f" }, { 'label': gettext('Success'), 'value': "s" }, { 'label': gettext('Ignore'), 'value': "i" }], select2: { allowClear: false }, disabled: function disabled(m) {
            return false;
          }
        }, {
          id: 'jstdesc', label: gettext('Comment'), type: 'multiline'
        }, _defineProperty({
          id: 'jstcode', label: '', cell: 'string', deps: ['jstkind'],
          type: 'text', control: 'sql-field', group: gettext('Code')
        }, 'control', Backform.SqlFieldControl.extend({
          render: function render() {
            if (this.model.get('jstkind')) {
              this.field.set('label', gettext('SQL query'));
            } else {
              this.field.set('label', gettext('Script'));
            }
            return Backform.SqlFieldControl.prototype.render.apply(this, arguments);
          }
        }))],
        validate: function validate(keys) {
          var val = this.get('jstname'),
              errMsg = null;

          if (_.isUndefined(val) || _.isNull(val) || String(val).replace(/^\s+|\s+$/g, '') == '') {
            errMsg = gettext('Name cannot be empty.');
            this.errorModel.set('jstname', errMsg);
          } else {
            this.errorModel.unset('jstname');
          }
          if (this.get('jstkind')) {
            if (this.get('jstconntype')) {
              this.errorModel.unset('jstconnstr');
              val = this.get('jstdbname');
              if (_.isUndefined(val) || _.isNull(val) || String(val).replace(/^\s+|\s+$/g, '') == '') {
                var msg = gettext('Please select a database.');
                errMsg = errMsg || msg;
                this.errorModel.set('jstdbname', msg);
              } else {
                this.errorModel.unset('jstdbname');
              }
            } else {
              this.errorModel.unset('jstdbname');
              var msg,
                  r = /\s*\b(\w+)\s*=\s*('([^'\\]*(?:\\.[^'\\]*)*)'|[\w|\.]*)/g;
              val = this.get('jstconnstr');
              if (_.isUndefined(val) || _.isNull(val) || String(val).replace(/^\s+|\s+$/g, '') == '') {
                msg = gettext('Please enter a connection string.');
              } else if (String(val).replace(r, '') != '') {
                msg = gettext('Please enter a valid connection string.');
              } else {
                var m,
                    params = {
                  'host': true, 'hostaddr': true, 'port': true,
                  'dbname': true, 'user': true, 'password': true,
                  'connect_timeout': true, 'client_encoding': true,
                  'application_name': true, 'options': true,
                  'fallback_application_name': true, 'sslmode': true,
                  'sslcert': true, 'sslkey': true, 'sslrootcert': true,
                  'sslcrl': true, 'keepalives': true, 'service': true,
                  'keepalives_idle': true, 'keepalives_interval': true,
                  'keepalives_count': true, 'sslcompression': true,
                  'requirepeer': true, 'krbsrvname': true, 'gsslib': true
                };

                while (m = r.exec(val)) {
                  if (params[m[1]]) {
                    if (m[2]) continue;
                    msg = gettext('Please enter a valid connection string.');
                    break;
                  }

                  msg = S(gettext('Invalid parameter in the connection string - %s.')).sprintf(m[1]).value();
                  break;
                }
              }

              if (msg) {
                errMsg = errMsg || msg;
                this.errorModel.set('jstconnstr', msg);
              } else {
                this.errorModel.unset('jstconnstr');
              }
            }
          } else {
            this.errorModel.unset('jstconnstr');
            this.errorModel.unset('jstdbname');
          }

          val = this.get('jstcode');
          if (_.isUndefined(val) || _.isNull(val) || String(val).replace(/^\s+|\s+$/g, '') == '') {
            var msg = gettext('Please specify code to execute.');
            errMsg = errMsg || msg;
            this.errorModel.set('jstcode', msg);
          } else {
            this.errorModel.unset('jstcode');
          }

          return errMsg;
        }
      })
    });
  }

  return pgBrowser.Nodes['pga_job'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backgrid) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(47), __webpack_require__(6), __webpack_require__(8), __webpack_require__(16), __webpack_require__(24)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, moment, pgBrowser, Alertify, Backform) {

  if (!pgBrowser.Nodes['coll-pga_schedule']) {
    pgBrowser.Nodes['coll-pga_schedule'] = pgBrowser.Collection.extend({
      node: 'pga_schedule',
      label: gettext('Schedules'),
      type: 'coll-pga_schedule',
      columns: ['jscid', 'jscname', 'jscenabled'],
      hasStatistics: false
    });
  }

  if (!pgBrowser.Nodes['pga_schedule']) {

    var weekdays = [gettext('Sunday'), gettext('Monday'), gettext('Tuesday'), gettext('Wednesday'), gettext('Thursday'), gettext('Friday'), gettext('Saturday')],
        monthdays = [gettext('1st'), gettext('2nd'), gettext('3rd'), gettext('4th'), gettext('5th'), gettext('6th'), gettext('7th'), gettext('8th'), gettext('9th'), gettext('10th'), gettext('11th'), gettext('12th'), gettext('13th'), gettext('14th'), gettext('15th'), gettext('16th'), gettext('17th'), gettext('18th'), gettext('19th'), gettext('20th'), gettext('21st'), gettext('22nd'), gettext('23rd'), gettext('24th'), gettext('25th'), gettext('26th'), gettext('27th'), gettext('28th'), gettext('29th'), gettext('30th'), gettext('31st'), gettext('Last day')],
        months = [gettext('January'), gettext('February'), gettext('March'), gettext('April'), gettext('May'), gettext('June'), gettext('July'), gettext('August'), gettext('September'), gettext('October'), gettext('November'), gettext('December')],
        hours = [gettext('00'), gettext('01'), gettext('02'), gettext('03'), gettext('04'), gettext('05'), gettext('06'), gettext('07'), gettext('08'), gettext('09'), gettext('10'), gettext('11'), gettext('12'), gettext('13'), gettext('14'), gettext('15'), gettext('16'), gettext('17'), gettext('18'), gettext('19'), gettext('20'), gettext('21'), gettext('22'), gettext('23')],
        minutes = [gettext('00'), gettext('01'), gettext('02'), gettext('03'), gettext('04'), gettext('05'), gettext('06'), gettext('07'), gettext('08'), gettext('09'), gettext('10'), gettext('11'), gettext('12'), gettext('13'), gettext('14'), gettext('15'), gettext('16'), gettext('17'), gettext('18'), gettext('19'), gettext('20'), gettext('21'), gettext('22'), gettext('23'), gettext('24'), gettext('25'), gettext('26'), gettext('27'), gettext('28'), gettext('29'), gettext('30'), gettext('31'), gettext('32'), gettext('33'), gettext('34'), gettext('35'), gettext('36'), gettext('37'), gettext('38'), gettext('39'), gettext('40'), gettext('41'), gettext('42'), gettext('43'), gettext('44'), gettext('45'), gettext('46'), gettext('47'), gettext('48'), gettext('49'), gettext('50'), gettext('51'), gettext('52'), gettext('53'), gettext('54'), gettext('55'), gettext('56'), gettext('57'), gettext('58'), gettext('59')],
        AnyDatetimeCell = Backgrid.Extension.MomentCell.extend({
      editor: Backgrid.Extension.DatetimePickerEditor,
      render: function render() {
        this.$el.empty();
        var model = this.model;
        this.$el.text(this.formatter.fromRaw(model.get(this.column.get("name")), model) || gettext('<any>'));
        this.delegateEvents();

        return this;
      }
    }),
        BooleanArrayFormatter = function BooleanArrayFormatter(selector, indexes) {
      var self = this;

      self.selector = selector;
      self.indexes = indexes;

      this.fromRaw = function (rawData) {
        if (!_.isArray(rawData)) {
          return rawData;
        }

        var res = [],
            idx = 0,
            resIdx = [];

        for (; idx < rawData.length; idx++) {
          if (!rawData[idx]) continue;
          res.push(self.selector[idx]);
          resIdx.push(idx + 1);
        }

        return self.indexes ? resIdx : res.join(', ');
      };
      this.toRaw = function (d) {
        if (!self.indexes) return d;
        var res = [],
            i = 0,
            l = self.selector.length;

        for (; i < l; i++) {
          res.push(_.indexOf(d, String(i + 1)) != -1);
        }
        return res;
      };

      return self;
    },
        BooleanArrayOptions = function BooleanArrayOptions(ctrl) {
      var selector = ctrl.field.get('selector'),
          val = ctrl.model.get(ctrl.field.get('name')),
          res = [];

      if (selector) {
        res = _.map(selector, function (v, i) {
          return { label: v, value: i + 1, selected: val[i] };
        });
      }
      return res;
    },
        ExceptionModel = pgBrowser.Node.Model.extend({
      defaults: {
        jexid: undefined,
        jexdate: null,
        jextime: null
      },
      idAttribute: 'jexid',
      schema: [{
        id: 'jexdate', type: 'text', label: gettext('Date'),
        editable: true, placeholder: gettext('<any>'),
        cell: AnyDatetimeCell, options: { format: 'YYYY-MM-DD' },
        displayFormat: 'YYYY-MM-DD', modelFormat: 'YYYY-MM-DD',
        cellHeaderClasses: 'width_percent_50', allowEmpty: true
      }, {
        id: 'jextime', type: 'text', placeholder: gettext('<any>'),
        label: gettext('Time'), editable: true, cell: AnyDatetimeCell,
        options: { format: 'HH:mm' }, displayFormat: 'HH:mm',
        modelFormat: 'HH:mm:ss', displayInUTC: false, allowEmpty: true,
        cellHeaderClasses: 'width_percent_50', modalInUTC: false
      }],
      validate: function validate() {
        var self = this,
            exceptions = this.collection,
            dates = {},
            errMsg,
            hasExceptionErr = false,
            d = this.get('jexdate') || '<any>',
            t = this.get('jextime') || '<any>',
            id = this.get('jexid') || this.cid;

        self.errorModel.unset('jscdate');
        if (d == t && d == '<any>') {
          errMsg = gettext('Please specify date/time.');
          self.errorModel.set('jscdate', errMsg);
          return errMsg;
        }

        exceptions.each(function (ex) {
          if (hasExceptionErr || id == (ex.get('jexid') || ex.cid)) return;

          if (d == (ex.get('jexdate') || '<any>') && t == (ex.get('jextime') || '<any>')) {
            errMsg = gettext('Please specify unique set of exceptions.');
            if (ex.errorModel.get('jscdate') != errMsg) self.errorModel.set('jscdate', errMsg);
            hasExceptionErr = true;
          }
        });

        return errMsg;
      }
    });

    pgBrowser.Nodes['pga_schedule'] = pgBrowser.Node.extend({
      parent_type: 'pga_job',
      type: 'pga_schedule',
      dialogHelp: url_for('help.static', { 'filename': 'pgagent_jobs.html' }),
      hasSQL: true,
      hasDepends: false,
      hasStatistics: false,
      canDrop: function canDrop(node) {
        return true;
      },
      label: gettext('Schedule'),
      node_image: 'icon-pga_schedule',
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_pga_schedule_on_job', node: 'pga_job', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Schedule...'),
          icon: 'wcTabIcon icon-pga_schedule', data: { action: 'create' }
        }, {
          name: 'create_pga_schedule_on_coll', node: 'coll-pga_schedule', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Schedule...'),
          icon: 'wcTabIcon icon-pga_schedule', data: { action: 'create' }
        }, {
          name: 'create_pga_schedule', node: 'pga_schedule', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Schedule...'),
          icon: 'wcTabIcon icon-pga_schedule', data: { action: 'create' }
        }]);
      },
      model: pgBrowser.Node.Model.extend({
        defaults: {
          jscid: null,
          jscjobid: null,
          jscname: '',
          jscdesc: '',
          jscenabled: true,
          jscstart: null,
          jscend: null,
          jscweekdays: _.map(weekdays, function () {
            return false;
          }),
          jscmonthdays: _.map(monthdays, function () {
            return false;
          }),
          jscmonths: _.map(months, function () {
            return false;
          }),
          jschours: _.map(hours, function () {
            return false;
          }),
          jscminutes: _.map(minutes, function () {
            return false;
          }),
          jscexceptions: []
        },
        idAttribute: 'jscid',
        parse: function parse(d) {
          d.jscexceptions = [];
          if (d.jexid && d.jexid.length) {
            var idx = 0;
            for (; idx < d.jexid.length; idx++) {
              d.jscexceptions.push({
                'jexid': d.jexid[idx],
                'jexdate': d.jexdate[idx],
                'jextime': d.jextime[idx]
              });
            }
          }
          delete d.jexid;
          delete d.jexdate;
          delete d.jextime;

          return pgBrowser.Node.Model.prototype.parse.apply(this, arguments);
        },
        schema: [{
          id: 'jscid', label: gettext('ID'), type: 'int',
          cellHeaderClasses: 'width_percent_5', mode: ['properties']
        }, {
          id: 'jscname', label: gettext('Name'), type: 'text',
          cellHeaderClasses: 'width_percent_45',
          disabled: function disabled() {
            return false;
          }
        }, {
          id: 'jscenabled', label: gettext('Enabled?'), type: 'switch',
          disabled: function disabled() {
            return false;
          },
          cellHeaderClasses: 'width_percent_5'
        }, {
          id: 'jscstart', label: gettext('Start'), type: 'text',
          control: 'datetimepicker', cell: 'moment',
          disabled: function disabled() {
            return false;
          }, displayInUTC: false,
          displayFormat: 'YYYY-MM-DD HH:mm:ss Z',
          modelFormat: 'YYYY-MM-DD HH:mm:ss Z', options: {
            format: 'YYYY-MM-DD HH:mm:ss Z'
          }, cellHeaderClasses: 'width_percent_25'
        }, {
          id: 'jscend', label: gettext('End'), type: 'text',
          control: 'datetimepicker', cell: 'moment',
          disabled: function disabled() {
            return false;
          }, displayInUTC: false,
          displayFormat: 'YYYY-MM-DD HH:mm:ss Z', options: {
            format: 'YYYY-MM-DD HH:mm:ss Z', useCurrent: false
          }, cellHeaderClasses: 'width_percent_25',
          modelFormat: 'YYYY-MM-DD HH:mm:ss Z'
        }, {
          id: 'jscweekdays', label: gettext('Week days'), type: 'text',
          control: Backform.Control.extend({
            formatter: new BooleanArrayFormatter(weekdays, false)
          }), mode: ['properties']
        }, {
          id: 'jscmonthdays', label: gettext('Month days'), type: 'text',
          control: Backform.Control.extend({
            formatter: new BooleanArrayFormatter(monthdays, false)
          }), mode: ['properties']
        }, {
          id: 'jscmonths', label: gettext('Months'), type: 'text',
          control: Backform.Control.extend({
            formatter: new BooleanArrayFormatter(months, false)
          }), mode: ['properties']
        }, {
          id: 'jschours', label: gettext('Hours'), type: 'text',
          control: Backform.Control.extend({
            formatter: new BooleanArrayFormatter(hours, false)
          }), mode: ['properties']
        }, {
          id: 'jscminutes', label: gettext('Minutes'), type: 'text',
          control: Backform.Control.extend({
            formatter: new BooleanArrayFormatter(minutes, false)
          }), mode: ['properties']
        }, {
          id: 'jscexceptions', label: gettext('Exceptions'), type: 'text',
          control: Backform.Control.extend({
            formatter: new function () {
              this.fromRaw = function (rawData) {
                var res = '',
                    idx = 0,
                    d;

                if (!rawData) {
                  return res;
                }

                for (; idx < rawData.length; idx++) {
                  d = rawData[idx];
                  if (idx) res += ', ';
                  res += '[' + String((d.jexdate || '') + ' ' + (d.jextime || '')).replace(/^\s+|\s+$/g, '') + ']';
                }

                return res;
              };
              this.toRaw = function (data) {
                return data;
              };

              return this;
            }()
          }), mode: ['properties']
        }, {
          type: 'nested', label: gettext('Days'), group: gettext('Repeat'),
          mode: ['create', 'edit'],
          control: Backform.FieldsetControl.extend({
            render: function render() {
              var res = Backform.FieldsetControl.prototype.render.apply(this, arguments);

              this.$el.prepend('<div class="set-group pg-el-xs-12 ' + Backform.helpMessageClassName + '">' + gettext('Schedules are specified using a <b>cron-style</b> format.<br/><ul><li>For each selected time or date element, the schedule will execute.<br/>e.g. To execute at 5 minutes past every hour, simply select 05 in the Minutes list box.<br/></li><li>Values from more than one field may be specified in order to further control the schedule.<br/>e.g. To execute at 12:05 and 14:05 every Monday and Thursday, you would click minute 05, hours 12 and 14, and weekdays Monday and Thursday.</li><li>For additional flexibility, the Month Days check list includes an extra Last Day option. This matches the last day of the month, whether it happens to be the 28th, 29th, 30th or 31st.</li></ul>') + '</div>');

              return res;
            }
          }),
          schema: [{
            id: 'jscweekdays', label: gettext('Week Days'), cell: 'select2',
            group: gettext('Days'), control: 'select2',
            select2: {
              first_empty: false,
              multiple: true,
              allowClear: true,
              placeholder: gettext('Select the weekdays...'),
              width: 'style',
              dropdownAdapter: $.fn.select2.amd.require('select2/selectAllAdapter')
            },
            selector: weekdays,
            formatter: new BooleanArrayFormatter(weekdays, true),
            options: BooleanArrayOptions
          }, {
            id: 'jscmonthdays', label: gettext('Month Days'), cell: 'select2',
            group: gettext('Days'), control: 'select2',
            select2: {
              first_empty: false,
              multiple: true,
              allowClear: true,
              placeholder: gettext('Select the month days...'),
              width: 'style',
              dropdownAdapter: $.fn.select2.amd.require('select2/selectAllAdapter')
            },
            formatter: new BooleanArrayFormatter(monthdays, true),
            selector: monthdays, options: BooleanArrayOptions
          }, {
            id: 'jscmonths', label: gettext('Months'), cell: 'select2',
            group: gettext('Days'), control: 'select2',
            select2: {
              first_empty: false,
              multiple: true,
              allowClear: true,
              placeholder: gettext('Select the months...'),
              width: 'style',
              dropdownAdapter: $.fn.select2.amd.require('select2/selectAllAdapter')
            },
            formatter: new BooleanArrayFormatter(months, true),
            selector: months, options: BooleanArrayOptions
          }]
        }, {
          type: 'nested', control: 'fieldset', label: gettext('Times'),
          group: gettext('Repeat'), mode: ['create', 'edit'],
          schema: [{
            id: 'jschours', label: gettext('Hours'), cell: 'select2',
            group: gettext('Times'), control: 'select2',
            select2: {
              first_empty: false,
              multiple: true,
              allowClear: true,
              placeholder: gettext('Select the hours...'),
              width: 'style',
              dropdownAdapter: $.fn.select2.amd.require('select2/selectAllAdapter')
            },
            formatter: new BooleanArrayFormatter(hours, true),
            selector: hours, options: BooleanArrayOptions
          }, {
            id: 'jscminutes', label: gettext('Minutes'), cell: 'select2',
            group: gettext('Times'), control: 'select2',
            select2: {
              first_empty: false,
              multiple: true,
              allowClear: true,
              placeholder: gettext('Select the minutes...'),
              width: 'style',
              dropdownAdapter: $.fn.select2.amd.require('select2/selectAllAdapter')
            },
            formatter: new BooleanArrayFormatter(minutes, true),
            selector: minutes, options: BooleanArrayOptions
          }]
        }, {
          id: 'jscexceptions', type: 'collection', mode: ['edit', 'create'],
          label: "", canEdit: false, model: ExceptionModel, canAdd: true,
          group: gettext('Exceptions'), canDelete: true,
          cols: ['jexdate', 'jextime'], control: 'sub-node-collection'
        }, {
          id: 'jscdesc', label: gettext('Comment'), type: 'multiline'
        }],
        validate: function validate(keys) {
          var val = this.get('jscname'),
              errMsg = null;

          if (_.isUndefined(val) || _.isNull(val) || String(val).replace(/^\s+|\s+$/g, '') == '') {
            var msg = gettext('Name cannot be empty.');
            this.errorModel.set('jscname', msg);
            errMsg = msg;
          } else {
            this.errorModel.unset('jscname');
          }

          val = this.get('jscstart');
          if (_.isUndefined(val) || _.isNull(val) || String(val).replace(/^\s+|\s+$/g, '') == '') {
            var msg = gettext('Please enter the start time.');
            this.errorModel.set('jscstart', msg);
            errMsg = errMsg || msg;
          } else {
            this.errorModel.unset('jscstart');
          }

          val = this.get('jscend');
          if (_.isUndefined(val) || _.isNull(val) || String(val).replace(/^\s+|\s+$/g, '') == '') {
            var msg = gettext('Please enter the end time.');
            this.errorModel.set('jscend', msg);
            errMsg = errMsg || msg;
          } else {
            this.errorModel.unset('jscend');
          }

          return errMsg;
        }
      })
    });
  }

  return pgBrowser.Nodes['pga_schedule'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*** IMPORTS FROM imports-loader ***/
var pgadmin = pgadmin || {};
pgadmin.dashboard = __webpack_require__(269);
var pgadmin = pgadmin || {};
pgadmin.tools = {};
pgadmin.tools.user_management = __webpack_require__(273);
var pgadmin = pgadmin || {};
pgadmin.browser = {};
pgadmin.browser.object_statistics = __webpack_require__(274);
var pgadmin = pgadmin || {};
pgadmin.browser = {};
pgadmin.browser.object_depends = __webpack_require__(276);
var pgadmin = pgadmin || {};
pgadmin.browser = {};
pgadmin.browser.object_sql = __webpack_require__(277);
var pgadmin = pgadmin || {};
pgadmin.browser = {};
pgadmin.browser.bgprocess = __webpack_require__(278);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.server_group = __webpack_require__(279);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.server = __webpack_require__(193);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.database = __webpack_require__(280);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.role = __webpack_require__(281);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.cast = __webpack_require__(282);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.tablespace = __webpack_require__(283);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.resource_group = __webpack_require__(284);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.event_trigger = __webpack_require__(285);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.extension = __webpack_require__(286);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.language = __webpack_require__(287);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.foreign_data_wrapper = __webpack_require__(288);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.foreign_server = __webpack_require__(289);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.user_mapping = __webpack_require__(290);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.schema = __webpack_require__(291);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.catalog = __webpack_require__(292);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.catalog_object = __webpack_require__(293);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.collation = __webpack_require__(294);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.domain = __webpack_require__(295);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.domain_constraints = __webpack_require__(296);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.foreign_table = __webpack_require__(297);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.fts_configuration = __webpack_require__(298);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.fts_dictionary = __webpack_require__(299);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.fts_parser = __webpack_require__(300);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.fts_template = __webpack_require__(301);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.function = __webpack_require__(196);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.procedure = __webpack_require__(302);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.edbfunc = __webpack_require__(197);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.edbproc = __webpack_require__(303);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.edbvar = __webpack_require__(304);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.trigger_function = __webpack_require__(305);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.package = __webpack_require__(306);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.sequence = __webpack_require__(307);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.synonym = __webpack_require__(308);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.type = __webpack_require__(309);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.rule = __webpack_require__(198);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.index = __webpack_require__(310);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.trigger = __webpack_require__(311);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.catalog_object_column = __webpack_require__(312);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.view = __webpack_require__(313);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.mview = __webpack_require__(314);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.table = __webpack_require__(315);
var pgadmin = pgadmin || {};
pgadmin.node = {};
pgadmin.node.partition = __webpack_require__(323);

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(8), __webpack_require__(3), __webpack_require__(29), __webpack_require__(161), __webpack_require__(30)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, alertify, pgAdmin, CodeMirror, sqlEditorUtils) {
  // Some scripts do export their object in the window only.
  // Generally the one, which do no have AMD support.
  var wcDocker = window.wcDocker,
      pgBrowser = pgAdmin.Browser;

  /* Return back, this has been called more than once */
  if (pgAdmin.DataGrid) return pgAdmin.DataGrid;

  pgAdmin.DataGrid = {
    init: function init() {
      if (this.initialized) return;
      this.initialized = true;
      this.title_index = 1;

      this.spinner_el = '<div class="wcLoadingContainer">' + '<div class="wcLoadingBackground"></div>' + '<div class="wcLoadingIconContainer">' + '<i class="wcLoadingIcon fa fa-spinner fa-pulse"></i>' + '</div>' + '</div>';
      // Define list of nodes on which view data option appears
      var supported_nodes = ['table', 'view', 'mview', 'foreign-table', 'catalog_object', 'partition'],


      /* Enable/disable View data menu in tools based
       * on node selected. if selected node is present
       * in supported_nodes, menu will be enabled
       * otherwise disabled.
       */
      view_menu_enabled = function view_menu_enabled(obj) {
        if (!_.isUndefined(obj) && !_.isNull(obj)) return _.indexOf(supported_nodes, obj._type) !== -1 ? true : false;else return false;
      },


      /* Enable/disable Query tool menu in tools based
       * on node selected. if selected node is present
       * in unsupported_nodes, menu will be disabled
       * otherwise enabled.
       */
      query_tool_menu_enabled = function query_tool_menu_enabled(obj) {
        if (!_.isUndefined(obj) && !_.isNull(obj)) {
          if (_.indexOf(pgAdmin.unsupported_nodes, obj._type) == -1) {
            if (obj._type == 'database' && obj.allowConn) return true;else if (obj._type != 'database') return true;else return false;
          } else {
            return false;
          }
        } else {
          return false;
        }
      };

      // Define the nodes on which the menus to be appear
      var menus = [{
        name: 'query_tool', module: this, applies: ['tools'],
        callback: 'show_query_tool', enable: query_tool_menu_enabled,
        priority: 1, label: gettext('Query Tool'),
        icon: 'fa fa-bolt'
      }];

      // Create context menu
      for (var idx = 0; idx < supported_nodes.length; idx++) {
        menus.push({
          name: 'view_all_rows_context_' + supported_nodes[idx],
          node: supported_nodes[idx], module: this, data: { mnuid: 3 },
          applies: ['context', 'object'], callback: 'show_data_grid', enable: view_menu_enabled,
          category: 'view_data', priority: 101, label: gettext('All Rows')
        }, {
          name: 'view_first_100_rows_context_' + supported_nodes[idx],
          node: supported_nodes[idx], module: this, data: { mnuid: 1 },
          applies: ['context', 'object'], callback: 'show_data_grid', enable: view_menu_enabled,
          category: 'view_data', priority: 102, label: gettext('First 100 Rows')
        }, {
          name: 'view_last_100_rows_context_' + supported_nodes[idx],
          node: supported_nodes[idx], module: this, data: { mnuid: 2 },
          applies: ['context', 'object'], callback: 'show_data_grid', enable: view_menu_enabled,
          category: 'view_data', priority: 103, label: gettext('Last 100 Rows')
        }, {
          name: 'view_filtered_rows_context_' + supported_nodes[idx],
          node: supported_nodes[idx], module: this, data: { mnuid: 4 },
          applies: ['context', 'object'], callback: 'show_filtered_row', enable: view_menu_enabled,
          category: 'view_data', priority: 104, label: gettext('Filtered Rows...')
        });
      }

      pgAdmin.Browser.add_menu_category('view_data', gettext('View/Edit Data'), 100, 'fa fa-th');
      pgAdmin.Browser.add_menus(menus);

      // Creating a new pgAdmin.Browser frame to show the data.
      var dataGridFrameType = new pgAdmin.Browser.Frame({
        name: 'frm_datagrid',
        showTitle: true,
        isCloseable: true,
        isPrivate: true,
        url: 'about:blank'
      });

      // Load the newly created frame
      dataGridFrameType.load(pgBrowser.docker);
    },

    // This is a callback function to show data when user click on menu item.
    show_data_grid: function show_data_grid(data, i) {
      var self = this,
          d = pgAdmin.Browser.tree.itemData(i);
      if (d === undefined) {
        alertify.alert('Data Grid Error', 'No object selected.');
        return;
      }

      // Get the parent data from the tree node hierarchy.
      var node = pgBrowser.Nodes[d._type],
          parentData = node.getTreeNodeHierarchy(i);

      // If server, database or schema is undefined then return from the function.
      if (parentData.server === undefined || parentData.database === undefined) {
        return;
      }
      // If schema, view, catalog object all are undefined then return from the function.
      if (parentData.schema === undefined && parentData.view === undefined && parentData.catalog === undefined) {
        return;
      }

      var nsp_name = '';

      if (parentData.schema != undefined) {
        nsp_name = parentData.schema.label;
      } else if (parentData.view != undefined) {
        nsp_name = parentData.view.label;
      } else if (parentData.catalog != undefined) {
        nsp_name = parentData.catalog.label;
      }
      var url_params = {
        'cmd_type': data.mnuid,
        'obj_type': d._type,
        'sid': parentData.server._id,
        'did': parentData.database._id,
        'obj_id': d._id
      };

      var baseUrl = url_for('datagrid.initialize_datagrid', url_params);
      var grid_title = parentData.server.label + ' - ' + parentData.database.label + ' - ' + nsp_name + '.' + d.label;

      // Initialize the data grid.
      self.initialize_data_grid(baseUrl, grid_title, '', parentData.server.server_type);
    },

    // This is a callback function to show filtered data when user click on menu item.
    show_filtered_row: function show_filtered_row(data, i) {
      var self = this,
          d = pgAdmin.Browser.tree.itemData(i);
      if (d === undefined) {
        alertify.alert('Data Grid Error', 'No object selected.');
        return;
      }

      // Get the parent data from the tree node hierarchy.
      var node = pgBrowser.Nodes[d._type],
          parentData = node.getTreeNodeHierarchy(i);

      // If server or database is undefined then return from the function.
      if (parentData.server === undefined || parentData.database === undefined) {
        return;
      }

      // If schema, view, catalog object all are undefined then return from the function.
      if (parentData.schema === undefined && parentData.view === undefined && parentData.catalog === undefined) {
        return;
      }

      var nsp_name = '';

      if (parentData.schema != undefined) {
        nsp_name = parentData.schema.label;
      } else if (parentData.view != undefined) {
        nsp_name = parentData.view.label;
      } else if (parentData.catalog != undefined) {
        nsp_name = parentData.catalog.label;
      }

      var url_params = {
        'cmd_type': data.mnuid,
        'obj_type': d._type,
        'sid': parentData.server._id,
        'did': parentData.database._id,
        'obj_id': d._id

      };

      var baseUrl = url_for('datagrid.initialize_datagrid', url_params);

      // Create url to validate the SQL filter
      var validateUrl = url_for('datagrid.filter_validate', {
        'sid': url_params['sid'],
        'did': url_params['did'],
        'obj_id': url_params['obj_id']
      });
      var grid_title = parentData.server.label + '-' + parentData.database.label + '-' + nsp_name + '.' + d.label;

      // Create filter dialog using alertify
      if (!alertify.filterDialog) {
        alertify.dialog('filterDialog', function factory() {
          return {
            main: function main(title, message, baseUrl, validateUrl) {
              this.set('title', title);
              this.message = message;
              this.baseUrl = baseUrl;
              this.validateUrl = validateUrl;
            },

            setup: function setup() {
              return {
                buttons: [{ text: "OK", className: "btn btn-primary" }, { text: "Cancel", className: "btn btn-danger" }],
                options: { modal: 0, resizable: false, maximizable: false, pinnable: false }
              };
            },

            build: function build() {},
            prepare: function prepare() {
              var $content = $(this.message),
                  $sql_filter = $content.find('#sql_filter');

              this.setContent($content.get(0));

              // Apply CodeMirror to filter text area.
              this.filter_obj = codemirror.fromTextArea($sql_filter.get(0), {
                lineNumbers: true,
                indentUnit: 4,
                mode: "text/x-pgsql",
                extraKeys: pgBrowser.editor_shortcut_keys,
                tabSize: pgBrowser.editor_options.tabSize,
                lineWrapping: pgAdmin.Browser.editor_options.wrapCode,
                autoCloseBrackets: pgAdmin.Browser.editor_options.insert_pair_brackets,
                matchBrackets: pgAdmin.Browser.editor_options.brace_matching
              });
            },

            callback: function callback(closeEvent) {

              if (closeEvent.button.text == gettext("OK")) {
                var sql = this.filter_obj.getValue();
                var that = this;

                // Make ajax call to include the filter by selection
                $.ajax({
                  url: that.validateUrl,
                  method: 'POST',
                  async: false,
                  contentType: "application/json",
                  data: JSON.stringify(sql),
                  success: function success(res) {
                    if (res.data.status) {
                      // Initialize the data grid.
                      self.initialize_data_grid(that.baseUrl, grid_title, sql, parentData.server.server_type);
                    } else {
                      alertify.alert('Validation Error', res.data.result);
                    }
                  },
                  error: function error(e) {
                    alertify.alert('Validation Error', e);
                  }
                });
              }
            }
          };
        });
      }

      var content = '';
      $.get(url_for('datagrid.filter'), function (data) {
        alertify.filterDialog('Data Filter', data, baseUrl, validateUrl).resizeTo(600, 400);
      });
    },

    get_panel_title: function get_panel_title() {
      // Get the parent data from the tree node hierarchy.
      var tree = pgAdmin.Browser.tree,
          selected_item = tree.selected(),
          item_data = tree.itemData(selected_item);
      var self = this;

      var node = pgBrowser.Nodes[item_data._type],
          parentData = node.getTreeNodeHierarchy(selected_item);

      // If server, database is undefined then return from the function.
      if (parentData.server === undefined) {
        return;
      }
      // If Database is not available then use default db
      var db_label = parentData.database ? parentData.database.label : parentData.server.db;

      var grid_title = db_label + ' on ' + parentData.server.user.name + '@' + parentData.server.label;
      return grid_title;
    },

    initialize_data_grid: function initialize_data_grid(baseUrl, grid_title, sql_filter, server_type) {
      var self = this;
      self.grid_title = grid_title;

      /* Ajax call to initialize the edit grid, which creates
       * an asynchronous connection and create appropriate query
       * for the selected node.
       */
      $.ajax({
        url: baseUrl,
        method: 'POST',
        dataType: 'json',
        contentType: "application/json",
        data: JSON.stringify(sql_filter),
        success: function success(res) {

          /* On successfully initialization find the dashboard panel,
           * create new panel and add it to the dashboard panel.
           */
          var url_params = {
            'trans_id': res.data.gridTransId,
            'is_query_tool': 'false',
            'editor_title': encodeURIComponent(self.grid_title)
          };

          var baseUrl = url_for('datagrid.panel', url_params) + "?query_url=&server_type=" + encodeURIComponent(server_type);
          var grid_title = gettext('Edit Data - ') + self.grid_title;
          if (res.data.newBrowserTab) {
            var newWin = window.open(baseUrl, '_blank');

            // add a load listener to the window so that the title gets changed on page load
            newWin.addEventListener("load", function () {
              newWin.document.title = grid_title;
            });
          } else {
            var propertiesPanel = pgBrowser.docker.findPanels('properties');
            var dataGridPanel = pgBrowser.docker.addPanel('frm_datagrid', wcDocker.DOCK.STACKED, propertiesPanel[0]);

            // Set panel title and icon
            dataGridPanel.title('<span title="' + grid_title + '">' + grid_title + '</span>');
            dataGridPanel.icon('fa fa-bolt');
            dataGridPanel.focus();

            // Listen on the panel closed event.
            dataGridPanel.on(wcDocker.EVENT.CLOSED, function () {
              $.ajax({
                url: url_for('datagrid.close', { 'trans_id': res.data.gridTransId }),
                method: 'GET'
              });
            });

            var openDataGridURL = function openDataGridURL(j) {
              // add spinner element
              $(j).data('embeddedFrame').$container.append(self.spinner_el);
              setTimeout(function () {
                var frameInitialized = $(j).data('frameInitialized');
                if (frameInitialized) {
                  var frame = $(j).data('embeddedFrame');
                  if (frame) {
                    frame.openURL(baseUrl);
                    frame.$container.find('.wcLoadingContainer').hide(1);
                  }
                } else {
                  openDataGridURL(j);
                }
              }, 100);
            };

            openDataGridURL(dataGridPanel);
          }
        },
        error: function error(e) {
          alertify.alert('SQL Tool Initialize Error');
        }
      });
    },

    // This is a callback function to show query tool when user click on menu item.
    show_query_tool: function show_query_tool(url, i, panel_title) {
      var self = this,
          sURL = url || '',
          panel_title = panel_title || '',
          d = pgAdmin.Browser.tree.itemData(i);
      if (d === undefined) {
        alertify.alert('Query tool Error', 'No object selected.');
        return;
      }

      // Get the parent data from the tree node hierarchy.
      var node = pgBrowser.Nodes[d._type],
          parentData = node.getTreeNodeHierarchy(i);

      // If server, database is undefined then return from the function.
      if (parentData.server === undefined) {
        return;
      }

      var url_params = {
        'sid': parentData.server._id
      };
      var url_endpoint = 'datagrid.initialize_query_tool';
      // If database not present then use Maintenance database
      // We will handle this at server side
      if (parentData.database) {
        url_params['did'] = parentData.database._id;
        url_endpoint = 'datagrid.initialize_query_tool_with_did';
      }
      var baseUrl = url_for(url_endpoint, url_params);

      $.ajax({
        url: baseUrl,
        method: 'POST',
        dataType: 'json',
        contentType: "application/json",
        success: function success(res) {
          var grid_title = self.get_panel_title();
          // Open the panel if frame is initialized
          var url_params = {
            'trans_id': res.data.gridTransId,
            'is_query_tool': 'true',
            'editor_title': encodeURIComponent(grid_title)
          };

          var baseUrl = url_for('datagrid.panel', url_params) + '?' + "query_url=" + encodeURI(sURL) + "&server_type=" + encodeURIComponent(parentData.server.server_type);

          // Create title for CREATE/DELETE scripts
          if (panel_title) {
            panel_title = sqlEditorUtils.capitalizeFirstLetter(panel_title) + ' script';
          } else {
            panel_title = gettext('Query - ') + grid_title;
          }

          if (res.data.newBrowserTab) {
            var newWin = window.open(baseUrl, '_blank');

            // add a load listener to the window so that the title gets changed on page load
            newWin.addEventListener("load", function () {
              newWin.document.title = panel_title;
            });
          } else {
            /* On successfully initialization find the dashboard panel,
             * create new panel and add it to the dashboard panel.
             */
            var propertiesPanel = pgBrowser.docker.findPanels('properties');
            var queryToolPanel = pgBrowser.docker.addPanel('frm_datagrid', wcDocker.DOCK.STACKED, propertiesPanel[0]);

            // Set panel title and icon
            queryToolPanel.title('<span title="' + panel_title + '">' + panel_title + '</span>');
            queryToolPanel.icon('fa fa-bolt');
            queryToolPanel.focus();

            // Listen on the panel closed event.
            queryToolPanel.on(wcDocker.EVENT.CLOSED, function () {
              $.ajax({
                url: url_for('datagrid.close', { 'trans_id': res.data.gridTransId }),
                method: 'GET'
              });
            });

            var openQueryToolURL = function openQueryToolURL(j) {
              // add spinner element
              $(j).data('embeddedFrame').$container.append(pgAdmin.DataGrid.spinner_el);
              setTimeout(function () {
                var frameInitialized = $(j).data('frameInitialized');
                if (frameInitialized) {
                  var frame = $(j).data('embeddedFrame');
                  if (frame) {
                    frame.openURL(baseUrl);
                    frame.$container.find('.wcLoadingContainer').delay(1000).hide(1);
                  }
                } else {
                  openQueryToolURL(j);
                }
              }, 100);
            };

            openQueryToolURL(queryToolPanel);
          }
        },
        error: function error(e) {
          alertify.alert(gettext("Query Tool Initialize Error"));
        }
      });
    }
  };

  return pgAdmin.DataGrid;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(2), __webpack_require__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(3), __webpack_require__(10), __webpack_require__(13), __webpack_require__(270), __webpack_require__(17), __webpack_require__(159), __webpack_require__(6), __webpack_require__(188), __webpack_require__(30)], __WEBPACK_AMD_DEFINE_RESULT__ = function (url_for, gettext, r, $, _, pgAdmin, Backbone, Backgrid, Flotr, alertify) {

    var wcDocker = window.wcDocker,
        pgBrowser = pgAdmin.Browser;

    /* Return back, this has been called more than once */
    if (pgAdmin.Dashboard) return;

    var dashboardVisible = true,
        cancel_query_url = '',
        is_super_user = false,
        current_user,
        maintenance_database,
        is_server_dashboard = false,
        is_database_dashboard = false;

    // Custom BackGrid cell, Responsible for cancelling active sessions
    var cancelQueryCell = Backgrid.Extension.DeleteCell.extend({
        render: function render() {
            this.$el.empty();
            this.$el.html("<i class='fa fa-times-circle' data-toggle='tooltip' " + "title='" + gettext('Cancel the active query') + "'></i>");
            this.delegateEvents();
            return this;
        },
        deleteRow: function deleteRow(e) {
            var self = this;
            e.preventDefault();

            var canDeleteRow = Backgrid.callByNeed(self.column.get('canDeleteRow'), self.column, self.model);
            // If we are not allowed to cancel the query, return from here
            if (!canDeleteRow) return;

            // This will refresh the grid
            var refresh_grid = function refresh_grid() {
                if (is_server_dashboard) {
                    $('#btn_server_activity_refresh').click();
                } else if (is_database_dashboard) {
                    $('#btn_database_activity_refresh').click();
                }
            };

            var title = gettext('Cancel Active Query?'),
                txtConfirm = gettext('Are you sure you wish to cancel the active query?');

            alertify.confirm(title, txtConfirm, function (evt) {
                $.ajax({
                    url: cancel_query_url + self.model.get('pid'),
                    type: 'DELETE',
                    success: function success(res) {
                        if (res == gettext('Success')) {
                            alertify.success(gettext('Active query cancelled successfully.'));
                            refresh_grid();
                        } else {
                            alertify.error(gettext('An error occurred whilst cancelling the active query.'));
                        }
                    },
                    error: function error(xhr, status, _error) {
                        try {
                            var err = $.parseJSON(xhr.responseText);
                            if (err.success == 0) {
                                alertify.error(err.errormsg);
                            }
                        } catch (e) {}
                    }
                });
            }, function (evt) {
                return true;
            });
        }
    });

    // Subnode Cell, which will display subnode control
    var SessionDetailsCell = Backgrid.Extension.ObjectCell.extend({
        enterEditMode: function enterEditMode() {
            // Notify that we are about to enter in edit mode for current cell.
            this.model.trigger("enteringEditMode", [this]);

            Backgrid.Cell.prototype.enterEditMode.apply(this, arguments);
            /* Make sure - we listen to the click event */
            this.delegateEvents();
            var editable = Backgrid.callByNeed(this.column.editable(), this.column, this.model);

            if (editable) {
                this.$el.html("<i class='fa fa-caret-down subnode-edit-in-process'></i>");
                this.model.trigger("pg-sub-node:opened", this.model, this);
            }
        },
        render: function render() {
            this.$el.empty();
            this.$el.html("<i class='fa fa-caret-right' data-toggle='tooltip' " + "title='" + gettext('View the active session details') + "'></i>");
            this.delegateEvents();
            if (this.grabFocus) this.$el.focus();
            return this;
        }
    });

    // Subnode Model
    var ActiveQueryDetailsModel = Backbone.Model.extend({
        defaults: {
            version: null /* Postgres version */
        },
        schema: [{
            id: 'backend_type', label: gettext('Backend type'),
            type: 'text', editable: true, disabled: true,
            group: gettext('Details'),
            visible: function visible(m) {
                return this.version >= 100000;
            }
        }, {
            id: 'query_start', label: gettext('Query started at'),
            type: 'text', editable: false, disabled: true,
            group: gettext('Details')
        }, {
            id: 'state_change', label: gettext('Last state changed at'),
            type: 'text', editable: true, disabled: true,
            group: gettext('Details')
        }, {
            id: 'query', label: gettext('SQL'),
            type: 'text', editable: true, disabled: true,
            control: Backform.SqlFieldControl,
            group: gettext('Details')
        }]
    });

    pgAdmin.Dashboard = {
        init: function init() {
            if (this.initialized) return;

            this.initialized = true;

            // Bind the Dashboard object with the 'object_selected' function
            var selected = this.object_selected.bind(this);
            var disconnected = this.object_disconnected.bind(this);

            // Listen for selection of any of object
            pgBrowser.Events.on('pgadmin-browser:tree:selected', selected);

            // Listen for server disconnected event
            pgBrowser.Events.on('pgadmin:server:disconnect', disconnected);

            // Load the default welcome dashboard
            var url = url_for('dashboard.index');

            var dashboardPanel = pgBrowser.panels['dashboard'].panel;
            if (dashboardPanel) {
                var div = dashboardPanel.layout().scene().find('.pg-panel-content');

                if (div) {
                    $.ajax({
                        url: url,
                        type: "GET",
                        dataType: "html",
                        success: function success(data) {
                            $(div).html(data);
                        },
                        error: function error(xhr, status) {
                            $(div).html('<div class="alert alert-danger pg-panel-message" role="alert">' + gettext('An error occurred whilst loading the dashboard.') + '</div>');
                        }
                    });

                    // Cache the current IDs for next time
                    $(dashboardPanel).data('sid', -1);
                    $(dashboardPanel).data('did', -1);
                }
            }
        },

        // Handle Server Disconnect
        object_disconnected: function object_disconnected(obj) {
            this.object_selected(obj.item, obj.data, pgBrowser.Nodes[obj.data._type]);
        },

        // Handle treeview clicks
        object_selected: function object_selected(item, itemData, node) {
            if (itemData && itemData._type && dashboardVisible) {
                var treeHierarchy = node.getTreeNodeHierarchy(item),
                    url = url_for('dashboard.index'),
                    sid = -1,
                    did = -1,
                    b = pgAdmin.Browser,
                    m = b && b.Nodes[itemData._type];

                cancel_query_url = url_for('dashboard.index') + 'cancel_query/';

                // Check if user is super user
                var server = treeHierarchy['server'];
                maintenance_database = server && server.db || null;

                if (server && server.user && server.user.is_superuser) {
                    is_super_user = true;
                } else {
                    is_super_user = false;
                    // Set current user
                    current_user = server && server.user ? server.user.name : null;
                }

                if (m && m.dashboard) {
                    if (_.isFunction(m.dashboard)) {
                        url = m.dashboard.apply(item, itemData, node, treeHierarchy);
                    } else {
                        url = m.dashboard;
                    }
                } else {
                    if ('database' in treeHierarchy) {
                        sid = treeHierarchy.server._id;
                        did = treeHierarchy.database._id;
                        is_server_dashboard = false;
                        is_database_dashboard = true;
                        url += sid + '/' + did;
                        cancel_query_url += sid + '/' + did + '/';
                    } else if ('server' in treeHierarchy) {
                        sid = treeHierarchy.server._id;
                        is_server_dashboard = true;
                        is_database_dashboard = false;
                        url += sid;
                        cancel_query_url += sid + '/';
                    }
                }

                var dashboardPanel = pgBrowser.panels['dashboard'].panel;
                if (dashboardPanel) {
                    var div = dashboardPanel.layout().scene().find('.pg-panel-content');

                    if (div) {
                        if (itemData.connected || _.isUndefined(itemData.connected)) {
                            // Avoid unnecessary reloads
                            if (url != $(dashboardPanel).data('dashboard_url') || url == $(dashboardPanel).data('dashboard_url') && $(dashboardPanel).data('server_status') == false) {
                                // Clear out everything so any existing timers die off
                                $(div).empty();

                                $.ajax({
                                    url: url,
                                    type: "GET",
                                    dataType: "html",
                                    success: function success(data) {
                                        $(div).html(data);
                                    },
                                    error: function error(xhr, status) {
                                        $(div).html('<div class="alert alert-danger pg-panel-message" role="alert">' + gettext('An error occurred whilst loading the dashboard.') + '</div>');
                                    }
                                });
                                $(dashboardPanel).data('server_status', true);
                            }
                        } else {
                            $(div).empty();
                            $(div).html('<div class="alert alert-info pg-panel-message" role="alert">' + gettext('Please connect to the selected server to view the dashboard.') + '</div>');
                            $(dashboardPanel).data('server_status', false);
                        }
                        // Cache the current IDs for next time
                        $(dashboardPanel).data('dashboard_url', url);
                    }
                }
            }
        },

        // Render a chart
        render_chart: function render_chart(container, data, dataset, sid, did, url, options, counter, refresh) {

            // Data format:
            // [
            //     { data: [[0, y0], [1, y1]...], label: 'Label 1', [options] },
            //     { data: [[0, y0], [1, y1]...], label: 'Label 2', [options] },
            //     { data: [[0, y0], [1, y1]...], label: 'Label 3', [options] }
            // ]

            if (!dashboardVisible) return;

            var y = 0;
            if (dataset.length == 0) {
                if (counter == true) {
                    // Have we stashed initial values?
                    if (_.isUndefined($(container).data('counter_previous_vals'))) {
                        $(container).data('counter_previous_vals', data[0]);
                    } else {
                        // Create the initial data structure
                        for (var x in data[0]) {
                            dataset.push({ 'data': [[0, data[0][x] - $(container).data('counter_previous_vals')[x]]], 'label': x });
                        }
                    }
                } else {
                    // Create the initial data structure
                    for (var x in data[0]) {
                        dataset.push({ 'data': [[0, data[0][x]]], 'label': x });
                    }
                }
            } else {
                for (var x in data[0]) {
                    // Push new values onto the existing data structure
                    // If this is a counter stat, we need to subtract the previous value
                    if (counter == false) {
                        dataset[y]['data'].unshift([0, data[0][x]]);
                    } else {
                        // Store the current value, minus the previous one we stashed.
                        // It's possible the tab has been reloaded, in which case out previous values are gone
                        if (_.isUndefined($(container).data('counter_previous_vals'))) return;

                        dataset[y]['data'].unshift([0, data[0][x] - $(container).data('counter_previous_vals')[x]]);
                    }

                    // Reset the time index to get a proper scrolling display
                    for (var z = 0; z < dataset[y]['data'].length; z++) {
                        dataset[y]['data'][z][0] = z;
                    }

                    y++;
                }
                $(container).data('counter_previous_vals', data[0]);
            }

            // Remove uneeded elements
            for (x = 0; x < dataset.length; x++) {
                // Remove old data points
                if (dataset[x]['data'].length > 101) {
                    dataset[x]['data'].pop();
                }
            }

            // Draw Graph, if the container still exists and has a size
            var dashboardPanel = pgBrowser.panels['dashboard'].panel;
            var div = dashboardPanel.layout().scene().find('.pg-panel-content');
            if ($(div).find(container).length) {
                // Exists?
                if (container.clientHeight > 0 && container.clientWidth > 0) {
                    // Not hidden?
                    Flotr.draw(container, dataset, options);
                }
            } else {
                return;
            }

            // Animate
            var setTimeoutFunc = function setTimeoutFunc() {
                var path = url + sid;
                if (did != -1) {
                    path += '/' + did;
                }
                $.ajax({
                    url: path,
                    type: "GET",
                    dataType: "html",
                    success: function success(resp) {
                        $(container).removeClass('graph-error');
                        data = JSON.parse(resp);
                        pgAdmin.Dashboard.render_chart(container, data, dataset, sid, did, url, options, counter, refresh);
                    },
                    error: function error(xhr, status, msg) {
                        var err = $.parseJSON(xhr.responseText),
                            msg = err.errormsg,
                            cls;
                        // If we get a 428, it means the server isn't connected
                        if (xhr.status == 428) {
                            if (_.isUndefined(msg) || _.isNull(msg)) {
                                msg = gettext('Please connect to the selected server to view the graph.');
                            }
                            cls = 'info';
                        } else {
                            msg = gettext('An error occurred whilst rendering the graph.');
                            cls = 'danger';
                        }

                        $(container).addClass('graph-error');
                        $(container).html('<div class="alert alert-' + cls + ' pg-panel-message" role="alert">' + msg + '</div>');

                        // Try again...
                        if (container.clientHeight > 0 && container.clientWidth > 0) {
                            setTimeout(setTimeoutFunc, refresh * 1000);
                        }
                    }
                });
            };

            setTimeout(setTimeoutFunc, refresh * 1000);
        },

        // Handler function to support the "Add Server" link
        add_new_server: function add_new_server() {
            if (pgBrowser && pgBrowser.tree) {
                var i = pgBrowser.tree.selected().length != 0 ? pgBrowser.tree.selected() : pgBrowser.tree.first(null, false),
                    serverModule = __webpack_require__(193),
                    itemData = pgBrowser.tree.itemData(i);

                while (itemData && itemData._type != "server_group") {
                    i = pgBrowser.tree.next(i);
                    itemData = pgBrowser.tree.itemData(i);
                }

                if (!itemData) {
                    return;
                }

                if (serverModule) {
                    serverModule.callbacks.show_obj_properties.apply(serverModule, [{ action: 'create' }, i]);
                }
            }
        },

        // Render a grid
        render_grid: function render_grid(container, sid, did, url, columns) {
            var Datum = Backbone.Model.extend({});

            var path = url + sid;
            if (did != -1) {
                path += '/' + did;
            }

            var Data = Backbone.Collection.extend({
                model: Datum,
                url: path,
                mode: "client"
            });

            var data = new Data();

            // Set up the grid
            var grid = new Backgrid.Grid({
                columns: columns,
                collection: data,
                className: "backgrid table-bordered presentation table backgrid-striped"
            });

            // Render the grid
            $(container).append(grid.render().el);

            // Initialize a client-side filter to filter on the client
            // mode pageable collection's cache.
            var filter = new Backgrid.Extension.ClientSideFilter({
                collection: data
            });

            // Render the filter
            $('#' + container.id + '_filter').before(filter.render().el);

            // Add some space to the filter and move it to the right
            $(filter.el).css({ float: "right", margin: "5px", "margin-right": "2px", "margin-top": "3px" });

            // Stash objects for future use
            $(container).data('data', data);
            $(container).data('grid', grid);
            $(container).data('filter', filter);
        },

        // Render the data in a grid
        render_grid_data: function render_grid_data(container) {
            var data = $(container).data('data'),
                grid = $(container).data('grid'),
                filter = $(container).data('filter');

            if (_.isUndefined(data)) {
                return null;
            }

            data.fetch({
                reset: true,
                success: function success() {
                    // If we're showing an error, remove it, and replace the grid & filter
                    if ($(container).hasClass('grid-error')) {
                        $(container).removeClass('grid-error');
                        $(container).html(grid.render().el);
                        $(filter.el).show();
                    }

                    // Re-apply search criteria
                    filter.search();
                },
                error: function error(model, xhr, options) {
                    var err = $.parseJSON(xhr.responseText),
                        msg = err.errormsg,
                        cls;
                    // If we get a 428, it means the server isn't connected
                    if (xhr.status == 428) {
                        if (_.isUndefined(msg) || _.isNull(msg)) {
                            msg = gettext('Please connect to the selected server to view the table.');
                        }
                        cls = 'info';
                    } else {
                        msg = gettext('An error occurred whilst rendering the table.');
                        cls = 'danger';
                    }

                    // Replace the content with the error, if not already present. Always update the message
                    if (!$(container).hasClass('grid-error')) {
                        $(filter.el).hide();
                        $(container).addClass('grid-error');
                    }

                    $(container).html('<div class="alert alert-' + cls + ' pg-panel-message" role="alert">' + msg + '</div>');

                    // Try again
                    setTimeout(function () {
                        pgAdmin.Dashboard.render_grid_data(container, data);
                    }, 5000);
                }
            });
        },

        // Rock n' roll on the server dashboard
        init_server_dashboard: function init_server_dashboard(sid, version, session_stats_refresh, tps_stats_refresh, ti_stats_refresh, to_stats_refresh, bio_stats_refresh) {
            var div_sessions = $('.dashboard-container').find('#graph-sessions')[0];
            var div_tps = $('.dashboard-container').find('#graph-tps')[0];
            var div_ti = $('.dashboard-container').find('#graph-ti')[0];
            var div_to = $('.dashboard-container').find('#graph-to')[0];
            var div_bio = $('.dashboard-container').find('#graph-bio')[0];
            var div_server_activity = $('.dashboard-container').find('#server_activity');
            var div_server_locks = $('.dashboard-container').find('#server_locks');
            var div_server_prepared = $('.dashboard-container').find('#server_prepared');
            var div_server_config = $('.dashboard-container').find('#server_config');
            var dataset_sessions = [];
            var data_sessions = [];
            var dataset_tps = [];
            var data_tps = [];
            var dataset_ti = [];
            var data_ti = [];
            var dataset_to = [];
            var data_to = [];
            var dataset_bio = [];
            var data_bio = [];

            // Fake DB ID
            var did = -1;

            var options_line = {
                parseFloat: false,
                xaxis: {
                    min: 100,
                    max: 0,
                    autoscale: 0
                },
                yaxis: {
                    autoscale: 1
                },
                legend: {
                    position: 'nw',
                    backgroundColor: '#D2E8FF'
                }
            };

            var server_activity_columns = [{
                name: "pid",
                label: gettext('PID'),
                editable: false,
                cell: "string"
            }, {
                name: "datname",
                label: gettext('Database'),
                editable: false,
                cell: "string"
            }, {
                name: "usename",
                label: gettext('User'),
                editable: false,
                cell: "string"
            }, {
                name: "application_name",
                label: gettext('Application'),
                editable: false,
                cell: "string"
            }, {
                name: "client_addr",
                label: gettext('Client'),
                editable: false,
                cell: "string"
            }, {
                name: "backend_start",
                label: gettext('Backend start'),
                editable: false,
                cell: "string"
            }, {
                name: "state",
                label: gettext('State'),
                editable: false,
                cell: "string"
            }];

            if (version < 90600) {
                server_activity_columns = server_activity_columns.concat([{
                    name: "waiting",
                    label: gettext('Waiting?'),
                    editable: false,
                    cell: "string"
                }]);
            } else {
                server_activity_columns = server_activity_columns.concat([{
                    name: "wait_event",
                    label: gettext('Wait Event'),
                    editable: false,
                    cell: "string"
                }, {
                    name: "blocking_pids",
                    label: gettext('Blocking PIDs'),
                    editable: false,
                    cell: "string"
                }]);
            }

            var newActiveQueryDetailsModel = new ActiveQueryDetailsModel();

            var subNodeFieldsModel = Backform.generateViewSchema(null, newActiveQueryDetailsModel, 'create', null, null, true);

            // Add version to each field
            _.each(subNodeFieldsModel[0].fields, function (obj) {
                obj['version'] = version;
            });

            // Add cancel active query button
            server_activity_columns.unshift({
                name: "pg-backform-expand", label: "",
                cell: SessionDetailsCell,
                cell_priority: -1,
                postgres_version: version,
                schema: subNodeFieldsModel
            });

            // Add cancel active query button
            server_activity_columns.unshift({
                name: "pg-backform-delete", label: "",
                cell: cancelQueryCell,
                editable: false, cell_priority: -1,
                canDeleteRow: pgAdmin.Dashboard.can_cancel_active_query,
                postgres_version: version
            });

            var server_locks_columns = [{
                name: "pid",
                label: gettext('PID'),
                editable: false,
                cell: "string"
            }, {
                name: "datname",
                label: gettext('Database'),
                editable: false,
                cell: "string"
            }, {
                name: "locktype",
                label: gettext('Lock type'),
                editable: false,
                cell: "string"
            }, {
                name: "relation",
                label: gettext('Target relation'),
                editable: false,
                cell: "string"
            }, {
                name: "page",
                label: gettext('Page'),
                editable: false,
                cell: "string"
            }, {
                name: "tuple",
                label: gettext('Tuple'),
                editable: false,
                cell: "string"
            }, {
                name: "virtualxid",
                label: gettext('vXID (target)'),
                editable: false,
                cell: "string"
            }, {
                name: "transactionid",
                label: gettext('XID (target)'),
                editable: false,
                cell: "string"
            }, {
                name: "classid",
                label: gettext('Class'),
                editable: false,
                cell: "string"
            }, {
                name: "objid",
                label: gettext('Object ID'),
                editable: false,
                cell: "string"
            }, {
                name: "virtualtransaction",
                label: gettext('vXID (owner)'),
                editable: false,
                cell: "string"
            }, {
                name: "mode",
                label: gettext('Mode'),
                editable: false,
                cell: "string"
            }, {
                name: "granted",
                label: gettext('Granted?'),
                editable: false,
                cell: "string"
            }];

            var server_prepared_columns = [{
                name: "git",
                label: gettext('Name'),
                editable: false,
                cell: "string"
            }, {
                name: "database",
                label: gettext('Database'),
                editable: false,
                cell: "string"
            }, {
                name: "Owner",
                label: gettext('Owner'),
                editable: false,
                cell: "string"
            }, {
                name: "transaction",
                label: gettext('XID'),
                editable: false,
                cell: "string"
            }, {
                name: "prepared",
                label: gettext('Prepared at'),
                editable: false,
                cell: "string"
            }];

            var server_config_columns = [{
                name: "name",
                label: gettext('Name'),
                editable: false,
                cell: "string"
            }, {
                name: "category",
                label: gettext('Category'),
                editable: false,
                cell: "string"
            }, {
                name: "setting",
                label: gettext('Setting'),
                editable: false,
                cell: "string"
            }, {
                name: "unit",
                label: gettext('Unit'),
                editable: false,
                cell: "string"
            }, {
                name: "short_desc",
                label: gettext('Description'),
                editable: false,
                cell: "string"
            }];

            // Render the graphs
            pgAdmin.Dashboard.render_chart(div_sessions, data_sessions, dataset_sessions, sid, did, url_for('dashboard.session_stats'), options_line, false, session_stats_refresh);
            pgAdmin.Dashboard.render_chart(div_tps, data_tps, dataset_tps, sid, did, url_for('dashboard.tps_stats'), options_line, true, tps_stats_refresh);
            pgAdmin.Dashboard.render_chart(div_ti, data_ti, dataset_ti, sid, did, url_for('dashboard.ti_stats'), options_line, true, ti_stats_refresh);
            pgAdmin.Dashboard.render_chart(div_to, data_to, dataset_to, sid, did, url_for('dashboard.to_stats'), options_line, true, to_stats_refresh);
            pgAdmin.Dashboard.render_chart(div_bio, data_bio, dataset_bio, sid, did, url_for('dashboard.bio_stats'), options_line, true, bio_stats_refresh);

            // To align subnode controls properly
            $(div_server_activity).addClass('pg-el-container');
            $(div_server_activity).attr('el', 'sm');

            // Render the tabs, but only get data for the activity tab for now
            pgAdmin.Dashboard.render_grid(div_server_activity, sid, did, url_for('dashboard.activity'), server_activity_columns);
            pgAdmin.Dashboard.render_grid(div_server_locks, sid, did, url_for('dashboard.locks'), server_locks_columns);
            pgAdmin.Dashboard.render_grid(div_server_prepared, sid, did, url_for('dashboard.prepared'), server_prepared_columns);
            pgAdmin.Dashboard.render_grid(div_server_config, sid, did, url_for('dashboard.config'), server_config_columns);

            pgAdmin.Dashboard.render_grid_data(div_server_activity);

            // (Re)render the appropriate tab
            $('a[data-toggle="tab"]').on('shown.bs.tab', function (e) {
                switch ($(e.target).attr('aria-controls')) {
                    case "tab_server_activity":
                        pgAdmin.Dashboard.render_grid_data(div_server_activity);
                        break;

                    case "tab_server_locks":
                        pgAdmin.Dashboard.render_grid_data(div_server_locks);
                        break;

                    case "tab_server_prepared":
                        pgAdmin.Dashboard.render_grid_data(div_server_prepared);
                        break;

                    case "tab_server_config":
                        pgAdmin.Dashboard.render_grid_data(div_server_config);
                        break;
                }
            });

            // Handle button clicks
            $("button").click(function (e) {
                switch (this.id) {
                    case "btn_server_activity_refresh":
                        pgAdmin.Dashboard.render_grid_data(div_server_activity);
                        break;

                    case "btn_server_locks_refresh":
                        pgAdmin.Dashboard.render_grid_data(div_server_locks);
                        break;

                    case "btn_server_prepared_refresh":
                        pgAdmin.Dashboard.render_grid_data(div_server_prepared);
                        break;

                    case "btn_server_config_refresh":
                        pgAdmin.Dashboard.render_grid_data(div_server_config);
                        break;
                }
            });
        },

        // Rock n' roll on the database dashboard
        init_database_dashboard: function init_database_dashboard(sid, did, version, session_stats_refresh, tps_stats_refresh, ti_stats_refresh, to_stats_refresh, bio_stats_refresh) {
            var div_sessions = document.getElementById('graph-sessions');
            var div_tps = document.getElementById('graph-tps');
            var div_ti = document.getElementById('graph-ti');
            var div_to = document.getElementById('graph-to');
            var div_bio = document.getElementById('graph-bio');
            var div_database_activity = document.getElementById('database_activity');
            var div_database_locks = document.getElementById('database_locks');
            var div_database_prepared = document.getElementById('database_prepared');
            var dataset_sessions = [];
            var data_sessions = [];
            var dataset_tps = [];
            var data_tps = [];
            var dataset_ti = [];
            var data_ti = [];
            var dataset_to = [];
            var data_to = [];
            var dataset_bio = [];
            var data_bio = [];

            var options_line = {
                parseFloat: false,
                xaxis: {
                    min: 100,
                    max: 0,
                    autoscale: 0
                },
                yaxis: {
                    autoscale: 1
                },
                legend: {
                    position: 'nw',
                    backgroundColor: '#D2E8FF'
                }
            };

            var database_activity_columns = [{
                name: "pid",
                label: gettext('PID'),
                editable: false,
                cell: "string"
            }, {
                name: "usename",
                label: gettext('User'),
                editable: false,
                cell: "string"
            }, {
                name: "application_name",
                label: gettext('Application'),
                editable: false,
                cell: "string"
            }, {
                name: "client_addr",
                label: gettext('Client'),
                editable: false,
                cell: "string"
            }, {
                name: "backend_start",
                label: gettext('Backend start'),
                editable: false,
                cell: "string"
            }, {
                name: "state",
                label: gettext('State'),
                editable: false,
                cell: "string"
            }];

            if (version < 90600) {
                database_activity_columns = database_activity_columns.concat([{
                    name: "waiting",
                    label: gettext('Waiting?'),
                    editable: false,
                    cell: "string"
                }]);
            } else {
                database_activity_columns = database_activity_columns.concat([{
                    name: "wait_event",
                    label: gettext('Wait Event'),
                    editable: false,
                    cell: "string"
                }, {
                    name: "blocking_pids",
                    label: gettext('Blocking PIDs'),
                    editable: false,
                    cell: "string"
                }]);
            }

            var newActiveQueryDetailsModel = new ActiveQueryDetailsModel();

            var subNodeFieldsModel = Backform.generateViewSchema(null, newActiveQueryDetailsModel, 'create', null, null, true);

            // Add version to each field
            _.each(subNodeFieldsModel[0].fields, function (obj) {
                obj['version'] = version;
            });

            // Add cancel active query button
            database_activity_columns.unshift({
                name: "pg-backform-expand", label: "",
                cell: SessionDetailsCell,
                cell_priority: -1,
                postgres_version: version,
                schema: subNodeFieldsModel
            });

            database_activity_columns.unshift({
                name: "pg-backform-delete", label: "",
                cell: cancelQueryCell,
                editable: false, cell_priority: -1,
                canDeleteRow: pgAdmin.Dashboard.can_cancel_active_query,
                postgres_version: version
            });

            var database_locks_columns = [{
                name: "pid",
                label: gettext('PID'),
                editable: false,
                cell: "string"
            }, {
                name: "locktype",
                label: gettext('Lock type'),
                editable: false,
                cell: "string"
            }, {
                name: "relation",
                label: gettext('Target relation'),
                editable: false,
                cell: "string"
            }, {
                name: "page",
                label: gettext('Page'),
                editable: false,
                cell: "string"
            }, {
                name: "tuple",
                label: gettext('Tuple'),
                editable: false,
                cell: "string"
            }, {
                name: "virtualxid",
                label: gettext('vXID (target)'),
                editable: false,
                cell: "string"
            }, {
                name: "transactionid",
                label: gettext('XID (target)'),
                editable: false,
                cell: "string"
            }, {
                name: "classid",
                label: gettext('Class'),
                editable: false,
                cell: "string"
            }, {
                name: "objid",
                label: gettext('Object ID'),
                editable: false,
                cell: "string"
            }, {
                name: "virtualtransaction",
                label: gettext('vXID (owner)'),
                editable: false,
                cell: "string"
            }, {
                name: "mode",
                label: gettext('Mode'),
                editable: false,
                cell: "string"
            }, {
                name: "granted",
                label: gettext('Granted?'),
                editable: false,
                cell: "string"
            }];

            var database_prepared_columns = [{
                name: "git",
                label: gettext('Name'),
                editable: false,
                cell: "string"
            }, {
                name: "Owner",
                label: gettext('Owner'),
                editable: false,
                cell: "string"
            }, {
                name: "transaction",
                label: gettext('XID'),
                editable: false,
                cell: "string"
            }, {
                name: "prepared",
                label: gettext('Prepared at'),
                editable: false,
                cell: "string"
            }];

            // Render the graphs
            pgAdmin.Dashboard.render_chart(div_sessions, data_sessions, dataset_sessions, sid, did, url_for('dashboard.session_stats'), options_line, false, session_stats_refresh);
            pgAdmin.Dashboard.render_chart(div_tps, data_tps, dataset_tps, sid, did, url_for('dashboard.tps_stats'), options_line, true, tps_stats_refresh);
            pgAdmin.Dashboard.render_chart(div_ti, data_ti, dataset_ti, sid, did, url_for('dashboard.ti_stats'), options_line, true, ti_stats_refresh);
            pgAdmin.Dashboard.render_chart(div_to, data_to, dataset_to, sid, did, url_for('dashboard.to_stats'), options_line, true, to_stats_refresh);
            pgAdmin.Dashboard.render_chart(div_bio, data_bio, dataset_bio, sid, did, url_for('dashboard.bio_stats'), options_line, true, bio_stats_refresh);

            // To align subnode controls properly
            $(div_database_activity).addClass('pg-el-container');
            $(div_database_activity).attr('el', 'sm');

            // Render the tabs, but only get data for the activity tab for now
            pgAdmin.Dashboard.render_grid(div_database_activity, sid, did, url_for('dashboard.activity'), database_activity_columns);
            pgAdmin.Dashboard.render_grid(div_database_locks, sid, did, url_for('dashboard.locks'), database_locks_columns);
            pgAdmin.Dashboard.render_grid(div_database_prepared, sid, did, url_for('dashboard.prepared'), database_prepared_columns);

            pgAdmin.Dashboard.render_grid_data(div_database_activity);

            // (Re)render the appropriate tab
            $('a[data-toggle="tab"]').on('shown.bs.tab', function (e) {
                switch ($(e.target).attr('aria-controls')) {
                    case "tab_database_activity":
                        pgAdmin.Dashboard.render_grid_data(div_database_activity);
                        break;

                    case "tab_database_locks":
                        pgAdmin.Dashboard.render_grid_data(div_database_locks);
                        break;

                    case "tab_database_prepared":
                        pgAdmin.Dashboard.render_grid_data(div_database_prepared);
                        break;
                }
            });

            // Handle button clicks
            $("button").click(function (e) {
                switch (this.id) {
                    case "btn_database_activity_refresh":
                        pgAdmin.Dashboard.render_grid_data(div_database_activity);
                        break;

                    case "btn_database_locks_refresh":
                        pgAdmin.Dashboard.render_grid_data(div_database_locks);
                        break;

                    case "btn_database_prepared_refresh":
                        pgAdmin.Dashboard.render_grid_data(div_database_prepared);
                        break;
                }
            });
        },
        toggleVisibility: function toggleVisibility(flag) {
            dashboardVisible = flag;
        },
        can_cancel_active_query: function can_cancel_active_query(m) {
            // We will validate if user is allowed to cancel the active query
            // If there is only one active session means it probably our main
            // connection session
            var active_sessions = m.collection.where({ 'state': 'active' }),
                pg_version = this.get('postgres_version') || null;

            // With PG10, We have background process showing on dashboard
            // We will not allow user to cancel them as they will fail with error
            // anyway, so better usability we will throw our on notification

            // Background processes do not have database field populated
            if (pg_version && pg_version >= 100000 && !m.get('datname')) {
                alertify.info(gettext('You cannot cancel background worker processes.'));
                return false;
                // If it is the last active connection on maintenance db then error out
            } else if (maintenance_database == m.get('datname') && m.get('state') == 'active' && active_sessions.length == 1) {
                alertify.error(gettext('You are not allowed to cancel the main active session.'));
                return false;
            } else if (m.get('state') == 'idle') {
                // If this session is already idle then do nothing
                alertify.info(gettext('The session is already in idle state.'));
                return false;
            } else if (is_super_user) {
                // Super user can do anything
                return true;
            } else if (current_user && current_user == m.get('usename')) {
                // Non-super user can cancel only their active queries
                return true;
            } else {
                // Do not allow to cancel someone else session to non-super user
                alertify.error(gettext('Superuser privileges are required to cancel another users query.'));
                return false;
            }
        }
    };

    return pgAdmin.Dashboard;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 270 */,
/* 271 */,
/* 272 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_272__;

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(pgAdmin) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(17), __webpack_require__(6), __webpack_require__(10), __webpack_require__(13), __webpack_require__(16), __webpack_require__(31), __webpack_require__(194), __webpack_require__(192), __webpack_require__(159)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, alertify, pgBrowser, Backbone, Backgrid, Backform, pgNode, userInfo) {

  // if module is already initialized, refer to that.
  if (pgBrowser.UserManagement) {
    return pgBrowser.UserManagement;
  }

  var USERURL = url_for('user_management.users'),
      ROLEURL = url_for('user_management.roles'),
      userFilter = function userFilter(collection) {
    return new Backgrid.Extension.ClientSideFilter({
      collection: collection,
      placeholder: _('Filter by email'),

      // The model fields to search for matches
      fields: ['email'],

      // How long to wait after typing has stopped before searching can start
      wait: 150
    });
  };

  pgBrowser.UserManagement = {
    init: function init() {
      if (this.initialized) return;

      this.initialized = true;

      return this;
    },
    // Callback to draw User Management Dialog.
    show_users: function show_users(action, item, params) {
      if (!userInfo['is_admin']) return;
      var Roles = [];

      var UserModel = pgAdmin.Browser.Node.Model.extend({
        idAttribute: 'id',
        urlRoot: USERURL,
        defaults: {
          id: undefined,
          email: undefined,
          active: true,
          role: undefined,
          newPassword: undefined,
          confirmPassword: undefined
        },
        schema: [{
          id: 'email', label: gettext('Email'), type: 'text',
          cell: Backgrid.Extension.StringDepCell, cellHeaderClasses: 'width_percent_30',
          deps: ['id'],
          editable: function editable(m) {
            if (m instanceof Backbone.Collection) {
              return false;
            }
            // Disable email edit for existing user.
            if (m.isNew()) {
              return true;
            }
            return false;
          }
        }, {
          id: 'role', label: gettext('Role'),
          type: 'text', control: "Select2", cellHeaderClasses: 'width_percent_20',
          cell: 'select2', select2: { allowClear: false, openOnEnter: false },
          options: function options(controlOrCell) {
            var options = [];

            if (controlOrCell instanceof Backform.Control) {
              // This is be backform select2 control
              _.each(Roles, function (role) {
                options.push({
                  label: role.name,
                  value: role.id.toString() });
              });
            } else {
              // This must be backgrid select2 cell
              _.each(Roles, function (role) {
                options.push([role.name, role.id.toString()]);
              });
            }

            return options;
          },
          editable: function editable(m) {
            if (m instanceof Backbone.Collection) {
              return true;
            }
            if (m.get("id") == userInfo['user_id']) {
              return false;
            } else {
              return true;
            }
          }
        }, {
          id: 'active', label: gettext('Active'),
          type: 'switch', cell: 'switch', cellHeaderClasses: 'width_percent_10',
          options: { 'onText': 'Yes', 'offText': 'No' },
          editable: function editable(m) {
            if (m instanceof Backbone.Collection) {
              return true;
            }
            if (m.get("id") == userInfo['user_id']) {
              return false;
            } else {
              return true;
            }
          }
        }, {
          id: 'newPassword', label: gettext('New password'),
          type: 'password', disabled: false, control: 'input',
          cell: 'password', cellHeaderClasses: 'width_percent_20'
        }, {
          id: 'confirmPassword', label: gettext('Confirm password'),
          type: 'password', disabled: false, control: 'input',
          cell: 'password', cellHeaderClasses: 'width_percent_20'
        }],
        validate: function validate() {
          var err = {},
              errmsg = null,
              changedAttrs = this.changed || {},
              email_filter = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;

          if (('email' in changedAttrs || !this.isNew()) && (_.isUndefined(this.get('email')) || _.isNull(this.get('email')) || String(this.get('email')).replace(/^\s+|\s+$/g, '') == '')) {
            errmsg = gettext('Email address cannot be empty.');
            this.errorModel.set('email', errmsg);
            return errmsg;
          } else if (!!this.get('email') && !email_filter.test(this.get('email'))) {

            errmsg = S(gettext("Invalid email address: %s.")).sprintf(this.get('email')).value();
            this.errorModel.set('email', errmsg);
            return errmsg;
          } else if (!!this.get('email') && this.collection.where({ "email": this.get('email') }).length > 1) {

            errmsg = S(gettext("The email address %s already exists.")).sprintf(this.get('email')).value();

            this.errorModel.set('email', errmsg);
            return errmsg;
          } else {
            this.errorModel.unset('email');
          }

          if ('role' in changedAttrs && (_.isUndefined(this.get('role')) || _.isNull(this.get('role')) || String(this.get('role')).replace(/^\s+|\s+$/g, '') == '')) {

            errmsg = S(gettext("Role cannot be empty for user %s.")).sprintf(this.get('email') || '').value();

            this.errorModel.set('role', errmsg);
            return errmsg;
          } else {
            this.errorModel.unset('role');
          }

          if (this.isNew()) {
            // Password is compulsory for new user.
            if ('newPassword' in changedAttrs && (_.isUndefined(this.get('newPassword')) || _.isNull(this.get('newPassword')) || this.get('newPassword') == '')) {

              errmsg = S(gettext("Password cannot be empty for user %s.")).sprintf(this.get('email') || '').value();

              this.errorModel.set('newPassword', errmsg);
              return errmsg;
            } else if (!_.isUndefined(this.get('newPassword')) && !_.isNull(this.get('newPassword')) && this.get('newPassword').length < 6) {

              errmsg = S(gettext("Password must be at least 6 characters for user %s.")).sprintf(this.get('email') || '').value();

              this.errorModel.set('newPassword', errmsg);
              return errmsg;
            } else {
              this.errorModel.unset('newPassword');
            }

            if ('confirmPassword' in changedAttrs && (_.isUndefined(this.get('confirmPassword')) || _.isNull(this.get('confirmPassword')) || this.get('confirmPassword') == '')) {

              errmsg = S(gettext("Confirm Password cannot be empty for user %s.")).sprintf(this.get('email') || '').value();

              this.errorModel.set('confirmPassword', errmsg);
              return errmsg;
            } else {
              this.errorModel.unset('confirmPassword');
            }

            if (!!this.get('newPassword') && !!this.get('confirmPassword') && this.get('newPassword') != this.get('confirmPassword')) {

              errmsg = S(gettext("Passwords do not match for user %s.")).sprintf(this.get('email') || '').value();

              this.errorModel.set('confirmPassword', errmsg);
              return errmsg;
            } else {
              this.errorModel.unset('confirmPassword');
            }
          } else {
            if ((_.isUndefined(this.get('newPassword')) || _.isNull(this.get('newPassword')) || this.get('newPassword') == '') && (_.isUndefined(this.get('confirmPassword')) || _.isNull(this.get('confirmPassword')) || this.get('confirmPassword') == '')) {

              this.errorModel.unset('newPassword');
              if (this.get('newPassword') == '') {
                this.set({ 'newPassword': undefined });
              }

              this.errorModel.unset('confirmPassword');
              if (this.get('confirmPassword') == '') {
                this.set({ 'confirmPassword': undefined });
              }
            } else if (!_.isUndefined(this.get('newPassword')) && !_.isNull(this.get('newPassword')) && !this.get('newPassword') == '' && this.get('newPassword').length < 6) {

              errmsg = S(gettext("Password must be at least 6 characters for user %s.")).sprintf(this.get('email') || '').value();

              this.errorModel.set('newPassword', errmsg);
              return errmsg;
            } else if (_.isUndefined(this.get('confirmPassword')) || _.isNull(this.get('confirmPassword')) || this.get('confirmPassword') == '') {

              errmsg = S(gettext("Confirm Password cannot be empty for user %s.")).sprintf(this.get('email') || '').value();

              this.errorModel.set('confirmPassword', errmsg);
              return errmsg;
            } else if (!!this.get('newPassword') && !!this.get('confirmPassword') && this.get('newPassword') != this.get('confirmPassword')) {

              errmsg = S(gettext("Passwords do not match for user %s.")).sprintf(this.get('email') || '').value();

              this.errorModel.set('confirmPassword', errmsg);
              return errmsg;
            } else {
              this.errorModel.unset('newPassword');
              this.errorModel.unset('confirmPassword');
            }
          }
          return null;
        }
      }),
          gridSchema = Backform.generateGridColumnsFromModel(null, UserModel, 'edit'),
          deleteUserCell = Backgrid.Extension.DeleteCell.extend({
        deleteRow: function deleteRow(e) {
          self = this;
          e.preventDefault();

          if (self.model.get("id") == userInfo['user_id']) {
            alertify.alert(gettext('Cannot delete user.'), gettext('Cannot delete currently logged in user.'), function () {
              return true;
            });
            return true;
          }

          // We will check if row is deletable or not
          var canDeleteRow = !_.isUndefined(this.column.get('canDeleteRow')) && _.isFunction(this.column.get('canDeleteRow')) ? Backgrid.callByNeed(this.column.get('canDeleteRow'), this.column, this.model) : true;
          if (canDeleteRow) {
            if (self.model.isNew()) {
              self.model.destroy();
            } else {
              alertify.confirm('Delete user?', 'Are you sure you wish to delete this user?', function (evt) {
                self.model.destroy({
                  wait: true,
                  success: function success(res) {
                    alertify.success(gettext('User deleted.'));
                  },
                  error: function error(m, jqxhr) {
                    alertify.error(gettext('Error during deleting user.'));
                  }
                });
              }, function (evt) {
                return true;
              });
            }
          } else {
            alertify.alert("This user cannot be deleted.", function () {
              return true;
            });
          }
        }
      });

      gridSchema.columns.unshift({
        name: "pg-backform-delete", label: "",
        cell: deleteUserCell,
        editable: false, cell_priority: -1,
        canDeleteRow: true
      });

      // Users Management dialog code here
      if (!alertify.UserManagement) {
        alertify.dialog('UserManagement', function factory() {
          return {
            main: function main(title) {
              this.set('title', title);
            },
            build: function build() {
              alertify.pgDialogBuild.apply(this);
            },
            setup: function setup() {
              return {
                buttons: [{
                  text: '', key: 112, className: 'btn btn-default pull-left fa fa-lg fa-question',
                  attrs: {
                    name: 'dialog_help', type: 'button', label: gettext('Users'),
                    url: url_for('help.static', {
                      'filename': 'pgadmin_user.html'
                    })
                  }
                }, {
                  text: gettext('Close'), key: 27, className: 'btn btn-danger fa fa-lg fa-times pg-alertify-button user_management_pg-alertify-button',
                  attrs: { name: 'close', type: 'button' }
                }],
                // Set options for dialog
                options: {
                  title: gettext('User Management'),
                  //disable both padding and overflow control.
                  padding: !1,
                  overflow: !1,
                  modal: false,
                  resizable: true,
                  maximizable: true,
                  pinnable: false,
                  closableByDimmer: false,
                  closable: false
                }
              };
            },
            hooks: {
              // Triggered when the dialog is closed
              onclose: function onclose() {
                if (this.view) {
                  // clear our backform model/view
                  this.view.remove({ data: true, internal: true, silent: true });
                  this.$content.remove();
                }
              }
            },
            prepare: function prepare() {
              var self = this,
                  footerTpl = _.template(['<div class="pg-prop-footer">', '<div class="pg-prop-status-bar" style="visibility:hidden">', '</div>', '</div>'].join("\n")),
                  $footer = $(footerTpl()),
                  $statusBar = $footer.find('.pg-prop-status-bar'),
                  UserRow = Backgrid.Row.extend({
                userInvalidColor: "lightYellow",

                userValidColor: "#fff",

                initialize: function initialize() {
                  Backgrid.Row.prototype.initialize.apply(this, arguments);
                  this.listenTo(this.model, 'pgadmin:user:invalid', this.userInvalid);
                  this.listenTo(this.model, 'pgadmin:user:valid', this.userValid);
                },
                userInvalid: function userInvalid() {
                  $(this.el).removeClass("new");
                  this.el.style.backgroundColor = this.userInvalidColor;
                },
                userValid: function userValid() {
                  this.el.style.backgroundColor = this.userValidColor;
                }
              }),
                  UserCollection = Backbone.Collection.extend({
                model: UserModel,
                url: USERURL,
                initialize: function initialize() {
                  Backbone.Collection.prototype.initialize.apply(this, arguments);
                  var self = this;
                  self.changedUser = null;
                  self.invalidUsers = {};

                  self.on('add', self.onModelAdd);
                  self.on('remove', self.onModelRemove);
                  self.on('pgadmin-session:model:invalid', function (msg, m, c) {
                    self.invalidUsers[m.cid] = msg;
                    m.trigger('pgadmin:user:invalid', m);
                    $statusBar.html(msg).css("visibility", "visible");
                  });
                  self.on('pgadmin-session:model:valid', function (m, c) {
                    delete self.invalidUsers[m.cid];
                    m.trigger('pgadmin:user:valid', m);
                    this.updateErrorMsg();
                    this.saveUser(m);
                  });
                },
                onModelAdd: function onModelAdd(m) {
                  // Start tracking changes.
                  m.startNewSession();
                },
                onModelRemove: function onModelRemove(m) {
                  delete this.invalidUsers[m.cid];
                  this.updateErrorMsg();
                },
                updateErrorMsg: function updateErrorMsg() {
                  var self = this,
                      msg = null;

                  for (var key in self.invalidUsers) {
                    msg = self.invalidUsers[key];
                    if (msg) {
                      break;
                    }
                  }

                  if (msg) {
                    $statusBar.html(msg).css("visibility", "visible");
                  } else {
                    $statusBar.empty().css("visibility", "hidden");
                  }
                },
                saveUser: function saveUser(m) {
                  var d = m.toJSON(true);

                  if (m.isNew() && (!m.get('email') || !m.get('role') || !m.get('newPassword') || !m.get('confirmPassword') || m.get('newPassword') != m.get('confirmPassword'))) {
                    // New user model is valid but partially filled so return without saving.
                    return false;
                  } else if (!m.isNew() && m.get('newPassword') != m.get('confirmPassword')) {
                    // For old user password change is in progress and user model is valid but admin has not added
                    // both the passwords so return without saving.
                    return false;
                  }

                  if (m.sessChanged() && d && !_.isEmpty(d)) {
                    m.stopSession();
                    m.save({}, {
                      attrs: d,
                      wait: true,
                      success: function success(res) {
                        // User created/updated on server now start new session for this user.
                        m.set({ 'newPassword': undefined,
                          'confirmPassword': undefined });

                        m.startNewSession();
                        alertify.success(S(gettext("User '%s' saved.")).sprintf(m.get('email')).value());
                      },
                      error: function error(res, jqxhr) {
                        m.startNewSession();
                        alertify.error(S(gettext("Error saving user: '%s'")).sprintf(jqxhr.responseJSON.errormsg).value());
                      }
                    });
                  }
                }
              }),
                  userCollection = this.userCollection = new UserCollection(),
                  header = ['<div class="subnode-header">', '  <button class="btn-sm btn-default add fa fa-plus" title="<%-add_title%>" <%=canAdd ? "" : "disabled=\'disabled\'"%> ></button>', '  <div class="control-label search_users"></div>', '</div>'].join("\n"),
                  headerTpl = _.template(header),
                  data = {
                canAdd: true,
                add_title: gettext('Add new user')
              },
                  $gridBody = $("<div></div>", {
                class: "user_container"
              });

              $.ajax({
                url: ROLEURL,
                method: 'GET',
                async: false,
                success: function success(res) {
                  Roles = res;
                },
                error: function error(e) {
                  setTimeout(function () {
                    alertify.alert(gettext('Cannot load user roles.'));
                  }, 100);
                }
              });

              var view = this.view = new Backgrid.Grid({
                row: UserRow,
                columns: gridSchema.columns,
                collection: userCollection,
                className: "backgrid table-bordered"
              });

              $gridBody.append(view.render().$el[0]);

              this.$content = $("<div class='user_management object subnode'></div>").append(headerTpl(data)).append($gridBody).append($footer);

              $(this.elements.body.childNodes[0]).addClass('alertify_tools_dialog_backgrid_properties');

              this.elements.content.appendChild(this.$content[0]);

              // Render Search Filter
              $('.search_users').append(userFilter(userCollection).render().el);

              userCollection.fetch();

              this.$content.find('button.add').first().click(function (e) {
                e.preventDefault();
                var canAddRow = true;

                if (canAddRow) {
                  // There should be only one empty row.

                  var isEmpty = false,
                      unsavedModel = null;

                  userCollection.each(function (model) {
                    if (!isEmpty) {
                      isEmpty = model.isNew();
                      unsavedModel = model;
                    }
                  });
                  if (isEmpty) {
                    var idx = userCollection.indexOf(unsavedModel),
                        row = view.body.rows[idx].$el;

                    row.addClass("new");
                    $(row).pgMakeVisible('backform-tab');
                    return false;
                  }

                  $(view.body.$el.find($("tr.new"))).removeClass("new");
                  var m = new UserModel(null, {
                    handler: userCollection,
                    top: userCollection,
                    collection: userCollection
                  });
                  userCollection.add(m);

                  var idx = userCollection.indexOf(m),
                      newRow = view.body.rows[idx].$el;

                  newRow.addClass("new");
                  $(newRow).pgMakeVisible('backform-tab');
                  return false;
                }
              });
            },
            callback: function callback(e) {
              if (e.button.element.name == "dialog_help") {
                e.cancel = true;
                pgBrowser.showHelp(e.button.element.name, e.button.element.getAttribute('url'), null, null, e.button.element.getAttribute('label'));
                return;
              }
              if (e.button.element.name == "close") {
                var self = this;
                if (!_.all(this.userCollection.pluck('id')) || !_.isEmpty(this.userCollection.invalidUsers)) {
                  e.cancel = true;
                  alertify.confirm(gettext('Discard unsaved changes?'), gettext('Are you sure you want to close the dialog? Any unsaved changes will be lost.'), function (e) {
                    self.close();
                    return true;
                  }, function (e) {
                    // Do nothing.
                    return true;
                  });
                }
              }
            }
          };
        });
      }
      alertify.UserManagement(true).resizeTo('680px', '400px');
    }

  };
  return pgBrowser.UserManagement;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backbone) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(1), __webpack_require__(4), __webpack_require__(0), __webpack_require__(6), __webpack_require__(13), __webpack_require__(8), __webpack_require__(275)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, _, S, $, pgBrowser, Backgrid, Alertify, sizePrettify) {

  if (pgBrowser.NodeStatistics) return pgBrowser.NodeStatistics;

  pgBrowser.NodeStatistics = pgBrowser.NodeStatistics || {};

  if (pgBrowser.NodeStatistics.initialized) {
    return pgBrowser.NodeStatistics;
  }

  var SizeFormatter = Backgrid.SizeFormatter = function () {};
  _.extend(SizeFormatter.prototype, {
    /**
       Takes a raw value from a model and returns the human readable formatted
       string for display.
        @member Backgrid.SizeFormatter
       @param {*} rawData
       @param {Backbone.Model} model Used for more complicated formatting
       @return {*}
    */
    fromRaw: function fromRaw(rawData, model) {
      return sizePrettify(rawData);
    },
    toRaw: function toRaw(formattedData, model) {
      return formattedData;
    }
  });

  var PGBooleanCell = Backgrid.Extension.SwitchCell.extend({
    defaults: _.extend({}, Backgrid.Extension.SwitchCell.prototype.defaults)
  }),
      typeCellMapper = {
    // boolean
    16: PGBooleanCell,
    // int8
    20: Backgrid.IntegerCell,
    // int2
    21: Backgrid.IntegerCell,
    // int4
    23: Backgrid.IntegerCell,
    // float4
    700: Backgrid.NumberCell,
    // float8
    701: Backgrid.NumberCell,
    // numeric
    1700: Backgrid.NumberCell,
    // abstime
    702: Backgrid.DatetimeCell,
    // reltime
    703: Backgrid.DatetimeCell,
    // date
    1082: Backgrid.DatetimeCell.extend({
      includeDate: true, includeTime: false, includeMilli: false
    }),
    // time
    1083: Backgrid.DatetimeCell.extend({
      includeDate: false, includeTime: true, includeMilli: true
    }),
    // timestamp
    1114: Backgrid.DatetimeCell.extend({
      includeDate: true, includeTime: true, includeMilli: true
    }),
    // timestamptz
    1184: 'string' /* Backgrid.DatetimeCell.extend({
                   includeDate: true, includeTime: true, includeMilli: true
                   }) */
    , 1266: 'string' /* Backgrid.DatetimeCell.extend({
                     includeDate: false, includeTime: true, includeMilli: true
                     }) */
  },
      GRID_CLASSES = "backgrid presentation table backgrid-striped table-bordered table-hover",
      wcDocker = window.wcDocker;

  _.extend(PGBooleanCell.prototype.defaults.options, {
    onText: gettext('True'),
    offText: gettext('False'),
    onColor: 'success',
    offColor: 'primary',
    size: 'mini'
  });

  _.extend(pgBrowser.NodeStatistics, {
    init: function init() {
      if (this.initialized) {
        return;
      }
      this.initialized = true;
      _.bindAll(this, 'showStatistics', 'panelVisibilityChanged', '__createMultiLineStatistics', '__createSingleLineStatistics');

      _.extend(this, {
        initialized: true,
        collection: new Backbone.Collection(null),
        statistic_columns: [{
          editable: false,
          name: 'statistics',
          label: gettext("Statistics"),
          cell: 'string',
          headerCell: Backgrid.Extension.CustomHeaderCell,
          cellHeaderClasses: 'width_percent_25'
        }, {
          editable: false,
          name: 'value',
          label: gettext("Value"),
          cell: 'string'
        }],
        panel: pgBrowser.docker.findPanels('statistics'),
        columns: null,
        grid: null
      });

      var self = this;

      // We will listen to the visibility change of the statistics panel
      pgBrowser.Events.on('pgadmin-browser:panel-statistics:' + wcDocker.EVENT.VISIBILITY_CHANGED, this.panelVisibilityChanged);

      pgBrowser.Events.on('pgadmin:browser:node:updated', function () {
        if (this.panel && this.panel.length) {
          $(this.panel[0]).data('node-prop', '');
          this.panelVisibilityChanged(this.panel[0]);
        }
      }, this);

      // Hmm.. Did we find the statistics panel, and is it visible (openned)?
      // If that is the case - we need to listen the browser tree selection
      // events.
      if (this.panel.length == 0) {
        pgBrowser.Events.on('pgadmin-browser:panel-statistics:' + wcDocker.EVENT.INIT, function () {
          self.panel = pgBrowser.docker.findPanels('statistics');
          if (self.panel[0].isVisible() || self.panel.length != 1) {
            pgBrowser.Events.on('pgadmin-browser:tree:selected', this.showStatistics);
          }
        }.bind(this));
      } else {
        if (self.panel[0].isVisible() || self.panel.length != 1) {
          pgBrowser.Events.on('pgadmin-browser:tree:selected', this.showStatistics);
        }
      }
      if (self.panel.length > 0 && self.panel[0].isVisible()) {
        pgBrowser.Events.on('pgadmin-browser:tree:selected', this.showStatistics);
      }
    },

    // Fetch the actual data and update the collection
    __updateCollection: function __updateCollection(url, node, item, node_type) {
      var $container = this.panel[0].layout().scene().find('.pg-panel-content'),
          $msgContainer = $container.find('.pg-panel-statistics-message'),
          $gridContainer = $container.find('.pg-panel-statistics-container'),
          collection = this.collection,
          panel = this.panel,
          self = this,
          msg = '',
          n_type = node_type;

      if (node) {
        msg = gettext("No statistics are available for the selected object.");
        /* We fetch the statistics only for those node who set the parameter
         * showStatistics function.
         */

        // Avoid unnecessary reloads
        var treeHierarchy = node.getTreeNodeHierarchy(item);
        var cache_flag = {
          node_type: node_type,
          url: url
        };
        if (_.isEqual($(panel[0]).data('node-prop'), cache_flag)) {
          return;
        }
        // Cache the current IDs for next time
        $(panel[0]).data('node-prop', cache_flag);

        if (node.hasStatistics) {
          msg = '';
          var timer;
          // Set the url, fetch the data and update the collection
          $.ajax({
            url: url,
            type: 'GET',
            beforeSend: function beforeSend(jqXHR, settings) {
              // Generate a timer for the request
              timer = setTimeout(function () {
                // notify user if request is taking longer than 1 second

                $msgContainer.text(gettext("Retrieving data from the server..."));
                $msgContainer.removeClass('hidden');
                if (self.grid) {
                  self.grid.remove();
                }
              }, 1000);
            },
            success: function success(res) {
              // clear timer and reset message.
              clearTimeout(timer);
              $msgContainer.text('');
              if (res.data) {
                var data = res.data;
                if (node.hasCollectiveStatistics || data['rows'].length > 1) {
                  self.__createMultiLineStatistics.call(self, data, node.statsPrettifyFields);
                } else {
                  self.__createSingleLineStatistics.call(self, data, node.statsPrettifyFields);
                }

                if (self.grid) {
                  delete self.grid;
                  self.grid = null;
                }

                self.grid = new Backgrid.Grid({
                  columns: self.columns,
                  collection: self.collection,
                  className: GRID_CLASSES
                });
                self.grid.render();
                $gridContainer.empty();
                $gridContainer.append(self.grid.$el);

                if (!$msgContainer.hasClass('hidden')) {
                  $msgContainer.addClass('hidden');
                }
                $gridContainer.removeClass('hidden');
              } else if (res.info) {
                if (!$gridContainer.hasClass('hidden')) {
                  $gridContainer.addClass('hidden');
                }
                $msgContainer.text(res.info);
                $msgContainer.removeClass('hidden');
              }
            },
            error: function error(xhr, _error, message) {
              var _label = treeHierarchy[n_type].label;
              pgBrowser.Events.trigger('pgadmin:node:retrieval:error', 'statistics', xhr, _error, message, item);
              if (!Alertify.pgHandleItemError(xhr, _error, message, {
                item: item, info: treeHierarchy
              })) {
                Alertify.pgNotifier(_error, xhr, S(gettext("Error retrieving the information - %s")).sprintf(message || _label).value(), function () {
                  console.log(arguments);
                });
              }
              // show failed message.
              $msgContainer.text(gettext("Failed to retrieve data from the server."));
            }
          });
        }
      }
      if (msg != '') {
        // Hide the grid container and show the default message container
        if (!$gridContainer.hasClass('hidden')) $gridContainer.addClass('hidden');
        $msgContainer.removeClass('hidden');

        $msgContainer.text(msg);
      }
    },

    showStatistics: function showStatistics(item, data, node) {
      var self = this;
      if (!node) {
        return;
      }
      /**
       * We can't start fetching the statistics immediately, it is possible -
       * the user is just using keyboards to select the node, and just
       * traversing through.
       *
       * We will wait for some time before fetching the statistics for the
       * selected node.
       **/
      if (node) {
        if (self.timeout) {
          clearTimeout(self.timeout);
        }
        self.timeout = setTimeout(function () {
          self.__updateCollection.call(self, node.generate_url(item, 'stats', data, true), node, item, data._type);
        }, 400);
      }
    },

    __createMultiLineStatistics: function __createMultiLineStatistics(data, prettifyFields) {
      var rows = data['rows'],
          columns = data['columns'];

      this.columns = [];
      for (var idx in columns) {
        var rawColumn = columns[idx],
            cell_type = typeCellMapper[rawColumn['type_code']] || 'string';

        // Don't show PID comma separated
        if (rawColumn['name'] == 'PID') {
          cell_type = cell_type.extend({
            orderSeparator: ''
          });
        }

        var col = {
          editable: false,
          name: rawColumn['name'],
          cell: cell_type
        };
        if (_.indexOf(prettifyFields, rawColumn['name']) != -1) {
          col['formatter'] = SizeFormatter;
        }
        this.columns.push(col);
      }

      this.collection.reset(rows);
    },

    __createSingleLineStatistics: function __createSingleLineStatistics(data, prettifyFields) {
      var row = data['rows'][0],
          columns = data['columns'],
          res = [];

      this.columns = this.statistic_columns;
      for (var idx in columns) {
        name = columns[idx]['name'];
        res.push({
          'statistics': name,
          // Check if row is undefined?
          'value': row && row[name] ? _.indexOf(prettifyFields, name) != -1 ? sizePrettify(row[name]) : row[name] : null
        });
      }

      this.collection.reset(res);
    },

    panelVisibilityChanged: function panelVisibilityChanged(panel) {
      if (panel.isVisible()) {
        var t = pgBrowser.tree,
            i = t.selected(),
            d = i && t.itemData(i),
            n = i && d && pgBrowser.Nodes[d._type];

        pgBrowser.NodeStatistics.showStatistics.apply(pgBrowser.NodeStatistics, [i, d, n]);

        // We will start listening the tree selection event.
        pgBrowser.Events.on('pgadmin-browser:tree:selected', pgBrowser.NodeStatistics.showStatistics);
      } else {
        // We don't need to listen the tree item selection event.
        pgBrowser.Events.off('pgadmin-browser:tree:selected', pgBrowser.NodeStatistics.showStatistics);
      }
    }
  });

  return pgBrowser.NodeStatistics;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
  var sizePrettify = function sizePrettify(rawSize) {
    var size = Math.abs(rawSize),
        limit = 10 * 1024,
        limit2 = limit - 1,
        cnt = 0,
        sizeUnits = ['bytes', 'kB', 'MB', 'GB', 'TB', 'PB'];

    if (size < limit) return size + ' ' + sizeUnits[cnt]; // return in bytes format
    else {
        do {
          size = size / 1024;
          cnt += 1;
        } while (size > limit2);

        return Math.round(size) + ' ' + sizeUnits[cnt];
      }
  };

  return sizePrettify;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backbone, Backgrid) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(1), __webpack_require__(4), __webpack_require__(0), __webpack_require__(6), __webpack_require__(8), __webpack_require__(17)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, _, S, $, pgBrowser, Alertify) {

  if (pgBrowser.ShowNodeDepends) return pgBrowser.ShowNodeDepends;

  var wcDocker = window.wcDocker;

  pgBrowser.ShowNodeDepends = pgBrowser.ShowNodeDepends || {};

  _.extend(pgBrowser.ShowNodeDepends, {
    init: function init() {
      if (this.initialized) {
        return;
      }

      this.initialized = true;
      /* Parameter is used to set the proper label of the
       * backgrid header cell.
       */
      var dependent = true,
          dependentGrid = null,
          // Refer to the backgrid object render under Dependents tab
      dependenciesGrid = null; // Refer to the backgrid object render under Dependencies tab

      _.bindAll(this, 'showDependents', 'dependentsPanelVisibilityChanged', 'showDependencies', 'dependenciesPanelVisibilityChanged', '__updateCollection');

      // We will listened to the visibility change of the Dependencies and Dependents panel
      pgBrowser.Events.on('pgadmin-browser:panel-dependencies:' + wcDocker.EVENT.VISIBILITY_CHANGED, this.dependenciesPanelVisibilityChanged);
      pgBrowser.Events.on('pgadmin-browser:panel-dependents:' + wcDocker.EVENT.VISIBILITY_CHANGED, this.dependentsPanelVisibilityChanged);

      // Defining Backbone Model for Dependencies and Dependents.
      var Model = Backbone.Model.extend({
        defaults: {
          icon: 'icon-unknown',
          type: undefined,
          name: undefined,
          /* field contains 'Database Name' for 'Tablespace and Role node',
           * for other node it contains 'Restriction'.
           */
          field: undefined
        },
        // This function is used to fetch/set the icon for the type(Function, Role, Database, ....)
        parse: function parse(res) {
          var node = pgBrowser.Nodes[res.type];
          res.icon = node ? _.isFunction(node['node_image']) ? node['node_image'].apply(node, [null, null]) : node['node_image'] || 'icon-' + res.type : 'icon-' + res.type;
          res.type = S.titleize(res.type.replace(/_/g, " "), true);
          return res;
        }
      });

      // Defining Backbone Collection for Dependents.
      this.dependentCollection = new (Backbone.Collection.extend({
        model: Model
      }))(null);

      // Defining Backbone Collection for Dependencies.
      this.dependenciesCollection = new (Backbone.Collection.extend({
        model: Model
      }))(null);

      var self = this;

      /* Function is used to create and render backgrid with
       * empty collection. We just want to add backgrid into the
       * panel only once.
       */
      var appendGridToPanel = function appendGridToPanel(collection, panel, is_dependent) {
        var $container = panel[0].layout().scene().find('.pg-panel-content'),
            $gridContainer = $container.find('.pg-panel-depends-container'),
            grid = new Backgrid.Grid({
          columns: [{
            name: 'type',
            label: 'Type',
            // Extend it to render the icon as per the type.
            cell: Backgrid.Cell.extend({
              render: function render() {
                Backgrid.Cell.prototype.render.apply(this, arguments);
                this.$el.prepend($('<i>', { class: "wcTabIcon " + this.model.get('icon') }));
                return this;
              }
            }),
            editable: false
          }, {
            name: 'name',
            label: 'Name',
            cell: 'string',
            editable: false
          }, {
            name: 'field',
            label: '', // label kept blank, it will change dynamically
            cell: 'string',
            editable: false
          }],

          collection: collection,
          className: "backgrid presentation table backgrid-striped table-bordered table-hover"
        });

        // Condition is used to save grid object to change the label of the header.
        if (is_dependent) self.dependentGrid = grid;else self.dependenciesGrid = grid;

        $gridContainer.append(grid.render().el);

        return true;
      };

      // We will listened to the visibility change of the Dependencies and Dependents panel
      pgBrowser.Events.on('pgadmin-browser:panel-dependencies:' + wcDocker.EVENT.VISIBILITY_CHANGED, this.dependenciesPanelVisibilityChanged);
      pgBrowser.Events.on('pgadmin-browser:panel-dependents:' + wcDocker.EVENT.VISIBILITY_CHANGED, this.dependentsPanelVisibilityChanged);
      pgBrowser.Events.on('pgadmin:browser:node:updated', function () {
        if (this.dependenciesPanels && this.dependenciesPanels.length) {
          $(this.dependenciesPanels[0]).data('node-prop', '');
          this.dependenciesPanelVisibilityChanged(this.dependenciesPanels[0]);
        }
        if (this.dependentsPanels && this.dependentsPanels.length) {
          $(this.dependentsPanels[0]).data('node-prop', '');
          this.dependentsPanelVisibilityChanged(this.dependentsPanels[0]);
        }
      }, this);

      // We will render the grid objects in the panel after some time, because -
      // it is possible, it is not yet available.
      // Find the panels to render the grid.
      var dependenciesPanels = this.dependenciesPanels = pgBrowser.docker.findPanels('dependencies');
      var dependentsPanels = this.dependentsPanels = pgBrowser.docker.findPanels('dependents');

      if (dependenciesPanels.length == 0) {
        pgBrowser.Events.on('pgadmin-browser:panel-dependencies:' + wcDocker.EVENT.INIT, function () {
          this.dependenciesPanels = pgBrowser.docker.findPanels('dependencies');
          appendGridToPanel(this.dependenciesCollection, this.dependenciesPanels, false);

          // If Dependencies panel exists and is focused then we need to listen the browser tree selection events.
          if (dependenciesPanels[0].isVisible() || dependenciesPanels.length != 1) {
            pgBrowser.Events.on('pgadmin-browser:tree:selected', this.showDependencies);
          }
        }.bind(this));
      } else {
        appendGridToPanel(this.dependenciesCollection, this.dependenciesPanels, false);

        // If Dependencies panel exists and is focused then we need to listen the browser tree selection events.
        if (dependenciesPanels[0].isVisible() || dependenciesPanels.length != 1) {
          pgBrowser.Events.on('pgadmin-browser:tree:selected', this.showDependencies);
        }
      }

      if (dependentsPanels.length == 0) {
        pgBrowser.Events.on('pgadmin-browser:panel-dependents:' + wcDocker.EVENT.INIT, function () {
          this.dependentsPanels = pgBrowser.docker.findPanels('dependents');
          appendGridToPanel(this.dependentCollection, this.dependentsPanels, true);

          // If Dependents panel exists and is focused then we need to listen the browser tree selection events.
          if (dependentsPanels[0].isVisible() || dependentsPanels.length != 1) {
            pgBrowser.Events.on('pgadmin-browser:tree:selected', this.showDependents);
          }
        }.bind(this));
      } else {
        appendGridToPanel(this.dependentCollection, this.dependentsPanels, true);

        // If Dependents panel exists and is focused then we need to listen the browser tree selection events.
        if (dependentsPanels[0].isVisible() || dependentsPanels.length != 1) {
          pgBrowser.Events.on('pgadmin-browser:tree:selected', this.showDependents);
        }
      }
    },

    // Fetch the actual data and update the collection
    __updateCollection: function __updateCollection(collection, panel, url, messages, node, item, type) {
      var msg = messages[0],
          $container = panel[0].layout().scene().find('.pg-panel-content'),
          $msgContainer = $container.find('.pg-panel-depends-message'),
          $gridContainer = $container.find('.pg-panel-depends-container'),
          treeHierarchy = node.getTreeNodeHierarchy(item),
          n_value = -1,
          n_type = type;

      // Avoid unnecessary reloads
      if (_.isEqual($(panel[0]).data('node-prop'), treeHierarchy)) {
        return;
      }

      // Cache the current IDs for next time
      $(panel[0]).data('node-prop', treeHierarchy);

      // Hide the grid container and show the default message container
      if (!$gridContainer.hasClass('hidden')) $gridContainer.addClass('hidden');
      $msgContainer.removeClass('hidden');

      if (node) {
        msg = messages[1];
        /* We fetch the Dependencies and Dependents tab only for
         * those node who set the parameter hasDepends to true.
         */
        if (node.hasDepends) {
          /* Set the message because ajax request may take time to
           * fetch the information from the server.
           */
          msg = messages[2];
          $msgContainer.text(msg);

          /* Updating the label for the 'field' type of the backbone model.
           * Label should be "Database" if the node type is tablespace or role
           * and dependent tab is selected. For other nodes and dependencies tab
           * it should be 'Restriction'.
           */
          if (this.dependent && (node.type == 'tablespace' || node.type == 'role')) this.dependentGrid.columns.models[2].set({ 'label': 'Database' });else {
            this.dependenciesGrid.columns.models[2].set({ 'label': 'Restriction' });
            this.dependentGrid.columns.models[2].set({ 'label': 'Restriction' });
          }

          // Hide message container and show grid container.
          $msgContainer.addClass('hidden');
          $gridContainer.removeClass('hidden');

          var timer = setTimeout(function () {
            // notify user if request is taking longer than 1 second

            $msgContainer.text(gettext("Retrieving data from the server..."));
            $msgContainer.removeClass('hidden');
            if ($gridContainer) {
              $gridContainer.addClass('hidden');
            }
          }, 1000);

          // Set the url, fetch the data and update the collection
          collection.url = url;
          collection.fetch({
            reset: true,
            success: function success() {
              clearTimeout(timer);
              $gridContainer.removeClass('hidden');
              if (!$msgContainer.hasClass('hidden')) {
                $msgContainer.addClass('hidden');
              }
            },
            error: function error(coll, xhr, _error, message) {
              var _label = treeHierarchy[n_type].label;
              pgBrowser.Events.trigger('pgadmin:node:retrieval:error', 'depends', xhr, _error, message);
              if (!Alertify.pgHandleItemError(xhr, _error, message, {
                item: item, info: treeHierarchy
              })) {
                Alertify.pgNotifier(_error, xhr, S(gettext("Error retrieving the information - %s")).sprintf(message || _label).value(), function () {
                  console.log(arguments);
                });
              }
              // show failed message.
              $msgContainer.text(gettext("Failed to retrieve data from the server."));
            }
          });
        }
      }
      if (msg != '') {
        $msgContainer.text(msg);
      }
    },
    showDependents: function showDependents(item, data, node) {
      /**
       * We can't start fetching the Dependents immediately, it is possible the user
       * is just using the keyboard to select the node, and just traversing
       * through. We will wait for some time before fetching the Dependents
       **/
      var self = this;
      if (!node) {
        return;
      }
      self.dependent = true;
      if (self.timeout) {
        clearTimeout(self.timeout);
      }
      self.timeout = setTimeout(self.__updateCollection(self.dependentCollection, self.dependentsPanels, node.generate_url(item, 'dependent', data, true), ['No object selected.', 'No dependent information is available for the current object.', 'Fetching dependent information from the server...'], node, item, data._type), 400);
    },
    dependentsPanelVisibilityChanged: function dependentsPanelVisibilityChanged(panel) {
      if (panel.isVisible()) {
        var t = pgBrowser.tree,
            i = t.selected(),
            d = i && t.itemData(i),
            n = i && d && pgBrowser.Nodes[d._type];

        pgBrowser.ShowNodeDepends.showDependents.apply(pgBrowser.ShowNodeDepends, [i, d, n]);

        // We will start listening the tree selection event.
        pgBrowser.Events.on('pgadmin-browser:tree:selected', pgBrowser.ShowNodeDepends.showDependents);
      } else {

        // We don't need to listen the tree item selection event.
        pgBrowser.Events.off('pgadmin-browser:tree:selected', pgBrowser.ShowNodeDepends.showDependents);
      }
    },
    showDependencies: function showDependencies(item, data, node) {
      /**
       * We can't start fetching the Dependencies immediately, it is possible the user
       * is just using the keyboard to select the node, and just traversing
       * through. We will wait for some time before fetching the Dependencies
       **/
      var self = this;
      if (!node) {
        return;
      }
      self.dependent = false;
      if (self.timeout) {
        clearTimeout(self.timeout);
      }
      self.timeout = setTimeout(self.__updateCollection(self.dependenciesCollection, self.dependenciesPanels, node.generate_url(item, 'dependency', data, true), ['Please select an object in the tree view.', 'No dependency information is available for the current object.', 'Fetching dependency information from the server...'], node, item, data._type), 400);
    },
    dependenciesPanelVisibilityChanged: function dependenciesPanelVisibilityChanged(panel) {
      if (panel.isVisible()) {
        var t = pgBrowser.tree,
            i = t.selected(),
            d = i && t.itemData(i),
            n = i && d && pgBrowser.Nodes[d._type];

        pgBrowser.ShowNodeDepends.showDependencies.apply(pgBrowser.ShowNodeDepends, [i, d, n]);

        // We will start listening the tree selection event.
        pgBrowser.Events.on('pgadmin-browser:tree:selected', pgBrowser.ShowNodeDepends.showDependencies);
      } else {
        // We don't need to listen the tree item selection event.
        pgBrowser.Events.off('pgadmin-browser:tree:selected', pgBrowser.ShowNodeDepends.showDependencies);
      }
    }
  });

  return pgBrowser.ShowNodeDepends;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10), __webpack_require__(13)))

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(pgAdmin) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(1), __webpack_require__(4), __webpack_require__(0), __webpack_require__(6), __webpack_require__(8), __webpack_require__(17)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, _, S, $, pgBrowser, Alertify) {

  pgBrowser.ShowNodeSQL = pgBrowser.ShowNodeSQL || {};

  if (pgBrowser.ShowNodeSQL.initialized) {
    return pgBrowser.ShowNodeSQL;
  }
  var wcDocker = window.wcDocker;

  _.extend(pgBrowser.ShowNodeSQL, {
    init: function init() {
      if (this.initialized) {
        return;
      }
      this.initialized = true;
      _.bindAll(this, 'showSQL', 'sqlPanelVisibilityChanged');

      var sqlPanels;
      this.sqlPanels = sqlPanels = pgBrowser.docker.findPanels('sql');

      // We will listend to the visibility change of the SQL panel
      pgBrowser.Events.on('pgadmin-browser:panel-sql:' + wcDocker.EVENT.VISIBILITY_CHANGED, this.sqlPanelVisibilityChanged);

      pgBrowser.Events.on('pgadmin:browser:node:updated', function () {
        if (this.sqlPanels && this.sqlPanels.length) {
          $(this.sqlPanels[0]).data('node-prop', '');
          this.sqlPanelVisibilityChanged(this.sqlPanels[0]);
        }
      }, this);

      // Hmm.. Did we find the SQL panel, and is it visible (opened)?
      // If that is the case - we need to listen the browser tree selection
      // events.
      if (sqlPanels.length == 0) {
        pgBrowser.Events.on('pgadmin-browser:panel-sql:' + wcDocker.EVENT.INIT, function () {
          if (sqlPanels[0].isVisible() || sqlPanels.length != 1) {
            pgBrowser.Events.on('pgadmin-browser:tree:selected', this.showSQL);
          }
        }.bind(this));
      } else {
        if (sqlPanels[0].isVisible() || sqlPanels.length != 1) {
          pgBrowser.Events.on('pgadmin-browser:tree:selected', this.showSQL);
        }
      }
    },
    showSQL: function showSQL(item, data, node) {
      /**
       * We can't start fetching the SQL immediately, it is possible - the user
       * is just using keyboards to select the node, and just traversing
       * through. We will wait for some time before fetching the Reversed
       * Engineering SQL.
       **/
      this.timeout && clearTimeout(this.timeout);

      var that = this;
      this.timeout = setTimeout(function () {
        var sql = '';
        if (node) {
          sql = '-- ' + gettext("No SQL could be generated for the selected object.");
          var self = this,
              n_type = data._type,
              n_value = -1,
              treeHierarchy = node.getTreeNodeHierarchy(item);

          // Avoid unnecessary reloads
          if (_.isEqual($(that.sqlPanels[0]).data('node-prop'), treeHierarchy)) {
            return;
          }
          // Cache the current IDs for next time
          $(that.sqlPanels[0]).data('node-prop', treeHierarchy);

          if (node.hasSQL) {

            sql = '';
            var url = node.generate_url(item, 'sql', data, true),
                timer;

            $.ajax({
              url: url,
              type: 'GET',
              beforeSend: function beforeSend(jqXHR, settings) {
                // Generate a timer for the request
                timer = setTimeout(function () {
                  // notify user if request is taking longer than 1 second

                  pgAdmin.Browser.editor.setValue(gettext("Retrieving data from the server..."));
                }, 1000);
              },
              success: function success(res) {
                if (pgAdmin.Browser.editor.getValue() != res) {
                  pgAdmin.Browser.editor.setValue(res);
                }
                clearTimeout(timer);
              },
              error: function error(xhr, _error, message) {
                var _label = treeHierarchy[n_type].label;
                pgBrowser.Events.trigger('pgadmin:node:retrieval:error', 'sql', xhr, _error, message, item);
                if (!Alertify.pgHandleItemError(xhr, _error, message, {
                  item: item, info: treeHierarchy
                })) {
                  Alertify.pgNotifier(_error, xhr, S(gettext("Error retrieving the information - %s")).sprintf(message || _label).value(), function () {
                    console.log(arguments);
                  });
                }
              }
            });
          }
        }

        if (sql != '') {
          pgAdmin.Browser.editor.setValue(sql);
        }
      }, 400);
    },
    sqlPanelVisibilityChanged: function sqlPanelVisibilityChanged(panel) {
      if (panel.isVisible()) {
        var t = pgBrowser.tree,
            i = t.selected(),
            d = i && t.itemData(i),
            n = i && d && pgBrowser.Nodes[d._type];

        pgBrowser.ShowNodeSQL.showSQL.apply(pgBrowser.ShowNodeSQL, [i, d, n]);

        // We will start listening the tree selection event.
        pgBrowser.Events.on('pgadmin-browser:tree:selected', pgBrowser.ShowNodeSQL.showSQL);
      } else {
        // We don't need to listen the tree item selection event.
        pgBrowser.Events.off('pgadmin-browser:tree:selected', pgBrowser.ShowNodeSQL.showSQL);
      }
    }
  });

  return pgBrowser.ShowNodeSQL;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3), __webpack_require__(2), __webpack_require__(5), __webpack_require__(1), __webpack_require__(4), __webpack_require__(0), __webpack_require__(6), __webpack_require__(8), __webpack_require__(96)], __WEBPACK_AMD_DEFINE_RESULT__ = function (pgAdmin, gettext, url_for, _, S, $, pgBrowser, alertify, pgMessages) {

  pgBrowser.BackgroundProcessObsorver = pgBrowser.BackgroundProcessObsorver || {};

  if (pgBrowser.BackgroundProcessObsorver.initialized) {
    return pgBrowser.BackgroundProcessObsorver;
  }

  var BGProcess = function BGProcess(info, notify) {
    var self = this;
    setTimeout(function () {
      self.initialize.apply(self, [info, notify]);
    }, 1);
  };

  _.extend(BGProcess.prototype, {
    initialize: function initialize(info, notify) {
      _.extend(this, {
        details: false,
        notify: _.isUndefined(notify) || notify,
        curr_status: null,
        state: 0, // 0: NOT Started, 1: Started, 2: Finished
        completed: false,

        id: info['id'],
        desc: null,
        detailed_desc: null,
        stime: null,
        exit_code: null,
        acknowledge: info['acknowledge'],
        execution_time: null,
        out: -1,
        err: -1,
        lot_more: false,

        notifier: null,
        container: null,
        panel: null,
        logs: $('<ol></ol>', { class: 'pg-bg-process-logs' })
      });

      if (this.notify) {
        pgBrowser.Events && pgBrowser.Events.on('pgadmin-bgprocess:started:' + this.id, function (process) {
          if (!process.notifier) process.show.apply(process);
        });
        pgBrowser.Events && pgBrowser.Events.on('pgadmin-bgprocess:finished:' + this.id, function (process) {
          if (!process.notifier) process.show.apply(process);
        });
      }
      var self = this;

      setTimeout(function () {
        self.update.apply(self, [info]);
      }, 1);
    },

    bgprocess_url: function bgprocess_url(type) {
      switch (type) {
        case 'status':
          if (this.details && this.out != -1 && this.err != -1) {
            return url_for('bgprocess.detailed_status', {
              'pid': this.id,
              'out': this.out,
              'err': this.err
            });
          }
          return url_for('bgprocess.status', { 'pid': this.id });
        case 'acknowledge':
          return url_for('bgprocess.acknowledge', { 'pid': this.id });
        default:
          return url_for('bgprocess.list');
      }
    },

    update: function update(data) {
      var self = this,
          out = [],
          err = [],
          idx = 0;

      if ('stime' in data) self.stime = new Date(data.stime);

      if ('execution_time' in data) self.execution_time = parseFloat(data.execution_time);

      if ('desc' in data) self.desc = data.desc;

      if ('details' in data) self.detailed_desc = data.details;

      if ('exit_code' in data) self.exit_code = data.exit_code;

      if ('out' in data) {
        self.out = data.out && data.out.pos;

        if (data.out && data.out.lines) {
          out = data.out.lines;
        }
      }

      if ('err' in data) {
        self.err = data.err && data.err.pos;

        if (data.err && data.err.lines) {
          err = data.err.lines;
        }
      }
      self.completed = self.completed || 'err' in data && 'out' in data && data.err.done && data.out.done || !self.details && !_.isNull(self.exit_code);

      var io = 0,
          ie = 0,
          res = [],
          escapeEl = document.createElement('textarea'),
          escapeHTML = function escapeHTML(html) {
        escapeEl.textContent = html;
        return escapeEl.innerHTML;
      };

      while (io < out.length && ie < err.length) {
        if (pgAdmin.natural_sort(out[io][0], err[ie][0]) <= 0) {
          res.push('<li class="pg-bg-res-out">' + escapeHTML(out[io++][1]) + '</li>');
        } else {
          res.push('<li class="pg-bg-res-err">' + escapeHTML(err[ie++][1]) + '</li>');
        }
      }

      while (io < out.length) {
        res.push('<li class="pg-bg-res-out">' + escapeHTML(out[io++][1]) + '</li>');
      }

      while (ie < err.length) {
        res.push('<li class="pg-bg-res-err">' + escapeHTML(err[ie++][1]) + '</li>');
      }
      if (res.length) {
        self.logs.append(res.join(''));
      }

      if (self.stime) {
        self.curr_status = gettext('Started');

        if (self.execution_time >= 2) {
          self.curr_status = gettext['Running...'];
        }

        if (!_.isNull(self.exit_code)) {
          if (self.exit_code == 0) {
            self.curr_status = gettext('Successfully completed.');
          } else {
            self.curr_status = S(gettext("Failed (exit code: %s).")).sprintf(String(self.exit_code)).value();
          }
        }

        if (self.state == 0 && self.stime) {
          self.state = 1;
          pgBrowser.Events && pgBrowser.Events.trigger('pgadmin-bgprocess:started:' + self.id, self, self);
        }

        if (self.state == 1 && !_.isNull(self.exit_code)) {
          self.state = 2;
          pgBrowser.Events && pgBrowser.Events.trigger('pgadmin-bgprocess:finished:' + self.id, self, self);
        }

        setTimeout(function () {
          self.show.apply(self);
        }, 10);
      }

      if (!self.completed) {
        setTimeout(function () {
          self.status.apply(self);
        }, 1000);
      }
    },

    status: function status() {
      var self = this;

      $.ajax({
        typs: 'GET',
        timeout: 30000,
        url: self.bgprocess_url('status'),
        cache: false,
        async: true,
        contentType: "application/json",
        success: function success(res) {
          setTimeout(function () {
            self.update(res);
          }, 10);
        },
        error: function error(res) {
          // Try after some time only if job id present
          if (res.status != 410) setTimeout(function () {
            self.update(res);
          }, 10000);
        }
      });
    },

    show: function show() {
      var self = this;

      if (self.notify && !self.details) {
        if (!self.notifier) {
          var header = $('<div></div>', {
            class: "h5 pg-bg-notify-header"
          }).append($('<span></span>').text(self.desc)),
              content = $('<div class="pg-bg-bgprocess row"></div>').append(header).append($('<div></div>', { class: 'pg-bg-notify-body h6' }).append($('<div></div>', { class: 'pg-bg-start col-xs-12' }).append($('<div></div>').text(self.stime.toString())).append($('<div class="pg-bg-etime"></div>')))),
              for_details = $('<div></div>', {
            class: "col-xs-12 text-center pg-bg-click h6"
          }).append($('<span></span>').text(gettext('Click here for details.'))).appendTo(content),
              status = $('<div></div>', {
            class: "pg-bg-status col-xs-12 h5 " + (self.exit_code === 0 ? 'bg-success' : self.exit_code == 1 ? 'bg-failed' : '')
          }).appendTo(content),
              close_me = $('<div class="bg-close"><i class="fa fa-close"></i></div>').appendTo(header);

          self.container = content;
          self.notifier = alertify.notify(content.get(0), 'bg-bgprocess', 0, null);

          for_details.on('click', function (ev) {
            ev = ev || window.event;
            ev.cancelBubble = true;
            ev.stopPropagation();

            this.notifier.dismiss();
            this.notifier = null;
            this.completed = false;

            this.show_detailed_view.apply(this);
          }.bind(self));

          close_me.on('click', function (ev) {
            this.notifier.dismiss();
            this.notifier = null;
            this.acknowledge_server.apply(this);
          }.bind(this));

          // Do not close the notifier, when clicked on the container, which
          // is a default behaviour.
          content.on('click', function (ev) {
            ev = ev || window.event;
            ev.cancelBubble = true;
            ev.stopPropagation();

            return;
          });
        }
        // TODO:: Formatted execution time
        self.container.find('.pg-bg-etime').empty().append($('<span></span>').text(String(self.execution_time))).append($('<span></span>').text(' ' + gettext('seconds')));
        self.container.find('.pg-bg-status').empty().append(self.curr_status);
      } else {
        self.show_detailed_view.apply(self);
      }
    },

    show_detailed_view: function show_detailed_view() {
      var self = this,
          panel = this.panel,
          is_new = false;

      if (!self.panel) {
        is_new = true;
        panel = this.panel = pgBrowser.BackgroundProcessObsorver.create_panel();

        panel.title('Process Watcher - ' + _.escape(self.desc));
        panel.focus();
      }

      var container = panel.$container,
          status_class = self.exit_code === 0 ? 'bg-bgprocess-success' : self.exit_code == 1 ? 'bg-bgprocess-failed' : '',
          $logs = container.find('.bg-process-watcher'),
          $header = container.find('.bg-process-details'),
          $footer = container.find('.bg-process-footer');

      if (is_new) {
        // set logs
        $logs.html(self.logs);

        // set bgprocess detailed description
        $header.find('.bg-detailed-desc').html(self.detailed_desc);
      }

      // set bgprocess start time
      $header.find('.bg-process-stats .bgprocess-start-time').html(self.stime);

      // set status
      $footer.find('.bg-process-status p').removeClass().addClass(status_class).html(self.curr_status);

      // set bgprocess execution time
      $footer.find('.bg-process-exec-time p').empty().append($('<span></span>').text(String(self.execution_time))).append($('<span></span>').text(' ' + gettext('seconds')));

      if (is_new) {
        self.details = true;
        self.err = 0;
        self.out = 0;
        setTimeout(function () {
          self.status.apply(self);
        }, 1000);

        var resize_log_container = function ($logs, $header, $footer) {
          var h = $header.outerHeight() + $footer.outerHeight();
          $logs.css('padding-bottom', h);
        }.bind(panel, $logs, $header, $footer);

        panel.on(wcDocker.EVENT.RESIZED, resize_log_container);
        panel.on(wcDocker.EVENT.ATTACHED, resize_log_container);
        panel.on(wcDocker.EVENT.DETACHED, resize_log_container);

        resize_log_container();

        panel.on(wcDocker.EVENT.CLOSED, function (process) {
          process.panel = null;

          process.details = false;
          if (process.exit_code != null) {
            process.acknowledge_server.apply(process);
          }
        }.bind(panel, this));
      }
    },

    acknowledge_server: function acknowledge_server() {
      var self = this;
      $.ajax({
        type: 'PUT',
        timeout: 30000,
        url: self.bgprocess_url('acknowledge'),
        cache: false,
        async: true,
        contentType: "application/json",
        success: function success(res) {
          return;
        },
        error: function error(res) {}
      });
    }
  });

  _.extend(pgBrowser.BackgroundProcessObsorver, {
    bgprocesses: {},
    init: function init() {
      var self = this;

      if (self.initialized) {
        return;
      }
      self.initialized = true;

      setTimeout(function () {
        self.update_process_list.apply(self);
      }, 1000);

      pgBrowser.Events.on('pgadmin-bgprocess:created', function () {
        setTimeout(function () {
          pgBrowser.BackgroundProcessObsorver.update_process_list(true);
        }, 1000);
      });
    },

    update_process_list: function update_process_list(recheck) {
      var observer = this;

      $.ajax({
        typs: 'GET',
        timeout: 30000,
        url: url_for('bgprocess.list'),
        cache: false,
        async: true,
        contentType: "application/json",
        success: function success(res) {
          var cnt = 0;
          if (!res || !_.isArray(res)) {
            return;
          }
          for (var idx in res) {
            var process = res[idx];
            if ('id' in process) {
              if (!(process.id in observer.bgprocesses)) {
                observer.bgprocesses[process.id] = new BGProcess(process);
              }
            }
          }
          if (recheck && res.length == 0) {
            // Recheck after some more time
            setTimeout(function () {
              observer.update_process_list(false);
            }, 3000);
          }
        },
        error: function error(res) {
          // FIXME:: What to do now?
        }
      });
    },

    create_panel: function create_panel() {
      this.register_panel();

      return pgBrowser.docker.addPanel('bg_process_watcher', wcDocker.DOCK.FLOAT, null, {
        w: screen.width < 700 ? screen.width * 0.95 : screen.width * 0.5,
        h: screen.height < 500 ? screen.height * 0.95 : screen.height * 0.5,
        x: screen.width < 700 ? '2%' : '25%',
        y: screen.height < 500 ? '2%' : '25%'
      });
    },

    register_panel: function register_panel() {
      var w = pgBrowser.docker,
          panels = w.findPanels('bg_process_watcher');

      if (panels && panels.length >= 1) return;

      var p = new pgBrowser.Panel({
        name: 'bg_process_watcher',
        showTitle: true,
        isCloseable: true,
        isPrivate: true,
        content: '<div class="bg-process-details col-xs-12">' + '<p class="bg-detailed-desc"></p>' + '<div class="bg-process-stats">' + '<span><b>' + gettext('Start time') + ': </b>' + '<span class="bgprocess-start-time"></span>' + '</span></div>' + '</div>' + '<div class="bg-process-watcher col-xs-12">' + '</div>' + '<div class="bg-process-footer col-xs-12">' + '<div class="bg-process-status col-xs-6">' + '<span><b>' + gettext('Status') + ':</b></span><p></p>' + '</div>' + '<div class="bg-process-exec-time col-xs-6">' + '<div class="exec-div pull-right">' + '<span><b>' + gettext('Execution time') + ':</b></span><p></p>' + '</div>' + '</div>' + '</div>',
        onCreate: function onCreate(myPanel, $container) {
          $container.addClass('pg-no-overflow');
        }
      });
      p.load(pgBrowser.docker);
    }
  });

  return pgBrowser.BackgroundProcessObsorver;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(3), __webpack_require__(10), __webpack_require__(6), __webpack_require__(31)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, pgAdmin, Backbone) {

  if (!pgAdmin.Browser.Nodes['server_group']) {
    pgAdmin.Browser.Nodes['server_group'] = pgAdmin.Browser.Node.extend({
      parent_type: null,
      type: 'server_group',
      dialogHelp: url_for('help.static', { 'filename': 'server_group_dialog.html' }),
      label: gettext('Server Group'),
      width: '350px',
      height: '250px',
      is_collection: true,
      Init: function Init() {
        /* Avoid multiple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgAdmin.Browser.add_menus([{
          name: 'create_server_group', node: 'server_group', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 1, label: gettext('Server Group...'),
          data: { 'action': 'create' }, icon: 'wcTabIcon icon-server_group'
        }]);
      },
      model: pgAdmin.Browser.Node.Model.extend({
        defaults: {
          id: undefined,
          name: null
        },
        schema: [{
          id: 'id', label: gettext('ID'), type: 'int', group: null,
          mode: ['properties']
        }, {
          id: 'name', label: gettext('Name'), type: 'text', group: null,
          mode: ['properties', 'edit', 'create']
        }],
        validate: function validate(attrs, options) {
          var err = {},
              errmsg = null;
          this.errorModel.clear();

          if (!this.isNew() && 'id' in this.changed) {
            errmsg = gettext('The ID cannot be changed.');
            this.errorModel.set('id', errmsg);
            return errmsg;
          }
          if (_.isUndefined(this.get('name')) || _.isNull(this.get('name')) || String(this.get('name')).replace(/^\s+|\s+$/g, '') == '') {
            errmsg = gettext('Name cannot be empty.');
            this.errorModel.set('name', errmsg);
            return errmsg;
          }
          return null;
        }
      }),
      canDrop: function canDrop(itemData, item, data) {
        if (itemData.can_delete) {
          return true;
        }
        return false;
      },
      canDelete: function canDelete(i) {
        var s = pgAdmin.Browser.tree.siblings(i, true);

        /* This is the only server group - we can't remove it*/
        if (!s || s.length == 0) {
          return false;
        }
        return true;
      }
    });
  }

  return pgAdmin.Browser.Nodes['server_group'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(77), __webpack_require__(17), __webpack_require__(9), __webpack_require__(22), __webpack_require__(195)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, Alertify) {

  if (!pgBrowser.Nodes['coll-database']) {
    var databases = pgBrowser.Nodes['coll-database'] = pgBrowser.Collection.extend({
      node: 'database',
      label: gettext('Databases'),
      type: 'coll-database',
      columns: ['name', 'datowner', 'comments'],
      hasStatistics: true,
      statsPrettifyFields: ['Size', 'Size of temporary files']
    });
  };

  if (!pgBrowser.Nodes['database']) {
    var connect_to_database = function connect_to_database(obj, data, tree, item, interactive) {
      connect(obj, data, tree, item);
    };

    var connect = function connect(obj, data, tree, item, _wasConnected) {
      var wasConnected = _wasConnected || data.connected,
          onFailure = function onFailure(xhr, status, error, _model, _data, _tree, _item, _status) {
        if (!_status) {
          tree.setInode(_item);
          tree.addIcon(_item, { icon: 'icon-database-not-connected' });
        }

        Alertify.pgNotifier('error', xhr, error, function (msg) {
          setTimeout(function () {
            Alertify.dlgServerPass(gettext('Connect to database'), msg, _model, _data, _tree, _item, _status, onSuccess, onFailure, onCancel).resizeTo();
          }, 100);
        });
      },
          onSuccess = function onSuccess(res, model, data, tree, item, connected) {
        data.is_connecting = false;
        if (!connected) {
          tree.deselect(item);
          tree.setInode(item);
        }

        if (res && res.data) {
          if (typeof res.data.connected == 'boolean') {
            data.connected = res.data.connected;
          }
          if (typeof res.data.icon == 'string') {
            tree.removeIcon(item);
            data.icon = res.data.icon;
            tree.addIcon(item, { icon: data.icon });
          }

          Alertify.success(res.info);
          obj.trigger('connected', obj, item, data);
          pgBrowser.Events.trigger('pgadmin:database:connected', item, data);

          if (!connected) {
            setTimeout(function () {
              tree.select(item);
              tree.open(item);
            }, 10);
          }
        }
      },
          onCancel = function onCancel(_tree, _item, _data, _status) {
        _data.is_connecting = false;
        var server = _tree.parent(_item);
        _tree.unload(_item);
        _tree.setInode(_item);
        _tree.removeIcon(_item);
        _tree.addIcon(_item, { icon: 'icon-database-not-connected' });
        obj.trigger('connect:cancelled', obj, _item, _data);
        pgBrowser.Events.trigger('pgadmin:database:connect:cancelled', _item, _data, obj);
        _tree.select(server);
      };

      $.post(obj.generate_url(item, "connect", data, true)).done(function (res) {
        if (res.success == 1) {
          return onSuccess(res, obj, data, tree, item, wasConnected);
        }
      }).fail(function (xhr, status, error) {
        return onFailure(xhr, status, error, obj, data, tree, item, wasConnected);
      });
    };

    pgBrowser.Nodes['database'] = pgBrowser.Node.extend({
      parent_type: 'server',
      type: 'database',
      sqlAlterHelp: 'sql-alterdatabase.html',
      sqlCreateHelp: 'sql-createdatabase.html',
      dialogHelp: url_for('help.static', { 'filename': 'database_dialog.html' }),
      hasSQL: true,
      hasDepends: true,
      hasStatistics: true,
      statsPrettifyFields: ['Size', 'Size of temporary files'],
      canDrop: function canDrop(node) {
        return node.canDrop;
      },
      label: gettext('Database'),
      node_image: function node_image() {
        return 'pg-icon-database';
      },
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_database_on_server', node: 'server', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Database...'),
          icon: 'wcTabIcon pg-icon-database', data: { action: 'create' },
          enable: 'can_create_database'
        }, {
          name: 'create_database_on_coll', node: 'coll-database', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Database...'),
          icon: 'wcTabIcon pg-icon-database', data: { action: 'create' },
          enable: 'can_create_database'
        }, {
          name: 'create_database', node: 'database', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Database...'),
          icon: 'wcTabIcon pg-icon-database', data: { action: 'create' },
          enable: 'can_create_database'
        }, {
          name: 'connect_database', node: 'database', module: this,
          applies: ['object', 'context'], callback: 'connect_database',
          category: 'connect', priority: 4, label: gettext('Connect Database...'),
          icon: 'fa fa-link', enable: 'is_not_connected'
        }, {
          name: 'disconnect_database', node: 'database', module: this,
          applies: ['object', 'context'], callback: 'disconnect_database',
          category: 'drop', priority: 5, label: gettext('Disconnect Database...'),
          icon: 'fa fa-chain-broken', enable: 'is_connected'
        }]);

        _.bindAll(this, 'connection_lost');
        pgBrowser.Events.on('pgadmin:database:connection:lost', this.connection_lost);
      },
      can_create_database: function can_create_database(node, item) {
        var treeData = this.getTreeNodeHierarchy(item),
            server = treeData['server'];

        return server.connected && server.user.can_create_db;
      },
      is_not_connected: function is_not_connected(node) {
        return node && node.connected != true && node.allowConn == true;
      },
      is_connected: function is_connected(node) {
        return node && node.connected == true && node.canDisconn == true;
      },
      is_conn_allow: function is_conn_allow(node) {
        return node && node.allowConn == true;
      },
      connection_lost: function connection_lost(i, resp, server_connected) {
        if (pgBrowser.tree) {
          var t = pgBrowser.tree,
              info = i && this.getTreeNodeHierarchy(i),
              s = null,
              d = i && t.itemData(i),
              self = this,
              _i = i;

          while (d && d._type != 'database') {
            i = t.parent(i);
            d = i && t.itemData(i);
          }

          if (i && d) {
            if (!d.allowConn) return false;
            if (_.isUndefined(d.is_connecting) || !d.is_connecting) {
              d.is_connecting = true;

              var disconnect = function disconnect(_i, _d) {
                if (_d._id == this._id) {
                  d.is_connecting = false;
                  pgBrowser.Events.off('pgadmin:database:connect:cancelled', disconnect);
                  _i = _i && t.parent(_i);
                  _d = _i && t.itemData(_i);
                  if (_i && _d) {
                    pgBrowser.Events.trigger('pgadmin:server:disconnect', { item: _i, data: _d }, false);
                  }
                }
              };

              pgBrowser.Events.on('pgadmin:database:connect:cancelled', disconnect);
              if (server_connected) {
                connect(self, d, t, i, true);
                return;
              }
              Alertify.confirm(gettext('Connection lost'), gettext('Would you like to reconnect to the database?'), function () {
                connect(self, d, t, i, true);
              }, function () {
                d.is_connecting = false;
                t.unload(i);
                t.setInode(i);
                t.addIcon(i, { icon: 'icon-database-not-connected' });
                pgBrowser.Events.trigger('pgadmin:database:connect:cancelled', i, d, self);
              });
            }
          }
        }
      },
      callbacks: {
        /* Connect the database */
        connect_database: function connect_database(args) {
          var input = args || {};
          obj = this, t = pgBrowser.tree, i = input.item || t.selected(), d = i && i.length == 1 ? t.itemData(i) : undefined;

          if (!d || d.label == "template0") return false;

          connect_to_database(obj, d, t, i, true);
          return false;
        },
        /* Disconnect the database */
        disconnect_database: function disconnect_database(args) {
          var input = args || {},
              obj = this,
              t = pgBrowser.tree,
              i = input.item || t.selected(),
              d = i && i.length == 1 ? t.itemData(i) : undefined;

          if (!d) return false;

          Alertify.confirm(gettext('Disconnect the database'), S(gettext('Are you sure you want to disconnect the database - %s?')).sprintf(d.label).value(), function (evt) {
            var data = d;
            $.ajax({
              url: obj.generate_url(i, 'connect', d, true),
              type: 'DELETE',
              success: function success(res) {
                if (res.success == 1) {
                  var prv_i = t.parent(i);
                  Alertify.success(res.info);
                  t.removeIcon(i);
                  data.connected = false;
                  data.icon = 'icon-database-not-connected';
                  t.addIcon(i, { icon: data.icon });
                  t.unload(i);
                  t.setInode(i);
                  setTimeout(function () {
                    t.select(prv_i);
                  }, 10);
                } else {
                  try {
                    Alertify.error(res.errormsg);
                  } catch (e) {}
                  t.unload(i);
                }
              },
              error: function error(xhr, status, _error) {
                try {
                  var err = $.parseJSON(xhr.responseText);
                  if (err.success == 0) {
                    Alertify.error(err.errormsg);
                  }
                } catch (e) {}
                t.unload(i);
              }
            });
          }, function (evt) {
            return true;
          });

          return false;
        },

        /* Connect the database (if not connected), before opening this node */
        beforeopen: function beforeopen(item, data) {
          if (!data || data._type != 'database' || data.label == "template0") {
            return false;
          }

          pgBrowser.tree.addIcon(item, { icon: data.icon });
          if (!data.connected && data.allowConn) {
            connect_to_database(this, data, pgBrowser.tree, item, true);
            return false;
          }
          return true;
        },

        selected: function selected(item, data) {
          if (!data || data._type != 'database') {
            return false;
          }

          pgBrowser.tree.addIcon(item, { icon: data.icon });
          if (!data.connected && data.allowConn) {
            connect_to_database(this, data, pgBrowser.tree, item, false);
            return false;
          }

          return pgBrowser.Node.callbacks.selected.apply(this, arguments);
        },

        refresh: function refresh(cmd, i) {
          var self = this,
              t = pgBrowser.tree,
              item = i || t.selected(),
              d = t.itemData(item);

          if (!d.allowConn) return;
          pgBrowser.Node.callbacks.refresh.apply(this, arguments);
        }
      },
      model: pgBrowser.Node.Model.extend({
        defaults: {
          name: undefined,
          owner: undefined,
          comment: undefined,
          encoding: 'UTF8',
          template: undefined,
          tablespace: undefined,
          collation: undefined,
          char_type: undefined,
          datconnlimit: -1,
          datallowconn: undefined,
          variables: [],
          privileges: [],
          securities: [],
          datacl: [],
          deftblacl: [],
          deffuncacl: [],
          defseqacl: [],
          is_template: false,
          deftypeacl: []
        },

        // Default values!
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;

          if (isNew) {
            var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;
            this.set({ 'datowner': userInfo.name }, { silent: true });
          }
          pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
        },

        schema: [{
          id: 'name', label: gettext('Database'), cell: 'string',
          editable: false, type: 'text'
        }, {
          id: 'did', label: gettext('OID'), cell: 'string', mode: ['properties'],
          editable: false, type: 'text'
        }, {
          id: 'datowner', label: gettext('Owner'),
          editable: false, type: 'text', node: 'role',
          control: Backform.NodeListByNameControl, select2: { allowClear: false }
        }, {
          id: 'acl', label: gettext('Privileges'), type: 'text',
          group: gettext('Security'), mode: ['properties'], disabled: true
        }, {
          id: 'tblacl', label: gettext('Default TABLE privileges'), type: 'text',
          group: gettext('Security'), mode: ['properties'], disabled: true
        }, {
          id: 'seqacl', label: gettext('Default SEQUENCE privileges'), type: 'text',
          group: gettext('Security'), mode: ['properties'], disabled: true
        }, {
          id: 'funcacl', label: gettext('Default FUNCTION privileges'), type: 'text',
          group: gettext('Security'), mode: ['properties'], disabled: true
        }, {
          id: 'typeacl', label: gettext('Default TYPE privileges'), type: 'text',
          group: gettext('Security'), mode: ['properties'], disabled: true, min_version: 90200
        }, {
          id: 'comments', label: gettext('Comment'),
          editable: false, type: 'multiline'
        }, {
          id: 'encoding', label: gettext('Encoding'),
          editable: false, type: 'text', group: gettext('Definition'),
          disabled: function disabled(m) {
            return !m.isNew();
          }, url: 'get_encodings',
          control: 'node-ajax-options', cache_level: 'server'
        }, {
          id: 'template', label: gettext('Template'),
          editable: false, type: 'text', group: gettext('Definition'),
          disabled: function disabled(m) {
            return !m.isNew();
          },
          control: 'node-list-by-name', url: 'get_databases', cache_level: 'server',
          select2: { allowClear: false }, mode: ['create'],
          transform: function transform(data, cell) {
            var res = [],
                control = cell || this,
                label = control.model.get('name');

            if (!control.model.isNew()) {
              res.push({ label: label, value: label });
            } else {
              if (data && _.isArray(data)) {
                _.each(data, function (d) {
                  res.push({ label: d.label, value: d.label,
                    image: 'pg-icon-database' });
                });
              }
            }
            return res;
          }
        }, {
          id: 'spcname', label: gettext('Tablespace'),
          editable: false, type: 'text', group: gettext('Definition'),
          control: 'node-list-by-name', node: 'tablespace',
          select2: { allowClear: false },
          filter: function filter(m) {
            if (m.label == "pg_global") return false;else return true;
          }
        }, {
          id: 'datcollate', label: gettext('Collation'),
          editable: false, type: 'text', group: gettext('Definition'),
          disabled: function disabled(m) {
            return !m.isNew();
          }, url: 'get_ctypes',
          control: 'node-ajax-options', cache_level: 'server'
        }, {
          id: 'datctype', label: gettext('Character type'),
          editable: false, type: 'text', group: gettext('Definition'),
          disabled: function disabled(m) {
            return !m.isNew();
          }, url: 'get_ctypes',
          control: 'node-ajax-options', cache_level: 'server'
        }, {
          id: 'datconnlimit', label: gettext('Connection limit'),
          editable: false, type: 'int', group: gettext('Definition'), min: -1
        }, {
          id: 'is_template', label: gettext('Template?'),
          editable: false, type: 'switch', group: gettext('Definition'),
          disabled: true, mode: ['properties', 'edit'],
          options: {
            'onText': gettext('Yes'), 'offText': gettext('No'),
            'onColor': 'success', 'offColor': 'primary',
            'size': 'small'
          }
        }, {
          id: 'datallowconn', label: gettext('Allow connections?'),
          editable: false, type: 'switch', group: gettext('Definition'),
          mode: ['properties'], disabled: true,
          options: {
            'onText': 'Yes', 'offText': 'No',
            'onColor': 'success', 'offColor': 'primary',
            'size': 'small'
          }
        }, {
          id: 'datacl', label: gettext('Privileges'), type: 'collection',
          model: pgBrowser.Node.PrivilegeRoleModel.extend({
            privileges: ['C', 'T', 'c']
          }), uniqueCol: ['grantee', 'grantor'], editable: false,
          group: gettext('Security'), mode: ['edit', 'create'],
          canAdd: true, canDelete: true, control: 'unique-col-collection'
        }, {
          id: 'variables', label: gettext('Parameters'), type: 'collection',
          model: pgBrowser.Node.VariableModel.extend({ keys: ['name', 'role'] }), editable: false,
          group: gettext('Parameters'), mode: ['edit', 'create'],
          canAdd: true, canEdit: false, canDelete: true, hasRole: true,
          control: Backform.VariableCollectionControl, node: 'role'
        }, {
          id: 'seclabels', label: gettext('Security Labels'),
          model: pgBrowser.SecLabelModel,
          editable: false, type: 'collection', canEdit: false,
          group: gettext('Security'), canDelete: true,
          mode: ['edit', 'create'], canAdd: true,
          control: 'unique-col-collection', uniqueCol: ['provider'],
          min_version: 90200
        }, {
          type: 'nested', control: 'tab', group: gettext('Default Privileges'),
          mode: ['edit'],
          schema: [{
            id: 'deftblacl', model: pgBrowser.Node.PrivilegeRoleModel.extend({ privileges: ['a', 'r', 'w', 'd', 'D', 'x', 't'] }), label: gettext('Default Privileges: Tables'),
            editable: false, type: 'collection', group: gettext('Tables'),
            mode: ['edit', 'create'], control: 'unique-col-collection',
            canAdd: true, canDelete: true, uniqueCol: ['grantee', 'grantor']
          }, {
            id: 'defseqacl', model: pgBrowser.Node.PrivilegeRoleModel.extend({ privileges: ['r', 'w', 'U'] }), label: gettext('Default Privileges: Sequences'),
            editable: false, type: 'collection', group: gettext('Sequences'),
            mode: ['edit', 'create'], control: 'unique-col-collection',
            canAdd: true, canDelete: true, uniqueCol: ['grantee', 'grantor']
          }, {
            id: 'deffuncacl', model: pgBrowser.Node.PrivilegeRoleModel.extend({ privileges: ['X'] }), label: gettext('Default Privileges: Functions'),
            editable: false, type: 'collection', group: gettext('Functions'),
            mode: ['edit', 'create'], control: 'unique-col-collection',
            canAdd: true, canDelete: true, uniqueCol: ['grantee', 'grantor']
          }, {
            id: 'deftypeacl', model: pgBrowser.Node.PrivilegeRoleModel.extend({ privileges: ['U'] }), label: gettext('Default Privileges: Types'),
            editable: false, type: 'collection', group: 'deftypesacl_group',
            mode: ['edit', 'create'], control: 'unique-col-collection',
            canAdd: true, canDelete: true, uniqueCol: ['grantee', 'grantor'],
            min_version: 90200
          }, {
            id: 'deftypesacl_group', type: 'group', label: gettext('Types'),
            mode: ['edit', 'create'], min_version: 90200
          }]
        }],
        validate: function validate(keys) {
          var name = this.get('name');
          if (_.isUndefined(name) || _.isNull(name) || String(name).replace(/^\s+|\s+$/g, '') == '') {
            var msg = gettext('Name cannot be empty.');
            this.errorModel.set('name', msg);
            return msg;
          } else {
            this.errorModel.unset('name');
          }
          return null;
        }
      })
    });

    pgBrowser.SecurityGroupSchema = {
      id: 'security', label: gettext('Security'), type: 'group',
      // Show/Hide security group for nodes under the catalog
      visible: function visible(args) {
        if (args && 'node_info' in args) {
          // If node_info is not present in current object then it might in its
          // parent in case if we used sub node control
          var node_info = args.node_info || args.handler.node_info;
          return 'catalog' in node_info ? false : true;
        }
        return true;
      }
    };
  }

  return pgBrowser.Nodes['coll-database'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(24), __webpack_require__(158), __webpack_require__(9), __webpack_require__(54), __webpack_require__(195)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify, Backform) {

  if (!pgBrowser.Nodes['coll-role']) {
    var role = pgAdmin.Browser.Nodes['coll-role'] = pgAdmin.Browser.Collection.extend({
      node: 'role',
      type: 'coll-role',
      columns: ['rolname', 'rolvaliduntil', 'rolconnlimit', 'rolcanlogin', 'rolsuper', 'rolcreaterole', 'rolcreatedb', 'rolcatupdate', 'rolinherit', 'rolreplication']
    });
  };

  var SecurityModel = pgAdmin.Browser.SecurityModel = pgAdmin.Browser.SecurityModel || pgAdmin.Browser.Node.Model.extend({
    defaults: {
      provider: null,
      label: null
    },
    schema: [{
      id: 'provider', label: gettext('Provider'),
      type: 'text', disabled: false,
      cellHeaderClasses: 'width_percent_50'
    }, {
      id: 'label', label: gettext('Security Label'),
      type: 'text', disabled: false
    }],
    validate: function validate() {
      var err = {},
          errmsg = null,
          data = this.toJSON();

      if (_.isUndefined(data.provider) || _.isNull(data.provider) || String(data.provider).replace(/^\s+|\s+$/g, '') == '') {
        var msg = gettext('Please specify the value for all the security providers.');

        this.errorModel.set('provider', msg);
        return msg;
      } else {
        this.errorModel.unset('provider');
      }

      if (_.isUndefined(data.label) || _.isNull(data.label) || String(data.label).replace(/^\s+|\s+$/g, '') == '') {
        var msg = gettext('Please specify the value for all the security providers.');

        this.errorModel.set('label', msg);
        return msg;
      } else {
        this.errorModel.unset('label');
      }

      return null;
    }
  });

  var switchOptions = {
    'onText': 'Yes', 'offText': 'No',
    'size': 'mini'
  };

  var RoleCustomSwitchControl = Backform.SwitchControl.extend({
    template: _.template(['<label class="control-label pg-el-sm-9 pg-el-xs-12"><%=label%></label>', '<div class="pgadmin-controls pg-el-sm-3 pg-el-xs-12">', '  <div class="checkbox" style="float:right">', '    <label>', '      <input type="checkbox" class="<%=extraClasses.join(\' \')%>" name="<%=name%>" <%=value ? "checked=\'checked\'" : ""%> <%=disabled ? "disabled" : ""%> <%=required ? "required" : ""%> />', '    </label>', '  </div>', '  <% if (helpMessage && helpMessage.length) { %>', '    <span class="<%=Backform.helpMessageClassName%>"><%=helpMessage%></span>', '  <% } %>', '</div>'].join("\n"))
  });

  var RoleMembersControl = Backform.Control.extend({
    defaults: _.defaults({ extraClasses: ['col-xs-12 col-sm-12 col-md-12'] }, Backform.NodeListByNameControl.prototype.defaults),
    initialize: function initialize() {
      Backform.NodeListByNameControl.prototype.initialize.apply(this, arguments);
    },
    formatter: {
      fromRaw: function fromRaw(rawData, model) {
        var res = _.isObject(rawData) ? rawData : JSON.parse(rawData);

        return _.pluck(res, 'role');
      },
      toRaw: function toRaw(formattedData, model) {
        return formattedData;
      }
    },
    template: _.template(['<label class="<%=Backform.controlLabelClassName%>"><%=label%></label>', '<div class="<%=Backform.controlsClassName%>">', '  <select multiple="multiple" style="width:100%;" class="pgadmin-controls <%=extraClasses.join(\' \')%>" name="<%=name%>" value="<%-JSON.stringify(value)%>" <%=disabled ? "disabled" : ""%> <%=required ? "required" : ""%>>', '    <% for (var i=0; i < options.length; i++) { %>', '      <% var option = options[i]; %>', '      <option value=<%-option.value%> data-icon=<%-option.image%> <%=value != null && _.indexOf(value, option.value) != -1 ? "selected" : ""%> <%=option.disabled ? "disabled=\'disabled\'" : ""%>><%-option.label%></option>', '    <% } %>', '  </select>', '  <% if (helpMessage && helpMessage.length) { %>', '    <span class="<%=Backform.helpMessageClassName%>"><%=helpMessage%></span>', '  <% } %>', '</div>'].join("\n")),
    selectionTemplate: _.template(['<span>', '  <span class="wcTabIcon <%= optimage %>"></span>', '  <span><%= opttext %><span>', '  <% if (checkbox) { %>', '  <input type="checkbox" <%=disabled ? "disabled=\'disabled\'" : ""%>/>', '  <% } %>', '</span>'].join("\n")),
    events: { "change select": "onChange" },
    getValueFromDOM: function getValueFromDOM() {
      var res = [];

      this.$el.find("select").find(':selected').each(function () {
        res.push($(this).attr('value'));
      });

      return res;
    },
    render: function render() {
      var field = _.defaults(this.field.toJSON(), this.defaults),
          attributes = this.model.toJSON(),
          attrArr = field.name.split('.'),
          name = attrArr.shift(),
          path = attrArr.join('.'),
          rawValue = this.keyPathAccessor(attributes[name], path),
          data = _.extend(field, {
        rawValue: rawValue,
        value: this.formatter.fromRaw(rawValue, this.model),
        attributes: attributes,
        formatter: this.formatter
      }),
          evalF = function evalF(f, d, m) {
        return _.isFunction(f) ? !!f.apply(d, [m]) : !!f;
      },
          evalASFunc = function evalASFunc(f, d, m) {
        return _.isFunction(f) ? f.apply(d, [m]) : f;
      };

      // Evaluate the disabled, visible, and required option
      _.extend(data, {
        disabled: evalF(data.disabled, data, this.model),
        visible: evalF(data.visible, data, this.model),
        required: evalF(data.required, data, this.model),
        helpMessage: evalASFunc(data.helpMessage, data, this.model)
      });
      // Evaluation the options
      if (_.isFunction(data.options)) {
        try {
          data.options = data.options.apply(this);
        } catch (e) {
          // Do nothing
          data.options = [];
          this.model.trigger('pgadmin-view:transform:error', m, self.field, e);
        }
      }

      // Clean up first
      this.$el.removeClass(Backform.hiddenClassName);

      if (!data.visible) this.$el.addClass(Backform.hiddenClassName);

      this.$el.html(this.template(data)).addClass(field.name);
      this.updateInvalid();

      var self = this,
          collection = this.model.get(this.field.get('name')),
          formatState = function formatState(opt) {
        if (!opt.id) {
          return opt.text;
        }

        var optimage = $(opt.element).data('icon');

        if (!optimage) {
          return opt.text;
        } else {
          var d = _.extend({}, data, {
            'opttext': _.escape(opt.text),
            'optimage': optimage,
            'checkbox': false
          });
          return $(self.selectionTemplate(d));
        }
      },
          formatSelection = function formatSelection(opt) {

        if (!opt.id) {
          return opt.text;
        }

        var optimage = $(opt.element).data('icon'),
            grantUpdate = function grantUpdate(ev) {

          _.each(collection.where({ role: opt.id }), function (m) {
            m.set('admin', $(ev.target).is(":checked"));
          });

          return false;
        };

        if (!optimage) {
          return opt.text;
        } else {
          var d = _.extend({}, data, {
            'opttext': _.escape(opt.text),
            'optimage': optimage,
            'checkbox': true
          }),
              j = $(self.selectionTemplate(d));

          // Update the checkbox lazy
          setTimeout(function () {
            _.each(collection.where({ role: opt.id }), function (m) {
              j.find('input').prop('checked', m.get('admin'));
            });
          }, 200);

          j.find('input').on('change', grantUpdate);

          return j;
        }
      };

      this.$el.find('select').select2({
        templateResult: formatState,
        templateSelection: formatSelection,
        multiple: true,
        tags: true,
        allowClear: data.disabled ? false : true,
        placeholder: data.disabled ? "" : gettext("Select members"),
        width: 'style'
      }).on("change", function (e) {
        $(e.target).find(':selected').each(function () {});
      });

      return this;
    },
    onChange: function onChange(e) {
      var model = this.model,
          $el = $(e.target),
          attrArr = this.field.get("name").split('.'),
          name = attrArr.shift(),
          path = attrArr.join('.'),
          vals = this.getValueFromDOM(),
          collection = model.get(name),
          removed = [];

      this.stopListening(this.model, "change:" + name, this.render);

      /*
       * Iterate through all the values, and find out how many are already
       * present in the collection.
       */
      collection.each(function (m) {
        var role = m.get('role'),
            idx = _.indexOf(vals, role);

        if (idx > -1) {
          vals.splice(idx, 1);
        } else {
          removed.push(role);
        }
      });

      /*
       * Adding new values
       */
      _.each(vals, function (v) {
        collection.add({ role: v });
      });

      /*
       * Removing unwanted!
       */
      _.each(removed, function (v) {
        collection.remove(collection.where({ role: v }));
      });

      this.listenTo(this.model, "change:" + name, this.render);
    }
  });

  if (!pgBrowser.Nodes['role']) {
    var _ref;

    var role = pgAdmin.Browser.Nodes['role'] = pgAdmin.Browser.Node.extend({
      parent_type: 'server',
      type: 'role',
      sqlAlterHelp: 'sql-alterrole.html',
      sqlCreateHelp: 'sql-createrole.html',
      dialogHelp: url_for('help.static', { 'filename': 'role_dialog.html' }),
      label: gettext('Login/Group Role'),
      hasSQL: true,
      canDrop: function canDrop(node, item) {
        var treeData = this.getTreeNodeHierarchy(item),
            server = treeData['server'];
        /*
        To Drop a role:
          1) If Role we are deleting is superuser then User must be superuser
          2) And for non-superuser roles User must have Create Role permission
        */

        // Role you are trying to drop is Superuser ?
        if (node.is_superuser) {
          return server.connected && server.user.is_superuser;
        }
        // For non super users
        return server.connected && server.user.can_create_role;
      },
      hasDepends: true,
      node_label: function node_label(r) {
        return r.label;
      },
      node_image: function node_image(r) {
        if (r == null || r == undefined) return 'icon-role';
        return r.can_login ? 'icon-role' : 'icon-group';
      },
      title: function title(d) {
        if (!d) {
          return this.label;
        }
        if (d.can_login) {
          return gettext('Login Role') + ' - ' + d.label;
        }
        return gettext('Group Role') + ' - ' + d.label;
      },
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_role_on_server', node: 'server', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Login/Group Role...'),
          icon: 'wcTabIcon icon-role', data: { action: 'create' },
          enable: 'can_create_role'
        }, {
          name: 'create_role_on_roles', node: 'coll-role', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Login/Group Role...'),
          icon: 'wcTabIcon icon-role', data: { action: 'create' },
          enable: 'can_create_role'
        }, {
          name: 'create_role', node: 'role', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Login/Group Role...'),
          icon: 'wcTabIcon icon-role', data: { action: 'create' },
          enable: 'can_create_role'
        }]);
      },
      can_create_role: function can_create_role(node, item) {
        var treeData = this.getTreeNodeHierarchy(item),
            server = treeData['server'];

        return server.connected && server.user.can_create_role;
      },
      model: pgAdmin.Browser.Node.Model.extend({
        idAttribute: 'oid',
        defaults: {
          oid: null,
          rolname: undefined,
          rolcanlogin: false,
          rolpassword: null,
          rolconnlimit: -1,
          rolsuper: false,
          rolcreaterole: false,
          rolcreatedb: false,
          rolinherit: true,
          rolcatupdate: false,
          rolreplication: false,
          rolmembership: [],
          rolvaliduntil: null,
          seclabels: [],
          variables: []
        },
        schema: [{
          id: 'rolname', label: gettext('Name'), type: 'text',
          disabled: 'readonly'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string', mode: ['properties'],
          editable: false, type: 'text', visible: true, disabled: true
        }, {
          id: 'rolpassword', label: gettext('Password'), type: 'password',
          group: gettext('Definition'), mode: ['edit', 'create'],
          control: 'input', deps: ['rolcanlogin'], retype: true,
          cell: 'string', disabled: function disabled(m) {
            if (!m.isNew()) {
              var user = this.node_info.server.user;

              return !(user.is_superuser || user.can_create_role) && user.id != m.get('oid');
            }
            return false;
          }
        }, {
          id: 'rolvaliduntil', disabled: 'readonly', type: 'text',
          group: gettext('Definition'), label: gettext('Account expires'),
          mode: ['properties', 'edit', 'create'], control: 'datetimepicker',
          deps: ['rolcanlogin'], options: { format: 'YYYY-MM-DD HH:mm:ss Z' }
        }, {
          id: 'rolconnlimit', type: 'int', group: gettext('Definition'),
          label: gettext('Connection limit'), cell: 'integer', min: -1,
          mode: ['properties', 'edit', 'create'], disabled: 'readonly'
        }, {
          id: 'rolcanlogin', label: gettext('Can login?'), type: 'switch',
          group: gettext('Privileges'), options: switchOptions,
          disabled: 'readonly', control: RoleCustomSwitchControl
        }, {
          id: 'rolsuper', label: gettext('Superuser'), type: 'switch',
          group: gettext('Privileges'), options: switchOptions,
          control: RoleCustomSwitchControl.extend({
            onChange: function onChange() {
              Backform.SwitchControl.prototype.onChange.apply(this, arguments);

              this.model.set('rolcatupdate', this.model.get('rolsuper'));
              this.model.set('rolcreaterole', this.model.get('rolsuper'));
              this.model.set('rolcreatedb', this.model.get('rolsuper'));
            }
          }),
          disabled: 'readonly'
        }, {
          id: 'rolcreaterole', label: gettext('Create roles?'),
          group: gettext('Privileges'), type: 'switch',
          options: switchOptions, disabled: 'readonly',
          control: RoleCustomSwitchControl
        }, {
          id: 'description', label: gettext('Comments'), type: 'multiline',
          group: null, mode: ['properties', 'edit', 'create'],
          options: switchOptions, disabled: 'readonly'
        }, {
          id: 'rolcreatedb', label: gettext('Create databases?'),
          group: gettext('Privileges'), type: 'switch',
          options: switchOptions, disabled: 'readonly',
          control: RoleCustomSwitchControl
        }, {
          id: 'rolcatupdate', label: gettext('Update catalog?'),
          type: 'switch', max_version: 90400, options: switchOptions,
          control: RoleCustomSwitchControl,
          group: gettext('Privileges'), disabled: function disabled(m) {
            return m.get('read_only') || !m.get('rolsuper');
          }
        }, {
          id: 'rolinherit', group: gettext('Privileges'),
          label: gettext('Inherit rights from the parent roles?'),
          type: 'switch', options: switchOptions, disabled: 'readonly',
          control: RoleCustomSwitchControl
        }, {
          id: 'rolreplication', group: gettext('Privileges'),
          label: gettext('Can initiate streaming replication and backups?'),
          type: 'switch', min_version: 90100, options: switchOptions,
          disabled: 'readonly', control: RoleCustomSwitchControl
        }, {
          id: 'rolmembership', label: gettext('Roles'),
          group: gettext('Membership'), type: 'collection',
          cell: 'string', disabled: 'readonly',
          mode: ['properties', 'edit', 'create'],
          control: RoleMembersControl, model: pgBrowser.Node.Model.extend({
            keys: ['role'],
            idAttribute: 'role',
            defaults: {
              role: undefined,
              admin: false
            },
            validate: function validate() {
              return null;
            }
          }),
          filter: function filter(d) {
            return this.model.isNew() || this.model.get('rolname') != d.label;
          },
          helpMessage: function helpMessage(m) {
            if (m.has('read_only') && m.get('read_only') == false) {
              return gettext('Select the checkbox for roles to include WITH ADMIN OPTION.');
            } else {
              return gettext('Roles shown with a check mark have the WITH ADMIN OPTION set.');
            }
          }
        }, (_ref = {
          id: 'variables', label: gettext('Parameters'), type: 'collection',
          group: gettext('Parameters'), hasDatabase: true, url: 'variables',
          model: pgBrowser.Node.VariableModel.extend({ keys: ['name', 'database'] }),
          control: 'variable-collection',
          mode: ['edit', 'create'], canAdd: true, canDelete: true
        }, _defineProperty(_ref, 'url', "variables"), _defineProperty(_ref, 'disabled', 'readonly'), _ref), {
          id: 'seclabels', label: gettext('Security Labels'),
          model: SecurityModel, editable: false, type: 'collection',
          group: gettext('Security'), mode: ['edit', 'create'],
          min_version: 90200, disabled: 'readonly', canAdd: true,
          canEdit: false, canDelete: true, control: 'unique-col-collection'
        }],
        readonly: function readonly(m) {
          if (!m.has('read_only')) {
            var user = this.node_info.server.user;

            m.set('read_only', !(user.is_superuser || user.can_create_role));
          }

          return m.get('read_only');
        },
        validate: function validate() {
          var err = {},
              errmsg,
              seclabels = this.get('seclabels');

          if (_.isUndefined(this.get('rolname')) || String(this.get('rolname')).replace(/^\s+|\s+$/g, '') == '') {
            err['name'] = gettext('Name cannot be empty.');
            errmsg = errmsg || err['name'];
          }

          if (seclabels) {
            var secLabelsErr;
            for (var i = 0; i < seclabels.models.length && !secLabelsErr; i++) {
              secLabelsErr = seclabels.models[i].validate.apply(seclabels.models[i]);
              if (secLabelsErr) {
                err['seclabels'] = secLabelsErr;
                errmsg = errmsg || secLabelsErr;
              }
            }
          }

          this.errorModel.clear().set(err);

          if (_.size(err)) {
            this.trigger('on-status', { msg: errmsg });
            return errmsg;
          }

          return null;
        }
      })
    });
  }

  return pgBrowser.Nodes['role'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(17), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {
  // Extend the collection class for cast
  if (!pgBrowser.Nodes['coll-cast']) {
    var casts = pgAdmin.Browser.Nodes['coll-cast'] = pgAdmin.Browser.Collection.extend({
      node: 'cast',
      label: gettext('Casts'),
      type: 'coll-cast',
      columns: ['name', 'description']
    });
  };

  // Extend the node class for cast
  if (!pgBrowser.Nodes['cast']) {
    var _ref;

    pgAdmin.Browser.Nodes['cast'] = pgAdmin.Browser.Node.extend({
      parent_type: 'database',
      type: 'cast',
      sqlAlterHelp: 'sql-altercast.html',
      sqlCreateHelp: 'sql-createcast.html',
      dialogHelp: url_for('help.static', { 'filename': 'cast_dialog.html' }),
      canDrop: true,
      canDropCascade: true,
      label: gettext('Cast'),
      hasSQL: true,
      hasDepends: true,
      Init: function Init() {

        // Avoid multiple registration of menus
        if (this.initialized) return;

        this.initialized = true;

        // Add context menus for cast
        pgBrowser.add_menus([{
          name: 'create_cast_on_database', node: 'database', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Cast...'),
          icon: 'wcTabIcon icon-cast', data: { action: 'create' },
          enable: pgBrowser.Nodes['database'].is_conn_allow
        }, {
          name: 'create_cast_on_coll', node: 'coll-cast', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Cast...'),
          icon: 'wcTabIcon icon-cast', data: { action: 'create' }
        }, {
          name: 'create_cast', node: 'cast', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Cast...'),
          icon: 'wcTabIcon icon-cast', data: { action: 'create' }
        }]);
      },

      // Define the backform model for cast node
      model: pgAdmin.Browser.Node.Model.extend({
        defaults: {
          name: undefined, // Name of the cast
          encoding: 'UTF8',
          srctyp: undefined, // Source type
          trgtyp: undefined, // Target type
          proname: undefined, // Function
          castcontext: undefined, // Context (IMPLICIT/EXPLICIT/ASSIGNMENT)
          syscast: undefined, // Is this cast is system object? Yes/No
          description: undefined // Comment on the cast
        },

        // Define the schema for cast
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          editable: false, type: 'text', disabled: true, cellHeaderClasses: 'width_percent_50'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          editable: false, type: 'text', disabled: true, mode: ['properties']
        }, {
          id: 'srctyp', label: gettext('Source type'), url: 'get_type',
          type: 'text', group: gettext('Definition'), disabled: function disabled(m) {
            return !m.isNew();
          }, mode: ['create'],

          transform: function transform(rows) {
            _.each(rows, function (r) {
              r['image'] = 'icon-cast';
            });
            return rows;
          },

          /*
           * Control is extended to create cast name from source type and destination type
           * once their values are changed
           */
          control: Backform.NodeAjaxOptionsControl.extend({

            onChange: function onChange() {
              Backform.NodeAjaxOptionsControl.prototype.onChange.apply(this, arguments);

              /*
               * On source type change, check if both source type and
               * target type are set, if yes then fetch values from both
               * controls and generate cast name
               */
              var srctype = this.model.get('srctyp');
              var trgtype = this.model.get('trgtyp');
              if (srctype != undefined && srctype != '' && trgtype != undefined && trgtype != '') this.model.set("name", srctype + "->" + trgtype);else this.model.unset("name");
            }
          })
        },

        /*
         * Text control for viewing source type in properties and
         * edit mode only
         */
        {
          id: 'srctyp', label: gettext('Source type'), type: 'text',
          group: gettext('Definition'), disabled: true, mode: ['properties', 'edit']
        }, {
          id: 'trgtyp', label: gettext('Target type'), url: 'get_type',
          type: 'text', group: gettext('Definition'), disabled: function disabled(m) {
            return !m.isNew();
          }, mode: ['create'],
          transform: function transform(rows) {
            _.each(rows, function (r) {
              r['image'] = 'icon-cast';
            });
            return rows;
          },

          /*
           * Control is extended to create cast name from source type and destination type
           * once their values are changed
           */
          control: Backform.NodeAjaxOptionsControl.extend({

            onChange: function onChange() {
              Backform.NodeAjaxOptionsControl.prototype.onChange.apply(this, arguments);

              /*
               * on target type change, check if both source type and
               * target type are set, if yes then fetch values from both
               * controls and generate cast name
               */
              var srcType = this.model.get('srctyp');
              var trgtype = this.model.get('trgtyp');
              if (srcType != undefined && srcType != '' && trgtype != undefined && trgtype != '') this.model.set("name", srcType + "->" + trgtype);else this.model.unset("name");
            }
          })
        },
        /*
         * Text control for viewing target type in properties and
         * edit mode only
         */
        {
          id: 'trgtyp', label: gettext('Target type'), type: 'text',
          group: gettext('Definition'), disabled: true, mode: ['properties', 'edit']
        },

        /*
         * Proname field is dependent on source type and target type.
         * On source and target type changed event,
         * associated functions will be fetch using ajax call
         */
        {
          id: 'proname', label: gettext('Function'), deps: ['srctyp', 'trgtyp'],
          type: 'text', disabled: function disabled(m) {
            return !m.isNew();
          },
          group: gettext('Definition'), mode: ['create'],
          control: 'node-ajax-options',
          options: function options(control) {
            var srcTyp = control.model.get('srctyp');
            var trgtyp = control.model.get('trgtyp');
            var res = [];

            if (srcTyp != undefined && srcTyp != '' && trgtyp != undefined && trgtyp != '') {
              var node = control.field.get('schema_node'),
                  _url = node.generate_url.apply(node, [null, 'get_functions', control.field.get('node_data'), false, control.field.get('node_info')]);
              $.ajax({
                type: 'POST',
                timeout: 30000,
                url: _url,
                cache: false,
                async: false,
                data: { "srctyp": srcTyp, "trgtyp": trgtyp },

                // On success return function list from server
                success: function success(result) {
                  res = result.data;
                  return res;
                },

                // On failure show error appropriate error message to user
                error: function error(xhr, status, _error) {
                  try {
                    var err = $.parseJSON(xhr.responseText);
                    if (err.success == 0) {
                      alertify.error(err.errormsg);
                    }
                  } catch (e) {}
                }
              });
            }
            return res;
          }
        },
        /*
         * Text type control for viewing function name in properties and
         * edit mode only
         */
        {
          id: 'proname', label: gettext('Function'), type: 'text',
          group: gettext('Definition'), disabled: true, mode: ['properties', 'edit']
        }, {
          id: 'castcontext', label: gettext('Context'),
          options: { 'onText': 'IMPLICIT', 'offText': 'EXPLICIT' },
          editable: false, type: 'string', group: gettext('Definition'),
          mode: ['create'],
          control: Backform.SwitchControl.extend({
            getValueFromDOM: function getValueFromDOM() {
              return this.$input.prop('checked') ? 'IMPLICIT' : 'EXPLICIT';
            }
          })
        },
        /*
         * Text control for viewing context in properties and
         * edit mode
         */
        {
          id: 'castcontext', label: gettext('Context'), disabled: true,
          options: [{
            label: 'IMPLICIT', value: 'IMPLICIT'
          }, {
            label: 'EXPLICIT', value: 'EXPLICIT'
          }, {
            label: 'ASSIGNMENT', value: 'ASSIGNMENT'
          }], editable: false, type: 'select2', group: gettext('Definition'),
          mode: ['properties', 'edit']
        }, {
          id: 'syscast', label: gettext('System cast?'),
          cell: 'switch', type: 'switch', mode: ['properties'], disabled: true,
          options: {
            'onText': 'Yes', 'offText': 'No',
            'onColor': 'success', 'offColor': 'primary',
            'size': 'small'
          }
        }, (_ref = {
          id: 'description', label: gettext('Comment'), type: 'text'
        }, _defineProperty(_ref, 'type', 'multiline'), _defineProperty(_ref, 'cellHeaderClasses', 'width_percent_50'), _ref)],

        /*
         * Triggers control specific error messages for source type and
         * target type if any one of them is not selected while creating
         * new cast
         */
        validate: function validate(keys) {

          var srctype = this.get('srctyp');
          var trgtype = this.get('trgtyp');

          // validate source type control
          if (_.isUndefined(srctype) || _.isNull(srctype) || String(srctype).replace(/^\s+|\s+$/g, '') == '') {
            var msg = gettext('Source type must be selected.');
            this.errorModel.set('srctyp', msg);
            return msg;
          } else {
            this.errorModel.unset('srctyp');
          }

          // validate target type control
          if (_.isUndefined(trgtype) || _.isNull(trgtype) || String(trgtype).replace(/^\s+|\s+$/g, '') == '') {
            var msg = gettext('Target type must be selected.');
            this.errorModel.set('trgtyp', msg);
            return msg;
          } else {
            this.errorModel.unset('trgtyp');
          }
          this.trigger('on-status-clear');
          return null;
        }
      })
    });
  }
  return pgBrowser.Nodes['coll-cast'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backbone) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(17), __webpack_require__(9), __webpack_require__(54), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  if (!pgBrowser.Nodes['coll-tablespace']) {
    var databases = pgBrowser.Nodes['coll-tablespace'] = pgBrowser.Collection.extend({
      node: 'tablespace',
      label: gettext('Tablespaces'),
      type: 'coll-tablespace',
      columns: ['name', 'spcuser', 'description'],
      hasStatistics: true,
      statsPrettifyFields: ['Size']
    });
  };

  if (!pgBrowser.Nodes['tablespace']) {
    pgBrowser.Nodes['tablespace'] = pgBrowser.Node.extend({
      parent_type: 'server',
      type: 'tablespace',
      sqlAlterHelp: 'sql-altertablespace.html',
      sqlCreateHelp: 'sql-createtablespace.html',
      dialogHelp: url_for('help.static', { 'filename': 'tablespace_dialog.html' }),
      label: gettext('Tablespace'),
      hasSQL: true,
      canDrop: true,
      hasDepends: true,
      hasStatistics: true,
      statsPrettifyFields: ['Size'],
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_tablespace_on_server', node: 'server', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Tablespace...'),
          icon: 'wcTabIcon icon-tablespace', data: { action: 'create' },
          enable: 'can_create_tablespace'
        }, {
          name: 'create_tablespace_on_coll', node: 'coll-tablespace', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Tablespace...'),
          icon: 'wcTabIcon icon-tablespace', data: { action: 'create' },
          enable: 'can_create_tablespace'
        }, {
          name: 'create_tablespace', node: 'tablespace', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Tablespace...'),
          icon: 'wcTabIcon icon-tablespace', data: { action: 'create' },
          enable: 'can_create_tablespace'
        }, {
          name: 'move_tablespace', node: 'tablespace', module: this,
          applies: ['object', 'context'], callback: 'move_objects',
          category: 'move_tablespace', priority: 5,
          label: gettext('Move objects to...'),
          icon: 'fa fa-exchange', data: { action: 'create' },
          enable: 'can_move_objects'
        }]);
      },
      can_create_tablespace: function can_create_tablespace(node, item) {
        var treeData = this.getTreeNodeHierarchy(item),
            server = treeData['server'];

        return server.connected && server.user.is_superuser;
      },
      can_move_objects: function can_move_objects(node, item) {
        var treeData = this.getTreeNodeHierarchy(item),
            server = treeData['server'];
        // Only supported PG9.4 and above version
        return server.connected && server.user.is_superuser && server.version >= 90400;
      },
      callbacks: {
        /* Move objects from one tablespace to another */
        move_objects: function move_objects(args) {
          var input = args || {},
              obj = this,
              t = pgBrowser.tree,
              i = input.item || t.selected(),
              d = i && i.length == 1 ? t.itemData(i) : undefined,
              node = d && pgBrowser.Nodes[d._type],
              url = obj.generate_url(i, 'move_objects', d, true),
              msql_url = obj.generate_url(i, 'move_objects_sql', d, true);

          if (!d) return false;

          // Object model
          var objModel = Backbone.Model.extend({
            idAttribute: 'id',
            defaults: {
              new_tblspc: undefined,
              obj_type: 'all',
              user: undefined
            },
            schema: [{
              id: 'tblspc', label: gettext('New tablespace'),
              type: 'text', disabled: false, control: 'node-list-by-name',
              node: 'tablespace', select2: { allowClear: false },
              filter: function filter(o) {
                return o && o.label != d.label;
              }
            }, {
              id: 'obj_type', label: gettext('Object type'),
              type: 'text', disabled: false, control: 'select2',
              select2: { allowClear: false, width: "100%" },
              options: [{ label: "All", value: 'all' }, { label: "Tables", value: 'tables' }, { label: "Indexes", value: 'indexes' }, { label: "Materialized views", value: 'materialized_views' }]
            }, {
              id: 'user', label: gettext('Object owner'),
              type: 'text', disabled: false, control: 'node-list-by-name',
              node: 'role', select2: { allowClear: false }
            }, {
              id: 'sqltab', label: gettext('SQL'), group: gettext('SQL'),
              type: 'text', disabled: false, control: Backform.SqlTabControl.extend({
                initialize: function initialize() {
                  // Initialize parent class
                  Backform.SqlTabControl.prototype.initialize.apply(this, arguments);
                },
                onTabChange: function onTabChange(obj) {
                  // Fetch the information only if the SQL tab is visible at the moment.
                  if (this.dialog && obj.shown == this.tabIndex) {
                    var self = this,
                        args = self.model.toJSON();
                    // Add existing tablespace
                    args.old_tblspc = d.label;

                    // Fetches modified SQL
                    $.ajax({
                      url: msql_url,
                      type: 'GET',
                      cache: false,
                      data: args,
                      dataType: "json",
                      contentType: "application/json"
                    }).done(function (res) {
                      self.sqlCtrl.clearHistory();
                      self.sqlCtrl.setValue(res.data);
                      self.sqlCtrl.refresh();
                    }).fail(function () {
                      self.model.trigger('pgadmin-view:msql:error');
                    }).always(function () {
                      self.model.trigger('pgadmin-view:msql:fetched');
                    });
                  }
                }
              })
            }],
            validate: function validate() {
              return null;
            }
          });

          if (!alertify.move_objects_dlg) {
            alertify.dialog('move_objects_dlg', function factory() {
              return {
                main: function main() {
                  var title = gettext('Move objects to another tablespace ');
                  this.set('title', title);
                },
                build: function build() {
                  alertify.pgDialogBuild.apply(this);
                },
                setup: function setup() {
                  return {
                    buttons: [{
                      text: '', key: 112, className: 'btn btn-default pull-left fa fa-lg fa-question',
                      attrs: { name: 'dialog_help', type: 'button', label: gettext('Users'),
                        url: url_for('help.static', { 'filename': 'move_objects.html' }) }
                    }, {
                      text: gettext('OK'), key: 13, className: 'btn btn-primary fa fa-lg fa-save pg-alertify-button'
                    }, {
                      text: gettext('Cancel'), key: 27, className: 'btn btn-danger fa fa-lg fa-times pg-alertify-button'
                    }],
                    // Set options for dialog
                    options: {
                      //disable both padding and overflow control.
                      padding: !1,
                      overflow: !1,
                      modal: false,
                      resizable: true,
                      maximizable: true,
                      pinnable: false,
                      closableByDimmer: false
                    }
                  };
                },
                hooks: {
                  // Triggered when the dialog is closed
                  onclose: function onclose() {
                    if (this.view) {
                      // clear our backform model/view
                      this.view.remove({ data: true, internal: true, silent: true });
                    }
                  }
                },
                prepare: function prepare() {
                  var self = this,
                      $container = $("<div class='move_objects'></div>");
                  //Disbale Okay button
                  this.__internal.buttons[1].element.disabled = true;
                  // Find current/selected node
                  var t = pgBrowser.tree,
                      i = t.selected(),
                      d = i && i.length == 1 ? t.itemData(i) : undefined,
                      node = d && pgBrowser.Nodes[d._type];

                  if (!d) return;
                  // Create treeInfo
                  var treeInfo = node.getTreeNodeHierarchy.apply(node, [i]);
                  // Instance of backbone model
                  var newModel = new objModel({}, { node_info: treeInfo }),
                      fields = Backform.generateViewSchema(treeInfo, newModel, 'create', node, treeInfo.server, true);

                  var view = this.view = new Backform.Dialog({
                    el: $container, model: newModel, schema: fields
                  });
                  // Add our class to alertify
                  $(this.elements.body.childNodes[0]).addClass('alertify_tools_dialog_properties obj_properties');
                  // Render dialog
                  view.render();

                  this.elements.content.appendChild($container.get(0));

                  // Listen to model & if filename is provided then enable Backup button
                  this.view.model.on('change', function () {
                    if (!_.isUndefined(this.get('tblspc')) && this.get('tblspc') !== '') {
                      this.errorModel.clear();
                      self.__internal.buttons[1].element.disabled = false;
                    } else {
                      self.__internal.buttons[1].element.disabled = true;
                      this.errorModel.set('tblspc', gettext('Please select tablespace'));
                    }
                  });
                },
                // Callback functions when click on the buttons of the Alertify dialogs
                callback: function callback(e) {
                  if (e.button.element.name == "dialog_help") {
                    e.cancel = true;
                    pgBrowser.showHelp(e.button.element.name, e.button.element.getAttribute('url'), null, null, e.button.element.getAttribute('label'));
                    return;
                  }
                  if (e.button.text === gettext('OK')) {
                    var self = this,
                        args = this.view.model.toJSON();
                    args.old_tblspc = d.label;
                    e.cancel = true;
                    alertify.confirm(gettext('Move objects...'), gettext('Are you sure you wish to move objects %(old_tablespace)s to %s(new_tablespace)s', { old_tablespace: args.old_tblspc, new_tablespace: args.tblspc }), function () {
                      $.ajax({
                        url: url,
                        method: 'PUT',
                        data: { 'data': JSON.stringify(args) },
                        success: function success(res) {
                          if (res.success) {
                            alertify.success(res.info);
                            self.close();
                          } else {
                            alertify.error(res.errormsg);
                          }
                        },
                        error: function error(xhr, status, _error) {
                          try {
                            var err = $.parseJSON(xhr.responseText);
                            if (err.success == 0) {
                              alertify.error(err.errormsg);
                            }
                          } catch (e) {}
                        }
                      });
                    }, function () {
                      // Do nothing as user cancel the operation
                    });
                  }
                }
              };
            });
          }
          alertify.move_objects_dlg(true).resizeTo('40%', '50%');;
        }
      },
      model: pgBrowser.Node.Model.extend({
        defaults: {
          name: undefined,
          owner: undefined,
          comment: undefined,
          spclocation: undefined,
          spcoptions: [],
          spcacl: [],
          seclabels: []
        },

        // Default values!
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;

          if (isNew) {
            var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;
            this.set({ 'spcuser': userInfo.name }, { silent: true });
          }
          pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
        },

        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', disabled: true, mode: ['properties']
        }, {
          id: 'spclocation', label: gettext('Location'), cell: 'string',
          group: gettext('Definition'), type: 'text', mode: ['properties', 'edit', 'create'],
          disabled: function disabled(m) {
            // To disabled it in edit mode,
            // We'll check if model is new if yes then disabled it
            return !m.isNew();
          }
        }, {
          id: 'spcuser', label: gettext('Owner'), cell: 'string',
          type: 'text', control: 'node-list-by-name', node: 'role',
          select2: { allowClear: false }
        }, {
          id: 'acl', label: gettext('Privileges'), type: 'text',
          group: gettext('Security'), mode: ['properties'], disabled: true
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline'
        }, {
          id: 'spcoptions', label: gettext('Parameters'), type: 'collection',
          group: gettext("Parameters"), control: 'variable-collection',
          model: pgBrowser.Node.VariableModel,
          mode: ['edit', 'create'], canAdd: true, canEdit: false,
          canDelete: true
        }, {
          id: 'spcacl', label: gettext('Privileges'), type: 'collection',
          group: gettext('Security'), control: 'unique-col-collection',
          model: pgBrowser.Node.PrivilegeRoleModel.extend({ privileges: ['C'] }),
          mode: ['edit', 'create'], canAdd: true, canDelete: true,
          uniqueCol: ['grantee'],
          columns: ['grantee', 'grantor', 'privileges']
        }, {
          id: 'seclabels', label: gettext('Security Labels'),
          model: pgBrowser.SecLabelModel, editable: false, type: 'collection',
          group: gettext('Security'), mode: ['edit', 'create'],
          min_version: 90200, canAdd: true,
          canEdit: false, canDelete: true, control: 'unique-col-collection'
        }],
        validate: function validate() {
          var err = {},
              errmsg = null,
              changedAttrs = this.sessAttrs,
              msg = undefined;
          if (_.isUndefined(this.get('name')) || String(this.get('name')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Name cannot be empty.');
            this.errorModel.set('name', msg);
          } else if (_.isUndefined(this.get('spclocation')) || String(this.get('spclocation')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Location cannot be empty.');
            this.errorModel.set('spclocation', msg);
          } else {
            this.errorModel.unset('name');
            this.errorModel.unset('spclocation');
          }
          return null;
        }
      })
    });
  }

  return pgBrowser.Nodes['coll-tablespace'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(1), __webpack_require__(6), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, _, pgBrowser) {

  // Extend the browser's collection class for resource group collection
  if (!pgBrowser.Nodes['coll-resource_group']) {
    pgBrowser.Nodes['coll-resource_group'] = pgBrowser.Collection.extend({
      node: 'resource_group',
      label: gettext('Resource Groups'),
      type: 'coll-resource_group',
      columns: ['name', 'cpu_rate_limit', 'dirty_rate_limit']
    });
  }

  // Extend the browser's node class for resource group node
  if (!pgBrowser.Nodes['resource_group']) {
    pgBrowser.Nodes['resource_group'] = pgBrowser.Node.extend({
      parent_type: 'server',
      type: 'resource_group',
      dialogHelp: url_for('help.static', { 'ilename': 'resource_group_dialog.html' }),
      label: gettext('Resource Group'),
      hasSQL: true,
      canDrop: true,
      Init: function Init() {

        // Avoid multiple registration of menus
        if (this.initialized) {
          return;
        }

        this.initialized = true;

        // Creating menu for the resource group node
        pgBrowser.add_menus([{
          name: 'create_resourcegroup_on_server', node: 'server', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Resource Group...'),
          icon: 'wcTabIcon icon-resource_group', data: { action: 'create' },
          /* Function is used to check the server type and version.
           * Resource Group only supported in PPAS 9.4 and above.
           */
          enable: function enable(node, item) {
            var treeData = this.getTreeNodeHierarchy(item),
                server = treeData['server'];
            return server.connected && node.server_type === 'ppas' && node.version >= 90400;
          }
        }, {
          name: 'create_resource_group_on_coll', node: 'coll-resource_group', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Resource Group...'),
          icon: 'wcTabIcon icon-resource_group', data: { action: 'create' }
        }, {
          name: 'create_resource_group', node: 'resource_group', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Resource Group...'),
          icon: 'wcTabIcon icon-resource_group', data: { action: 'create' }
        }]);
      },

      // Defining model for resource group node
      model: pgBrowser.Node.Model.extend({
        defaults: {
          name: undefined,
          cpu_rate_limit: 0.0,
          dirty_rate_limit: 0.0
        },

        // Defining schema for the resource group node
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text'
        }, {
          id: 'cpu_rate_limit', label: gettext('CPU rate limit (%%)'), cell: 'string',
          type: 'numeric', min: 0, max: 16777216
        }, {
          id: 'dirty_rate_limit', label: gettext('Dirty rate limit (KB)'), cell: 'string',
          type: 'numeric', min: 0, max: 16777216
        }],

        /* validate function is used to validate the input given by
         * the user. In case of error, message will be displayed on
         * the GUI for the respective control.
         */
        validate: function validate(keys) {
          var msg,
              cpu_rate_limit,
              dirty_rate_limit,
              name,
              name = this.get('name');
          if (_.isUndefined(name) || _.isNull(name) || String(name).replace(/^\s+|\s+$/g, '') == '') {
            var msg = gettext('Name cannot be empty.');
            this.errorModel.set('name', msg);
            return msg;
          } else {
            this.errorModel.unset('name');
          }

          var cpu_rate_limit = this.get('cpu_rate_limit');
          if (_.isUndefined(cpu_rate_limit) || _.isNull(cpu_rate_limit) || String(cpu_rate_limit).replace(/^\s+|\s+$/g, '') == '') {
            var msg = gettext('CPU rate limit cannot be empty.');
            this.errorModel.set('cpu_rate_limit', msg);
            return msg;
          } else {
            this.errorModel.unset('cpu_rate_limit');
          }

          var dirty_rate_limit = this.get('dirty_rate_limit');
          if (_.isUndefined(dirty_rate_limit) || _.isNull(dirty_rate_limit) || String(dirty_rate_limit).replace(/^\s+|\s+$/g, '') == '') {
            var msg = gettext('Dirty rate limit cannot be empty.');
            this.errorModel.set('dirty_rate_limit', msg);
            return msg;
          } else {
            this.errorModel.unset('dirty_rate_limit');
          }
          return null;
        }
      })
    });
  }

  return pgBrowser.Nodes['coll-resource_group'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  // Extend the browser's collection class for event trigger collection
  if (!pgBrowser.Nodes['coll-event_trigger']) {
    var databases = pgAdmin.Browser.Nodes['coll-event_trigger'] = pgAdmin.Browser.Collection.extend({
      node: 'event_trigger',
      label: gettext('Event Trigger'),
      type: 'coll-event_trigger',
      columns: ['name', 'eventowner', 'comment']
    });
  };

  // Extend the browser's node class for event triggers node
  if (!pgBrowser.Nodes['event_trigger']) {
    pgAdmin.Browser.Nodes['event_trigger'] = pgAdmin.Browser.Node.extend({
      parent_type: 'database',
      type: 'event_trigger',
      sqlAlterHelp: 'sql-altereventtrigger.html',
      sqlCreateHelp: 'sql-createeventtrigger.html',
      dialogHelp: url_for('help.static', { 'filename': 'event_trigger_dialog.html' }),
      label: gettext('Event Trigger'),
      hasSQL: true,
      hasDepends: true,
      canDrop: true,
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_event_trigger_on_coll', node: 'coll-event_trigger', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Event Trigger...'),
          icon: 'wcTabIcon icon-event_trigger', data: { action: 'create' }
        }, {
          name: 'create_event_trigger', node: 'event_trigger', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Event Trigger...'),
          icon: 'wcTabIcon icon-event_trigger', data: { action: 'create' }
        }, {
          name: 'create_event_trigger', node: 'database', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Event Trigger...'),
          icon: 'wcTabIcon icon-event_trigger', data: { action: 'create' },
          enable: pgBrowser.Nodes['database'].is_conn_allow
        }]);
      },
      // Define the model for event trigger node
      model: pgAdmin.Browser.Node.Model.extend({
        defaults: {
          oid: undefined,
          name: undefined,
          eventowner: undefined,
          comment: undefined,
          enabled: "O",
          eventfuncoid: undefined,
          eventfunname: undefined,
          eventname: "DDL_COMMAND_START",
          when: undefined,
          xmin: undefined,
          source: undefined,
          language: undefined
        },

        // Default values!
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;

          if (isNew) {
            var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;

            this.set({ 'eventowner': userInfo.name }, { silent: true });
          }
          pgAdmin.Browser.Node.Model.prototype.initialize.apply(this, arguments);
        },

        // Define the schema for the event trigger node
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', mode: ['properties']
        }, {
          id: 'eventowner', label: gettext('Owner'), cell: 'string',
          type: 'text', mode: ['properties', 'edit', 'create'], node: 'role',
          control: Backform.NodeListByNameControl
        }, {
          id: 'comment', label: gettext('Comment'), type: 'multiline'
        }, {
          id: 'enabled', label: gettext('Enabled status'),
          type: "radio", group: gettext("Definition"), mode: ['properties', 'edit', 'create'],
          options: [{ label: "Enable", value: "O" }, { label: "Disable", value: "D" }, { label: "Replica", value: "R" }, { label: "Always", value: "A" }]
        }, {
          id: 'eventfunname', label: gettext('Trigger function'),
          type: 'text', control: 'node-ajax-options', group: gettext("Definition"),
          url: 'fopts', cache_node: 'trigger_function'
        }, {
          id: 'eventname', label: gettext('Events'),
          type: "radio", group: gettext("Definition"), cell: 'string',
          options: [{ label: "DDL COMMAND START", value: "DDL_COMMAND_START" }, { label: "DDL COMMAND END", value: "DDL_COMMAND_END" }, { label: "SQL DROP", value: "SQL_DROP" }]
        }, {
          id: 'when', label: gettext('When'), type: 'multiline', group: gettext("Definition")
        }, {
          id: 'seclabels', label: gettext('Security Labels'),
          model: pgBrowser.SecLabelModel, editable: false, type: 'collection',
          group: gettext('Security'), mode: ['edit', 'create'],
          min_version: 90200, canAdd: true,
          canEdit: false, canDelete: true, control: 'unique-col-collection'
        }],
        // event trigger model data validation.
        validate: function validate() {
          var msg = undefined;
          // Clear any existing error msg.
          this.errorModel.clear();

          if (_.isUndefined(this.get('name')) || String(this.get('name')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Event trigger name cannot be empty.');
            this.errorModel.set('name', msg);
            return msg;
          }

          if (_.isUndefined(this.get('eventowner')) || String(this.get('eventowner')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Event trigger owner cannot be empty.');
            this.errorModel.set('eventowner', msg);
            return msg;
          }

          if (_.isUndefined(this.get('enabled'))) {
            msg = gettext('Event trigger enabled status cannot be empty.');
            this.errorModel.set('enabled', msg);
            return msg;
          }

          if (_.isUndefined(this.get('eventfunname')) || String(this.get('eventfunname')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Event trigger function cannot be empty.');
            this.errorModel.set('eventfunname', msg);
            return msg;
          }

          if (_.isUndefined(this.get('eventname'))) {
            msg = gettext('Event trigger event cannot be empty.');
            this.errorModel.set('eventname', msg);
            return msg;
          }

          return null;
        }
      })
    });
  }

  return pgBrowser.Nodes['coll-event_trigger'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser) {

  /*
   * Create and Add an Extension Collection into nodes
   * Params:
   *   label - Label for Node
   *   type - Type of Node
   *   columns - List of columns to show under under properties.
   */
  if (!pgBrowser.Nodes['coll-extension']) {
    var extensions = pgAdmin.Browser.Nodes['coll-extension'] = pgAdmin.Browser.Collection.extend({
      node: 'extension',
      label: gettext('Extension'),
      type: 'coll-extension',
      columns: ['name', 'owner', 'comment']
    });
  };

  /*
   * Create and Add an Extension Node into nodes
   * Params:
   *   parent_type - Name of parent Node
   *   type - Type of Node
   *   hasSQL - True if we need to show SQL query Tab control, otherwise False
   *   canDrop - True to show "Drop Extension" link under Context menu,
   *    otherwise False
   *   canDropCascade - True to show "Drop Cascade" link under Context menu,
   *    otherwise False
   *   columns - List of columns to show under under properties tab.
   *   label - Label for Node
   */
  if (!pgBrowser.Nodes['extension']) {
    pgAdmin.Browser.Nodes['extension'] = pgAdmin.Browser.Node.extend({
      parent_type: 'database',
      type: 'extension',
      sqlAlterHelp: 'sql-alterextension.html',
      sqlCreateHelp: 'sql-createextension.html',
      dialogHelp: url_for('help.static', { 'filename': 'extension_dialog.html' }),
      hasSQL: true,
      hasDepends: true,
      canDrop: true,
      canDropCascade: true,
      label: gettext('Extension'),

      Init: function Init() {
        if (this.initialized) return;

        this.initialized = true;

        /*
         * Add "create extension" menu item into context and object menu
         * for the following nodes:
         * coll-extension, extension and database.
         */
        pgBrowser.add_menus([{
          name: 'create_extension_on_coll', node: 'coll-extension', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Extension...'),
          icon: 'wcTabIcon icon-extension', data: { action: 'create' }
        }, {
          name: 'create_extension', node: 'extension', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Extension...'),
          icon: 'wcTabIcon icon-extension', data: { action: 'create' }
        }, {
          name: 'create_extension', node: 'database', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Extension...'),
          icon: 'wcTabIcon icon-extension', data: { action: 'create' },
          enable: pgBrowser.Nodes['database'].is_conn_allow
        }]);
      },

      /*
       * Define model for the Node and specify the properties
       * of the model in schema.
       */
      model: pgAdmin.Browser.Node.Model.extend({
        schema: [{
          id: 'name', label: gettext('Name'), first_empty: true,
          type: 'text', mode: ['properties', 'create', 'edit'],
          visible: true, url: 'avails', disabled: function disabled(m) {
            return !m.isNew();
          },
          transform: function transform(data, cell) {
            var res = [],
                control = cell || this,
                label = control.model.get('name');

            if (!control.model.isNew()) {
              res.push({ label: label, value: label });
            } else {
              if (data && _.isArray(data)) {
                _.each(data, function (d) {
                  if (d.installed_version === null)

                    /*
                     * d contains json data and sets into
                     * select's option control
                     *
                     * We need to stringify data because formatter will
                     * convert Array Object as [Object] string
                     */
                    res.push({ label: d.name, value: JSON.stringify(d) });
                });
              }
            }
            return res;
          },

          /*
           * extends NodeAjaxOptionsControl to override the properties
           * getValueFromDOM which takes stringified data from option of
           * select control and parse it. And `onChange` takes the stringified
           * data from select's option, thus convert it to json format and set the
           * data into Model which is used to enable/disable the schema field.
           */
          control: Backform.NodeAjaxOptionsControl.extend({
            getValueFromDOM: function getValueFromDOM() {
              var data = this.formatter.toRaw(_.unescape(this.$el.find("select").val()), this.model);
              /*
               * return null if data is empty to prevent it from
               * throwing parsing error. Adds check as name can be empty
               */
              if (data === '') {
                return null;
              } else if (typeof data === 'string') {
                data = JSON.parse(data);
              }
              return data.name;
            },

            /*
             * When name is changed, extract value from its select option and
             * set attributes values into the model
             */
            onChange: function onChange() {
              Backform.NodeAjaxOptionsControl.prototype.onChange.apply(this, arguments);
              var selectedValue = this.$el.find("select").val();
              if (selectedValue.trim() != "") {
                var d = this.formatter.toRaw(selectedValue, this.model);
                if (typeof d === 'string') d = JSON.parse(d);
                var changes = {
                  'version': '',
                  'relocatable': !_.isNull(d.relocatable[0]) && !_.isUndefined(d.relocatable[0]) ? d.relocatable[0] : ''
                };
                this.model.set(changes);
              } else {
                var changes = { 'version': '', 'relocatable': true, 'schema': '' };
                this.model.set(changes);
              }
            }
          })
        }, {
          id: 'eid', label: gettext('OID'), cell: 'string',
          type: 'text', disabled: true, mode: ['properties']
        }, {
          id: 'owner', label: gettext('Owner'), control: 'node-list-by-name',
          mode: ['properties'], node: 'role', cell: 'string',
          cache_level: 'server'
        }, {
          id: 'schema', label: gettext('Schema'), type: 'text',
          control: 'node-list-by-name', group: gettext('Definition'),
          mode: ['properties', 'create', 'edit'], deps: ['relocatable'],
          node: 'schema', first_empty: true,
          disabled: function disabled(m) {
            /*
             * enable or disable schema field if model's relocatable
             * attribute is True or False
             */
            return m.has('relocatable') ? !m.get('relocatable') : false;
          }
        }, {
          id: 'relocatable', label: gettext('Relocatable?'), cell: 'switch',
          group: gettext('Definition'), type: 'switch', mode: ['properties'],
          options: {
            'onText': 'Yes', 'offText': 'No',
            'onColor': 'success', 'offColor': 'primary',
            'size': 'small'
          }
        }, {
          id: 'version', label: gettext('Version'), cell: 'string',
          mode: ['properties', 'create', 'edit'], group: gettext('Definition'),
          control: 'node-ajax-options', url: 'avails', first_empty: true,

          // Transform the data into version for the selected extension.
          transform: function transform(data, cell) {
            var res = [],
                control = cell || this,
                extension = control.model.get('name');

            _.each(data, function (dt) {
              if (dt.name == extension) {
                if (dt.version && _.isArray(dt.version)) {
                  _.each(dt.version, function (v) {
                    res.push({ label: v, value: v });
                  });
                }
              }
            });
            return res;
          }
        }, {
          id: 'comment', label: gettext('Comment'), cell: 'string',
          type: 'multiline', disabled: true
        }],
        validate: function validate() {

          /*
          * Triggers error messages for name
          * if it is empty/undefined/null
          */
          var err = {},
              errmsg,
              name = this.get('name');
          if (_.isUndefined(name) || _.isNull(name) || String(name).replace(/^\s+|\s+$/g, '') == '') {
            err['name'] = gettext('Name cannot be empty.');
            errmsg = errmsg || err['name'];
            this.errorModel.set('name', errmsg);
            return errmsg;
          } else {
            this.errorModel.unset('name');
          }
          return null;
        }
      })
    });
  };

  return pgBrowser.Nodes['coll-extension'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  // Extend the browser's collection class for languages collection
  if (!pgBrowser.Nodes['coll-language']) {
    var languages = pgBrowser.Nodes['coll-language'] = pgBrowser.Collection.extend({
      node: 'language',
      label: gettext('Languages'),
      type: 'coll-language',
      columns: ['name', 'lanowner', 'description']
    });
  };

  // Extend the browser's node class for language node
  if (!pgBrowser.Nodes['language']) {
    pgBrowser.Nodes['language'] = pgBrowser.Node.extend({
      parent_type: 'database',
      type: 'language',
      sqlAlterHelp: 'sql-alterlanguage.html',
      sqlCreateHelp: 'sql-createlanguage.html',
      dialogHelp: url_for('help.static', { 'filename': 'language_dialog.html' }),
      label: gettext('Language'),
      hasSQL: true,
      canDrop: true,
      canDropCascade: true,
      hasDepends: true,
      Init: function Init() {

        // Avoid multiple registration of menus
        if (this.initialized) return;

        this.initialized = true;

        // Add context menus for language
        pgBrowser.add_menus([{
          name: 'create_language_on_database', node: 'database', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Language...'),
          icon: 'wcTabIcon icon-language', data: { action: 'create' },
          enable: pgBrowser.Nodes['database'].is_conn_allow
        }, {
          name: 'create_language_on_coll', node: 'coll-language', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Language...'),
          icon: 'wcTabIcon icon-language', data: { action: 'create' }
        }, {
          name: 'create_language', node: 'language', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Language...'),
          icon: 'wcTabIcon icon-language', data: { action: 'create' }
        }]);
      },

      // Define the model for language node
      model: pgBrowser.Node.Model.extend({
        defaults: {
          name: undefined,
          lanowner: undefined,
          comment: undefined,
          lanacl: [],
          seclabels: [],
          trusted: true,
          lanproc: undefined,
          laninl: undefined,
          lanval: undefined,
          is_template: false,
          template_list: []
        },

        // Default values!
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;
          if (isNew) {
            var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;

            this.set({ 'lanowner': userInfo.name }, { silent: true });
          }
          pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
        },

        // Define the schema for the language node
        schema: [{
          id: 'name', label: gettext('Name'), type: 'text',
          control: 'node-ajax-options', mode: ['properties', 'create', 'edit'],
          url: 'get_templates', select2: { allowClear: false, tags: true, multiple: false },
          transform: function transform(data, cell) {
            var res = [],
                control = cell || this,
                label = control.model.get('name');

            if (!control.model.isNew()) {
              res.push({ label: label, value: label });
            } else {
              var tmp_list = [];
              if (data && _.isArray(data)) {
                _.each(data, function (d) {
                  res.push({ label: d.tmplname, value: d.tmplname });
                  tmp_list.push(d.tmplname);
                });
              }
              this.model.set({ 'template_list': tmp_list });
            }

            return res;
          }
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string', mode: ['properties'],
          type: 'text', disabled: true
        }, {
          id: 'lanowner', label: gettext('Owner'), type: 'text',
          control: Backform.NodeListByNameControl, node: 'role',
          mode: ['edit', 'properties', 'create'], select2: { allowClear: false }
        }, {
          id: 'acl', label: gettext('Privileges'), type: 'text',
          group: gettext('Security'), mode: ['properties'], disabled: true
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline'
        }, {
          id: 'trusted', label: gettext('Trusted?'), type: 'switch',
          options: {
            'onText': 'Yes', 'offText': 'No',
            'onColor': 'success', 'offColor': 'primary',
            'size': 'small'
          },
          group: gettext('Definition'), mode: ['edit', 'properties', 'create'], deps: ['name'],
          disabled: function disabled(m) {
            if (m.isNew()) {
              if (m.get('template_list').indexOf(m.get('name')) == -1) {
                m.set({ 'is_template': false });
                return false;
              } else m.set({ 'is_template': true });
            }
            return true;
          }
        }, {
          id: 'lanproc', label: gettext('Handler Function'), type: 'text', control: 'node-ajax-options',
          group: gettext('Definition'), mode: ['edit', 'properties', 'create'], url: 'get_functions',
          deps: ['name'], first_empty: false,
          /* This function is used to populate the handler function
           * for the selected language node. It will check if the property
           * type is 'handler' then push the data into the result array.
           */
          transform: function transform(data) {
            var res = [];
            if (data && _.isArray(data)) {
              _.each(data, function (d) {
                if (d.prop_type == 'handler') {
                  res.push({ label: d.label, value: d.label });
                }
              });
            }
            return res;
          }, disabled: function disabled(m) {
            if (m.isNew()) {
              if (m.get('template_list').indexOf(m.get('name')) == -1) return false;
            }
            return true;
          }
        }, {
          id: 'laninl', label: gettext('Inline Function'), type: 'text', control: 'node-ajax-options',
          group: gettext('Definition'), mode: ['edit', 'properties', 'create'], url: 'get_functions',
          deps: ['name'], first_empty: false,
          /* This function is used to populate the inline function
           * for the selected language node. It will check if the property
           * type is 'inline' then push the data into the result array.
           */
          transform: function transform(data) {
            var res = [];
            if (data && _.isArray(data)) {
              _.each(data, function (d) {
                if (d.prop_type == 'inline') {
                  res.push({ label: d.label, value: d.label });
                }
              });
            }
            return res;
          }, disabled: function disabled(m) {
            if (m.isNew()) {
              if (m.get('template_list').indexOf(m.get('name')) == -1) return false;
            }
            return true;
          }
        }, {
          id: 'lanval', label: gettext('Validator Function'), type: 'text', control: 'node-ajax-options',
          group: gettext('Definition'), mode: ['edit', 'properties', 'create'], url: 'get_functions',
          deps: ['name'],
          /* This function is used to populate the validator function
           * for the selected language node. It will check if the property
           * type is 'validator' then push the data into the result array.
           */
          transform: function transform(data) {
            var res = [];
            if (data && _.isArray(data)) {
              _.each(data, function (d) {
                if (d.prop_type == 'validator') {
                  res.push({ label: d.label, value: d.label });
                }
              });
            }
            return res;
          }, disabled: function disabled(m) {
            if (m.isNew()) {
              if (m.get('template_list').indexOf(m.get('name')) == -1) return false;
            }
            return true;
          }
        }, {
          id: 'lanacl', label: gettext('Privileges'), type: 'collection',
          group: 'security', control: 'unique-col-collection', mode: ['edit', 'create'],
          model: pgBrowser.Node.PrivilegeRoleModel.extend({
            privileges: ['U']
          }), canAdd: true, canDelete: true, uniqueCol: ['grantee']
        }, {
          id: 'seclabels', label: gettext('Security Labels'), mode: ['edit', 'create'],
          model: pgBrowser.SecLabelModel, editable: false,
          type: 'collection', group: 'security', min_version: 90200,
          canAdd: true, canEdit: false, canDelete: true,
          control: 'unique-col-collection'
        }],
        /* validate function is used to validate the input given by
         * the user. In case of error, message will be displayed on
         * the GUI for the respective control.
         */
        validate: function validate() {
          var name = this.get('name');

          if (_.isUndefined(name) || _.isNull(name) || String(name).replace(/^\s+|\s+$/g, '') == '') {
            var msg = gettext('Name cannot be empty.');
            this.errorModel.set('name', msg);
            return msg;
          } else {
            this.errorModel.unset('name');
          }

          // If predefined template is selected then no need to validate it.
          if (!this.get('is_template')) {
            var handler_func = this.get('lanproc');
            if (_.isUndefined(handler_func) || _.isNull(handler_func) || String(handler_func).replace(/^\s+|\s+$/g, '') == '') {
              var msg = gettext('Handler Function cannot be empty');
              this.errorModel.set('lanproc', msg);
              return msg;
            } else {
              this.errorModel.unset('lanproc');
            }
          }

          return null;
        }
      })
    });
  }
  return pgBrowser.Nodes['coll-language'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  // Extend the browser's node model class to create a Options model
  var OptionsModel = pgBrowser.Node.Model.extend({
    idAttribute: 'fdwoption',
    defaults: {
      fdwoption: undefined,
      fdwvalue: undefined
    },
    // Defining schema for the Options model
    schema: [{
      id: 'fdwoption', label: gettext('Option'), type: 'text',
      cellHeaderClasses: 'width_percent_50', editable: true
    }, {
      id: 'fdwvalue', label: gettext('Value'), type: 'text',
      cellHeaderClasses: 'width_percent_50', group: null, editable: true
    }],
    /* validate function is used to validate the input given by
     * the user. In case of error, message will be displayed on
     * the browser for the respective control.
     */
    validate: function validate() {
      // Validation for the option name
      if (_.isUndefined(this.get('fdwoption')) || _.isNull(this.get('fdwoption')) || String(this.get('fdwoption')).replace(/^\s+|\s+$/g, '') == '') {
        var msg = 'Please enter an option name';
        this.errorModel.set('fdwoption', msg);
        return msg;
      } else {
        this.errorModel.unset('fdwoption');
      }
      return null;
    }
  });

  // Extend the browser's collection class for foreign data wrapper collection
  if (!pgBrowser.Nodes['coll-foreign_data_wrapper']) {
    var foreign_data_wrappers = pgBrowser.Nodes['coll-foreign_data_wrapper'] = pgBrowser.Collection.extend({
      node: 'foreign_data_wrapper',
      label: gettext('Foreign Data Wrappers'),
      type: 'coll-foreign_data_wrapper',
      columns: ['name', 'fdwowner', 'description']
    });
  };

  // Extend the browser's node class for foreign data wrapper node
  if (!pgBrowser.Nodes['foreign_data_wrapper']) {
    pgBrowser.Nodes['foreign_data_wrapper'] = pgBrowser.Node.extend({
      parent_type: 'database',
      type: 'foreign_data_wrapper',
      sqlAlterHelp: 'sql-alterforeigndatawrapper.html',
      sqlCreateHelp: 'sql-createforeigndatawrapper.html',
      dialogHelp: url_for('help.static', { 'filename': 'foreign_data_wrapper_dialog.html' }),
      label: gettext('Foreign Data Wrapper'),
      hasSQL: true,
      hasDepends: true,
      canDrop: true,
      canDropCascade: true,
      Init: function Init() {

        // Avoid multiple registration of menus
        if (this.initialized) return;

        this.initialized = true;

        /* Create foreign data wrapper context menu at database,
         * foreign data wrapper collections and foreign data wrapper node
         */
        pgBrowser.add_menus([{
          name: 'create_foreign_data_wrapper_on_coll', node: 'coll-foreign_data_wrapper', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Foreign Data Wrapper...'),
          icon: 'wcTabIcon icon-foreign_data_wrapper', data: { action: 'create' }
        }, {
          name: 'create_foreign_data_wrapper', node: 'foreign_data_wrapper', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Foreign Data Wrapper...'),
          icon: 'wcTabIcon icon-foreign_data_wrapper', data: { action: 'create' }
        }, {
          name: 'create_foreign_data_wrapper', node: 'database', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Foreign Data Wrapper...'),
          icon: 'wcTabIcon icon-foreign_data_wrapper', data: { action: 'create' },
          enable: pgBrowser.Nodes['database'].is_conn_allow
        }]);
      },

      // Defining model for foreign data wrapper node
      model: pgBrowser.Node.Model.extend({
        defaults: {
          name: undefined,
          fdwowner: undefined,
          comment: undefined,
          fdwvalue: undefined,
          fdwhan: undefined,
          fdwoption: undefined,
          fdwacl: []
        },

        // Default values!
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;

          if (isNew) {
            var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;

            this.set({ 'fdwowner': userInfo.name }, { silent: true });
          }
          pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
        },

        // Defining schema for the foreign data wrapper node
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', disabled: function disabled(m) {

            // name field will be disabled only if edit mode and server version is below 9.2
            if (this.mode == 'edit' && this.node_info.server.version < 90200) {
              return true;
            } else return false;
          }
        }, {
          id: 'fdwoid', label: gettext('OID'), cell: 'string',
          type: 'text', disabled: true, mode: ['properties']
        }, {
          id: 'fdwowner', label: gettext('Owner'), type: 'text',
          control: Backform.NodeListByNameControl, node: 'role',
          mode: ['edit', 'create', 'properties'], select2: { allowClear: false }
        }, {
          id: 'fdwhan', label: gettext('Handler'), type: 'text', control: 'node-ajax-options',
          group: gettext('Definition'), mode: ['edit', 'create', 'properties'], url: 'get_handlers'
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline'
        }, {
          id: 'fdwoptions', label: 'Options', type: 'collection', group: gettext('Options'),
          model: OptionsModel, control: 'unique-col-collection', mode: ['edit', 'create'],
          canAdd: true, canDelete: true, uniqueCol: ['fdwoption'],
          columns: ['fdwoption', 'fdwvalue']
        }, {
          id: 'fdwvalue', label: gettext('Validator'), type: 'text', control: 'node-ajax-options',
          group: gettext('Definition'), mode: ['edit', 'create', 'properties'], url: 'get_validators'
        }, {
          id: 'security', label: gettext('Security'), type: 'group'
        }, {
          id: 'fdwacl', label: 'Privileges', type: 'collection',
          group: 'security', mode: ['edit', 'create'], canAdd: true,
          canDelete: true, uniqueCol: ['grantee'],
          model: pgBrowser.Node.PrivilegeRoleModel.extend({
            privileges: ['U']
          }), control: 'unique-col-collection'
        }, {
          id: 'acl', label: gettext('Privileges'), type: 'text',
          group: gettext('Security'), mode: ['properties'], disabled: true
        }],
        /* validate function is used to validate the input given by
         * the user. In case of error, message will be displayed on
         * the browser for the respective control.
         */
        validate: function validate() {
          var name = this.get('name');

          if (_.isUndefined(name) || _.isNull(name) || String(name).replace(/^\s+|\s+$/g, '') == '') {
            var msg = gettext('Name cannot be empty.');
            this.errorModel.set('name', msg);
            return msg;
          } else {
            this.errorModel.unset('name');
          }
          return null;
        }
      })
    });
  }

  return pgBrowser.Nodes['foreign_data_wrapper'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, $, _, S, pgAdmin, pgBrowser, alertify) {

  // Extend the browser's node model class to create a Options model
  var OptionsModel = pgAdmin.Browser.Node.Model.extend({
    idAttribute: 'fsrvoption',
    defaults: {
      fsrvoption: undefined,
      fsrvvalue: undefined
    },

    // Defining schema for the Options model
    schema: [{ id: 'fsrvoption', label: 'Options', type: 'text', cellHeaderClasses: 'width_percent_50', group: null, editable: true }, { id: 'fsrvvalue', label: 'Value', type: 'text', cellHeaderClasses: 'width_percent_50', group: null, editable: true }],

    /* validate function is used to validate the input given by
     * the user. In case of error, message will be displayed on
     * the browser for the respective control.
     */
    validate: function validate() {
      // Validation for the option name
      if (_.isUndefined(this.get('fsrvoption')) || _.isNull(this.get('fsrvoption')) || String(this.get('fsrvoption')).replace(/^\s+|\s+$/g, '') == '') {
        var msg = 'Please enter an option name';
        this.errorModel.set('fsrvoption', msg);
        return msg;
      } else {
        this.errorModel.unset('fsrvoption');
      }
      return null;
    }
  });

  // Extend the browser's collection class for foreign server collection
  if (!pgBrowser.Nodes['coll-foreign_server']) {
    var foreign_data_wrappers = pgAdmin.Browser.Nodes['coll-foreign_server'] = pgAdmin.Browser.Collection.extend({
      node: 'foreign_server',
      label: gettext('Foreign Servers'),
      type: 'coll-foreign_server',
      columns: ['name', 'fsrvowner', 'description']
    });
  };

  // Extend the browser's node class for foreign server node
  if (!pgBrowser.Nodes['foreign_server']) {
    pgAdmin.Browser.Nodes['foreign_server'] = pgAdmin.Browser.Node.extend({
      parent_type: 'foreign_data_wrapper',
      type: 'foreign_server',
      sqlAlterHelp: 'sql-alterforeignserver.html',
      sqlCreateHelp: 'sql-createforeignserver.html',
      label: gettext('Foreign Server'),
      hasSQL: true,
      hasDepends: true,
      canDrop: true,
      canDropCascade: true,
      Init: function Init() {

        // Avoid multiple registration of menus
        if (this.initialized) return;

        this.initialized = true;

        /* Create foreign server context menu at database,
         * foreign server collections and foreign server node
         */
        pgBrowser.add_menus([{
          name: 'create_foreign_server_on_coll', node: 'coll-foreign_server', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Foreign Server...'),
          icon: 'wcTabIcon icon-foreign_server', data: { action: 'create' }
        }, {
          name: 'create_foreign_server', node: 'foreign_server', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Foreign Server...'),
          icon: 'wcTabIcon icon-foreign_server', data: { action: 'create' }
        }, {
          name: 'create_foreign_server', node: 'foreign_data_wrapper', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Foreign Server...'),
          icon: 'wcTabIcon icon-foreign_server', data: { action: 'create' }
        }]);
      },

      // Defining model for foreign server node
      model: pgAdmin.Browser.Node.Model.extend({
        defaults: {
          name: undefined,
          fsrvtype: undefined,
          fsrvversion: undefined,
          fsrvvalue: undefined,
          fsrvoptions: [],
          fsrvowner: undefined,
          description: undefined,
          fsrvacl: []
        },

        // Default values!
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;

          if (isNew) {
            var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;

            this.set({ 'fsrvowner': userInfo.name }, { silent: true });
          }
          pgAdmin.Browser.Node.Model.prototype.initialize.apply(this, arguments);
        },

        // Defining schema for the foreign server node
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', disabled: function disabled(m) {
            if (this.mode == 'edit' && this.node_info.server.version < 90200) {
              return true;
            } else return false;
          }
        }, {
          id: 'fsrvid', label: gettext('OID'), cell: 'string',
          type: 'text', disabled: true, mode: ['properties']
        }, {
          id: 'fsrvowner', label: gettext('Owner'), type: 'text',
          control: Backform.NodeListByNameControl, node: 'role',
          mode: ['edit', 'create', 'properties'], select2: { allowClear: false }
        }, {
          id: 'fsrvtype', label: gettext('Type'), cell: 'string',
          group: gettext('Definition'), type: 'text', mode: ['edit', 'create', 'properties'], disabled: function disabled(m) {
            return !m.isNew();
          }
        }, {
          id: 'fsrvversion', label: gettext('Version'), cell: 'string',
          group: gettext('Definition'), type: 'text'
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline'
        }, {
          id: 'fsrvoptions', label: 'Options', type: 'collection', group: gettext("Options"),
          model: OptionsModel, control: 'unique-col-collection', mode: ['edit', 'create'],
          canAdd: true, canDelete: true, uniqueCol: ['fsrvoption'],
          columns: ['fsrvoption', 'fsrvvalue']
        }, pgBrowser.SecurityGroupSchema, {
          id: 'fsrvacl', label: 'Privileges', type: 'collection', group: 'security',
          model: pgAdmin.Browser.Node.PrivilegeRoleModel.extend({ privileges: ['U'] }), control: 'unique-col-collection',
          mode: ['edit', 'create'], canAdd: true, canDelete: true, uniqueCol: ['grantee']
        }, {
          id: 'acl', label: gettext('Privileges'), type: 'text',
          group: gettext('Security'), mode: ['properties'], disabled: true
        }],

        /* validate function is used to validate the input given by
         * the user. In case of error, message will be displayed on
         * the browser for the respective control.
         */
        validate: function validate() {
          var name = this.get('name');

          if (_.isUndefined(name) || _.isNull(name) || String(name).replace(/^\s+|\s+$/g, '') == '') {
            var msg = gettext('Name cannot be empty.');
            this.errorModel.set('name', msg);
            return msg;
          } else {
            this.errorModel.unset('name');
          }
          return null;
        }
      })
    });
  }

  return pgBrowser.Nodes['coll-foreign_server'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  // Extend the browser's node model class to create a Options model
  var OptionsModel = pgAdmin.Browser.Node.Model.extend({
    idAttribute: 'umoption',
    defaults: {
      umoption: undefined,
      umvalue: undefined
    },

    // Defining schema for the Options model
    schema: [{
      id: 'umoption', label: gettext('Options'), type: 'text',
      cellHeaderClasses: 'width_percent_50', group: null, editable: true
    }, {
      id: 'umvalue', label: gettext('Value'), type: 'text',
      cellHeaderClasses: 'width_percent_50', group: null, editable: true
    }],

    /* validate function is used to validate the input given by
     * the user. In case of error, message will be displayed on
     * the browser for the respective control.
     */
    validate: function validate() {
      // Validation for the option value
      if (_.isUndefined(this.get('umoption')) || _.isNull(this.get('umoption')) || String(this.get('umoption')).replace(/^\s+|\s+$/g, '') == '') {
        var msg = 'Please enter an option name';
        this.errorModel.set('umoption', msg);
        return msg;
      } else {
        this.errorModel.unset('umoption');
      }
      return null;
    }
  });

  // Extend the browser's collection class for user mapping collection
  if (!pgBrowser.Nodes['coll-user_mapping']) {
    var foreign_data_wrappers = pgAdmin.Browser.Nodes['coll-user_mapping'] = pgAdmin.Browser.Collection.extend({
      node: 'user_mapping',
      label: gettext('User Mappings'),
      type: 'coll-user_mapping',
      columns: ['name']
    });
  };

  // Extend the browser's node class for user mapping node
  if (!pgBrowser.Nodes['user_mapping']) {
    pgAdmin.Browser.Nodes['user_mapping'] = pgAdmin.Browser.Node.extend({
      parent_type: 'foreign_server',
      type: 'user_mapping',
      sqlAlterHelp: 'sql-alterusermapping.html',
      sqlCreateHelp: 'sql-createusermapping.html',
      dialogHelp: url_for('help.static', { 'filename': 'user_mapping_dialog.html' }),
      label: gettext('User Mapping'),
      hasSQL: true,
      hasDepends: true,
      canDrop: true,
      canDropCascade: true,
      Init: function Init() {

        // Avoid multiple registration of menus
        if (this.initialized) return;

        this.initialized = true;

        /* Create foreign server context menu at database,
         * user mapping collections and user mapping node
         */
        pgBrowser.add_menus([{
          name: 'create_user_mapping_on_coll', node: 'coll-user_mapping', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('User Mapping...'),
          icon: 'wcTabIcon icon-user_mapping', data: { action: 'create' }
        }, {
          name: 'create_user_mapping', node: 'user_mapping', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('User Mapping...'),
          icon: 'wcTabIcon icon-user_mapping', data: { action: 'create' }
        }, {
          name: 'create_user_mapping', node: 'foreign_server', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('User Mapping...'),
          icon: 'wcTabIcon icon-user_mapping', data: { action: 'create' }
        }]);
      },

      // Defining model for user mapping node
      model: pgAdmin.Browser.Node.Model.extend({
        defaults: {
          name: undefined,
          um_options: []
        },

        // Default values!
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;

          if (isNew) {
            var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;

            this.set({ 'name': userInfo.name }, { silent: true });
          }
          pgAdmin.Browser.Node.Model.prototype.initialize.apply(this, arguments);
        },

        // Defining schema for the user mapping node
        schema: [{
          id: 'name', label: gettext('User'), type: 'text',
          control: Backform.NodeListByNameControl, node: 'role',
          mode: ['edit', 'create', 'properties'], select2: { allowClear: false },
          disabled: function disabled(m) {
            return !m.isNew();
          },
          transform: function transform(data) {
            var self = this;
            node = self.field.get('schema_node');
            var res = Backform.NodeListByNameControl.prototype.defaults.transform.apply(this, arguments);
            res.unshift({ label: 'CURRENT_USER', value: 'CURRENT_USER', image: 'icon-' + node.type }, { label: 'PUBLIC', value: 'PUBLIC', image: 'icon-' + node.type });
            return res;
          }
        }, {
          id: 'um_oid', label: gettext('OID'), cell: 'string',
          type: 'text', disabled: true, mode: ['properties']
        }, {
          id: 'umoptions', label: 'Options', type: 'collection', group: gettext("Options"),
          model: OptionsModel, control: 'unique-col-collection', mode: ['create', 'edit'],
          canAdd: true, canDelete: true, uniqueCol: ['umoption']
        }],

        /* validate function is used to validate the input given by
         * the user. In case of error, message will be displayed on
         * the browser for the respective control.
         */
        validate: function validate() {
          var name = this.get('name');

          if (_.isUndefined(name) || _.isNull(name) || String(name).replace(/^\s+|\s+$/g, '') == '') {
            var msg = gettext('Name cannot be empty.');
            this.errorModel.set('name', msg);
            return msg;
          } else {
            this.errorModel.unset('name');
          }
          return null;
        }
      })
    });
  }

  return pgBrowser.Nodes['coll-user_mapping'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backgrid) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(16), __webpack_require__(8), __webpack_require__(9), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, Backform, alertify) {

  // VacuumSettings Collection to display all settings parameters as Grid
  var VacuumCollectionControl = Backform.VacuumCollectionControl = Backform.Control.extend({

    grid_columns: undefined,

    initialize: function initialize() {
      Backform.Control.prototype.initialize.apply(this, arguments);
      var self = this,
          m = this.model,
          url = self.field.get('url');

      if (url && m.isNew()) {
        var node = self.field.get('node'),
            node_data = self.field.get('node_data'),
            node_info = self.field.get('node_info'),
            full_url = node.generate_url.apply(node, [null, url, node_data, false, node_info]),
            data;
        m.trigger('pgadmin-view:fetching', m, self.field);

        // fetch default values for autovacuum fields
        $.ajax({
          async: false,
          url: full_url,
          success: function success(res) {
            data = res;
          },
          error: function error() {
            m.trigger('pgadmin-view:fetch:error', m, self.field);
          }
        });
        m.trigger('pgadmin-view:fetched', m, self.field);

        // Add fetched models into collection
        if (data && _.isArray(data)) {
          m.get(self.field.get('name')).reset(data, { silent: true });
        }
      }
    },

    render: function render() {
      var self = this,
          m = this.model,
          attributes = self.field.attributes;

      // remove grid
      if (self.grid) {
        self.grid.remove();
        delete self.grid;
        self.grid = undefined;
      }

      self.$el.empty();

      var gridHeader = _.template(['<div class="subnode-header">', '  <label class="control-label col-sm-4"><%-label%></label>', '</div>'].join("\n")),
          gridBody = $('<div class="pgadmin-control-group backgrid form-group col-xs-12 object subnode"></div>').append(gridHeader(attributes));

      // Initialize a new Grid instance
      var grid = self.grid = new Backgrid.Grid({
        columns: self.grid_columns,
        collection: self.model.get(self.field.get('name')),
        className: "backgrid table-bordered"
      });

      // render grid
      self.$el.append($(gridBody).append(grid.render().$el));

      return self;
    }
  });

  // We will use this function in VacuumSettings Control
  // to convert data type on the fly
  var cellFunction = Backform.cellFunction = function (model) {
    var self = this,
        m = model,
        vartype = model.get('column_type');

    switch (vartype) {
      case "integer":
        return Backgrid.IntegerCell;
        break;
      case "number":
        return Backgrid.NumberCell;
        break;
      case "string":
        return Backgrid.StringCell;
        break;
      default:
        return Backgrid.Cell;
        break;
    }
  };

  // Define Security Model with fields and validation for VacuumSettings Control
  var VacuumTableModel = Backform.VacuumTableModel = pgBrowser.Node.Model.extend({
    defaults: {
      name: undefined,
      setting: undefined,
      label: undefined,
      value: undefined,
      column_type: undefined
    },

    toJSON: function toJSON() {
      var d = pgBrowser.Node.Model.prototype.toJSON.apply(this);
      delete d.label;
      delete d.setting;
      delete d.column_type;
      return d;
    }
  });

  // Extend the browser's collection class for VacuumSettingsModel
  var VacuumSettingsSchema = Backform.VacuumSettingsSchema = [{
    id: 'autovacuum_custom', label: gettext('Custom auto-vacuum?'),
    group: gettext('Table'), mode: ['edit', 'create'],
    type: 'switch',
    disabled: function disabled(m) {
      // If table is partitioned table then disabled it.
      if (m.top && m.top.get('is_partitioned')) {
        // We also need to unset rest of all
        setTimeout(function () {
          m.set('autovacuum_custom', false);
        }, 10);

        return true;
      }

      if (!m.top.inSchema.apply(this, [m])) {
        return false;
      }
      return true;
    }
  }, {
    id: 'autovacuum_enabled', label: gettext('Enabled?'),
    group: gettext('Table'), mode: ['edit', 'create'],
    type: 'switch',
    deps: ['autovacuum_custom'],
    disabled: function disabled(m) {
      if (!m.top.inSchema.apply(this, [m]) && m.get('autovacuum_custom') == true) {
        return false;
      }

      // We also need to unset rest of all
      setTimeout(function () {
        m.set('autovacuum_enabled', false);
      }, 10);
      return true;
    }
  }, {
    id: 'vacuum_table', label: gettext('Vacuum Table'),
    model: Backform.VacuumTableModel, editable: false, type: 'collection',
    canEdit: true, group: gettext('Table'),
    mode: ['edit', 'create'], url: 'get_table_vacuum',
    control: Backform.VacuumCollectionControl.extend({
      grid_columns: [{
        name: 'label', label: gettext('Label'),
        headerCell: Backgrid.Extension.CustomHeaderCell,
        cell: 'string', editable: false, cellHeaderClasses: 'width_percent_40'
      }, {
        name: 'value', label: gettext('Value'),
        cellHeaderClasses: 'width_percent_30',
        cellFunction: Backform.cellFunction, editable: function editable(m) {
          return m.handler.get('autovacuum_enabled');
        }, headerCell: Backgrid.Extension.CustomHeaderCell
      }, {
        name: 'setting', label: gettext('Default value'),
        cellHeaderClasses: 'width_percent_30',
        headerCell: Backgrid.Extension.CustomHeaderCell,
        cellFunction: Backform.cellFunction, editable: false
      }]
    }),
    deps: ['autovacuum_enabled']
  }, {
    id: 'toast_autovacuum', label: gettext('Custom auto-vacuum?'),
    group: gettext('Toast Table'), mode: ['edit', 'create'],
    type: 'switch',
    disabled: function disabled(m) {
      // We need to check additional condition to toggle enable/disable
      // for table auto-vacuum
      if (!m.top.inSchema.apply(this, [m]) && m.isNew()) {
        return false;
      } else if (!m.top.inSchema.apply(this, [m]) && (m.get('toast_autovacuum_enabled') === true || m.top.get('hastoasttable') === true)) {
        return false;
      }
      return true;
    }
  }, {
    id: 'toast_autovacuum_enabled', label: gettext('Enabled?'),
    group: gettext('Toast Table'), mode: ['edit', 'create'],
    type: 'switch',
    deps: ['toast_autovacuum'],
    disabled: function disabled(m) {
      // If in schema & in create mode then enable it
      if (!m.top.inSchema.apply(this, [m]) && m.get('toast_autovacuum') === true) {
        return false;
      }

      if (m.isNew() || m.get('hastoasttable')) {
        // we also need to unset rest of all
        setTimeout(function () {
          m.set('toast_autovacuum_enabled', false);
        }, 10);
      }
      return true;
    }
  }, {
    id: 'vacuum_toast', label: gettext('Vacuum Toast Table'),
    model: Backform.VacuumTableModel, type: 'collection', editable: function editable(m) {
      return m.isNew();
    },
    canEdit: true, group: gettext('Toast Table'),
    mode: ['properties', 'edit', 'create'], url: 'get_toast_table_vacuum',
    control: Backform.VacuumCollectionControl.extend({
      grid_columns: [{
        name: 'label', label: gettext('Label'),
        headerCell: Backgrid.Extension.CustomHeaderCell,
        cell: 'string', editable: false, cellHeaderClasses: 'width_percent_40'
      }, {
        name: 'value', label: gettext('Value'),
        cellHeaderClasses: 'width_percent_30',
        headerCell: Backgrid.Extension.CustomHeaderCell,
        cellFunction: Backform.cellFunction, editable: function editable(m) {
          return m.handler.get('toast_autovacuum_enabled');
        }
      }, {
        name: 'setting', label: gettext('Default value'),
        cellHeaderClasses: 'width_percent_30',
        headerCell: Backgrid.Extension.CustomHeaderCell,
        cellFunction: Backform.cellFunction, editable: false
      }]
    }),
    deps: ['toast_autovacuum_enabled']
  }];

  // Extend the browser's collection class for schema collection
  if (!pgBrowser.Nodes['coll-schema']) {
    var databases = pgBrowser.Nodes['coll-schema'] = pgBrowser.Collection.extend({
      node: 'schema',
      label: gettext('Schemas'),
      type: 'coll-schema',
      columns: ['name', 'namespaceowner', 'description']
    });
  };
  // Extend the browser's node class for schema node
  if (!pgBrowser.Nodes['schema']) {
    pgBrowser.Nodes['schema'] = pgBrowser.Node.extend({
      parent_type: 'database',
      type: 'schema',
      sqlAlterHelp: 'sql-alterschema.html',
      sqlCreateHelp: 'sql-createschema.html',
      dialogHelp: url_for('help.static', { 'filename': 'schema_dialog.html' }),
      label: gettext('Schema'),
      hasSQL: true,
      canDrop: true,
      canDropCascade: true,
      hasDepends: true,
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_schema_on_coll', node: 'coll-schema', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Schema...'),
          icon: 'wcTabIcon icon-schema', data: { action: 'create' }
        }, {
          name: 'create_schema', node: 'schema', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Schema...'),
          icon: 'wcTabIcon icon-schema', data: { action: 'create' }
        }, {
          name: 'create_schema', node: 'database', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Schema...'),
          icon: 'wcTabIcon icon-schema', data: { action: 'create' },
          enable: 'can_create_schema'
        }]);
      },
      can_create_schema: function can_create_schema(node, item) {
        return pgBrowser.Nodes['database'].is_conn_allow.call(this, node);
      },
      model: pgBrowser.Node.Model.extend({
        defaults: {
          name: undefined,
          namespaceowner: undefined,
          description: undefined,
          is_system_obj: undefined
        },
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;

          if (isNew) {
            var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;

            this.set({ 'namespaceowner': userInfo.name }, { silent: true });
          }
          pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
        },
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', disabled: true, mode: ['properties']
        }, {
          id: 'namespaceowner', label: gettext('Owner'), cell: 'string',
          type: 'text', control: 'node-list-by-name', node: 'role',
          select2: { allowClear: false }
        }, {
          id: 'is_sys_object', label: gettext('System schema?'),
          cell: 'switch', type: 'switch', mode: ['properties'], disabled: true
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline'
        }, {
          id: 'acl', label: gettext('Privileges'), type: 'text',
          group: gettext('Security'), mode: ['properties'], disabled: true
        }, {
          id: 'tblacl', label: gettext('Default TABLE privileges'), type: 'text',
          group: gettext('Security'), mode: ['properties'], disabled: true
        }, {
          id: 'seqacl', label: gettext('Default SEQUENCE privileges'), type: 'text',
          group: gettext('Security'), mode: ['properties'], disabled: true
        }, {
          id: 'funcacl', label: gettext('Default FUNCTION privileges'),
          group: gettext('Security'), type: 'text', mode: ['properties'], disabled: true
        }, {
          id: 'typeacl', label: gettext('Default TYPE privileges'), type: 'text',
          group: gettext('Security'), mode: ['properties'], disabled: true, min_version: 90200,
          visible: function visible() {
            return this.version_compatible;
          }
        }, {
          id: 'nspacl', label: gettext('Privileges'),
          model: pgBrowser.Node.PrivilegeRoleModel.extend({ privileges: ['C', 'U'] }), uniqueCol: ['grantee', 'grantor'],
          editable: false, type: 'collection', group: gettext('Security'),
          mode: ['edit', 'create'],
          canAdd: true, canDelete: true, control: 'unique-col-collection'
        }, {
          id: 'seclabels', label: gettext('Security Labels'),
          model: pgBrowser.SecLabelModel, editable: false, type: 'collection',
          group: gettext('Security'), mode: ['edit', 'create'],
          min_version: 90200, canAdd: true,
          canEdit: false, canDelete: true, control: 'unique-col-collection'
        }, {
          type: 'nested', control: 'tab', group: gettext('Default Privileges'),
          mode: ['create', 'edit'],
          schema: [{
            id: 'deftblacl', model: pgBrowser.Node.PrivilegeRoleModel.extend({ privileges: ['a', 'r', 'w', 'd', 'D', 'x', 't'] }),
            label: gettext('Default Privileges: Tables'),
            editable: false, type: 'collection', group: gettext('Tables'),
            mode: ['edit', 'create'], control: 'unique-col-collection',
            canAdd: true, canDelete: true, uniqueCol: ['grantee', 'grantor']
          }, {
            id: 'defseqacl', model: pgBrowser.Node.PrivilegeRoleModel.extend({ privileges: ['r', 'w', 'U'] }),
            label: gettext('Default Privileges: Sequences'),
            editable: false, type: 'collection', group: gettext('Sequences'),
            mode: ['edit', 'create'], control: 'unique-col-collection',
            canAdd: true, canDelete: true, uniqueCol: ['grantee', 'grantor']
          }, {
            id: 'deffuncacl', model: pgBrowser.Node.PrivilegeRoleModel.extend({ privileges: ['X'] }),
            label: gettext('Default Privileges: Functions'),
            editable: false, type: 'collection', group: gettext('Functions'),
            mode: ['edit', 'create'], control: 'unique-col-collection',
            canAdd: true, canDelete: true, uniqueCol: ['grantee', 'grantor']
          }, {
            id: 'deftypeacl', model: pgBrowser.Node.PrivilegeRoleModel.extend({ privileges: ['U'] }),
            label: gettext('Default Privileges: Types'),
            editable: false, type: 'collection', group: gettext('Types'),
            mode: ['edit', 'create'], control: 'unique-col-collection',
            canAdd: true, canDelete: true, uniqueCol: ['grantee', 'grantor'],
            min_version: 90200
          }]
        }],
        validate: function validate() {
          var err = {},
              errmsg = null;
          // Validation of mandatory fields
          this.errorModel.clear();
          if (_.isUndefined(this.get('name')) || _.isNull(this.get('name')) || String(this.get('name')).replace(/^\s+|\s+$/g, '') == '') {
            errmsg = gettext('Name cannot be empty.');
            this.errorModel.set('name', errmsg);
            return errmsg;
          } else if (_.isUndefined(this.get('namespaceowner')) || _.isNull(this.get('namespaceowner')) || String(this.get('namespaceowner')).replace(/^\s+|\s+$/g, '') == '') {
            errmsg = gettext('Owner cannot be empty.');
            this.errorModel.set('namespaceowner', errmsg);
            return errmsg;
          }
          return null;
        }
      }),
      // This function will checks whether we can allow user to
      // drop object or not based on location within schema & catalog
      canChildDrop: function canChildDrop(itemData, item) {
        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        // To iterate over tree to check parent node
        while (i) {
          // If it is schema then allow user to create collation
          if (_.indexOf(['schema'], d._type) > -1) return true;

          //Check if we are not child of catalog
          var prev_i = t.hasParent(i) ? t.parent(i) : null,
              prev_d = prev_i ? t.itemData(prev_i) : null;
          if (prev_d && prev_d._type == 'catalog') {
            return false;
          }
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // by default we do not want to allow create menu
        return true;
      }
    });

    pgBrowser.tableChildTreeNodeHierarchy = function (i) {
      var idx = 0,
          res = {},
          t = pgBrowser.tree;

      do {
        var d = t.itemData(i);
        if (d._type in pgBrowser.Nodes && pgBrowser.Nodes[d._type].hasId) {
          if (d._type === 'partition' || d._type === 'table') {
            if (!('table' in res)) {
              res['table'] = _.extend({}, d, { 'priority': idx });
              idx -= 1;
            }
          } else {
            res[d._type] = _.extend({}, d, { 'priority': idx });
            idx -= 1;
          }
        }
        i = t.hasParent(i) ? t.parent(i) : null;
      } while (i);

      return res;
    };
  }

  // Switch Cell with Deps (specifically for table children)
  var TableChildSwitchCell = Backgrid.Extension.TableChildSwitchCell = Backgrid.Extension.SwitchCell.extend({
    initialize: function initialize() {
      Backgrid.Extension.SwitchCell.prototype.initialize.apply(this, arguments);
      Backgrid.Extension.DependentCell.prototype.initialize.apply(this, arguments);
    },
    dependentChanged: function dependentChanged() {
      var model = this.model,
          column = this.column,
          editable = this.column.get("editable"),
          input = this.$el.find('input[type=checkbox]').first(),
          self_name = column.get('name'),
          is_editable;

      is_editable = _.isFunction(editable) ? !!editable.apply(column, [model]) : !!editable;
      if (is_editable) {
        this.$el.addClass("editable");
        input.bootstrapSwitch('disabled', false);
      } else {
        this.$el.removeClass("editable");
        input.bootstrapSwitch('disabled', true);
        // Set self value into model to false
        setTimeout(function () {
          model.set(self_name, false);
        }, 10);
      }

      this.delegateEvents();
      return this;
    },
    remove: Backgrid.Extension.DependentCell.prototype.remove
  });

  return pgBrowser.Nodes['schema'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(16), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, $, _, S, pgAdmin, pgBrowser, Backform, alertify) {

  // Extend the browser's collection class for catalog collection
  if (!pgBrowser.Nodes['coll-catalog']) {
    var databases = pgBrowser.Nodes['coll-catalog'] = pgBrowser.Collection.extend({
      node: 'catalog',
      label: gettext('Catalogs'),
      type: 'coll-catalog',
      columns: ['name', 'namespaceowner', 'description']
    });
  };
  // Extend the browser's node class for catalog node
  if (!pgBrowser.Nodes['catalog']) {
    pgBrowser.Nodes['catalog'] = pgBrowser.Node.extend({
      parent_type: 'database',
      type: 'catalog',
      label: gettext('Catalog'),
      hasSQL: true,
      hasDepends: true,
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;
      },
      model: pgBrowser.Node.Model.extend({
        defaults: {
          name: undefined,
          namespaceowner: undefined,
          nspacl: undefined,
          description: undefined,
          securitylabel: []
        },
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;

          if (isNew) {
            var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;

            this.set({ 'namespaceowner': userInfo.name }, { silent: true });
          }
          pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
        },
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', disabled: true
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string', mode: ['properties'],
          type: 'text', disabled: true
        }, {
          id: 'namespaceowner', label: gettext('Owner'), cell: 'string',
          type: 'text', disabled: true
        }, {
          id: 'acl', label: gettext('Privileges'), type: 'text',
          group: gettext('Security'), mode: ['properties'], disabled: true
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline'
        }, {
          id: 'seclabels', label: gettext('Security Labels'),
          model: pgBrowser.SecLabelModel, editable: false, type: 'collection',
          group: gettext('Security'), mode: ['edit', 'create'],
          min_version: 90200, canAdd: true,
          canEdit: false, canDelete: true, control: 'unique-col-collection'
        }],
        validate: function validate() {
          return null;
        }
      })
    });
  }

  return pgBrowser.Nodes['catalog'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, $, _, S, pgAdmin, pgBrowser, alertify) {

  if (!pgBrowser.Nodes['coll-catalog_object']) {
    var databases = pgAdmin.Browser.Nodes['coll-catalog_object'] = pgAdmin.Browser.Collection.extend({
      node: 'catalog_object',
      label: gettext('Catalog Objects'),
      type: 'coll-catalog_object',
      columns: ['name', 'owner', 'description']
    });
  };

  if (!pgBrowser.Nodes['catalog_object']) {
    pgAdmin.Browser.Nodes['catalog_object'] = pgAdmin.Browser.Node.extend({
      parent_type: 'catalog',
      type: 'catalog_object',
      label: gettext('Catalog Object'),
      hasSQL: false,
      hasScriptTypes: [],
      hasDepends: true,
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;
      },
      model: pgAdmin.Browser.Node.Model.extend({
        defaults: {
          name: undefined,
          namespaceowner: undefined,
          nspacl: undefined,
          description: undefined
        },
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', disabled: true
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', disabled: true
        }, {
          id: 'owner', label: gettext('Owner'), cell: 'string',
          type: 'text', disabled: true
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline', disabled: true
        }]
      })
    });
  }

  return pgBrowser.Nodes['catalog_object'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  if (!pgBrowser.Nodes['coll-collation']) {
    var databases = pgAdmin.Browser.Nodes['coll-collation'] = pgAdmin.Browser.Collection.extend({
      node: 'collation',
      label: gettext('Collations'),
      type: 'coll-collation',
      columns: ['name', 'owner', 'description']
    });
  };

  if (!pgBrowser.Nodes['collation']) {
    pgAdmin.Browser.Nodes['collation'] = pgBrowser.Node.extend({
      type: 'collation',
      sqlAlterHelp: 'sql-altercollation.html',
      sqlCreateHelp: 'sql-createcollation.html',
      dialogHelp: url_for('help.static', { 'filename': 'collation_dialog.html' }),
      label: gettext('Collation'),
      collection_type: 'coll-collation',
      hasSQL: true,
      hasDepends: true,
      parent_type: ['schema', 'catalog'],
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_collation_on_coll', node: 'coll-collation', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Collation...'),
          icon: 'wcTabIcon icon-collation', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_collation', node: 'collation', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Collation...'),
          icon: 'wcTabIcon icon-collation', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_collation', node: 'schema', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Collation...'),
          icon: 'wcTabIcon icon-collation', data: { action: 'create', check: false },
          enable: 'canCreate'
        }]);
      },
      canDrop: pgBrowser.Nodes['schema'].canChildDrop,
      canDropCascade: pgBrowser.Nodes['schema'].canChildDrop,
      model: pgAdmin.Browser.Node.Model.extend({
        defaults: {
          name: undefined,
          oid: undefined,
          owner: undefined,
          lc_type: undefined,
          lc_collate: undefined,
          description: undefined
        },

        // Default values!
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;

          if (isNew) {
            var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;
            var schemaInfo = args.node_info.schema;

            this.set({ 'owner': userInfo.name }, { silent: true });
            this.set({ 'schema': schemaInfo._label }, { silent: true });
          }
          pgAdmin.Browser.Node.Model.prototype.initialize.apply(this, arguments);
        },

        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'],
          disabled: 'inSchema'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', mode: ['properties']
        }, {
          id: 'owner', label: gettext('Owner'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'],
          disabled: 'inSchema', control: 'node-list-by-name',
          node: 'role'
        }, {
          id: 'schema', label: gettext('Schema'), cell: 'string',
          type: 'text', mode: ['create', 'edit'], node: 'schema',
          disabled: 'inSchema', filter: function filter(d) {
            // If schema name start with pg_* then we need to exclude them
            if (d && d.label.match(/^pg_/)) {
              return false;
            }
            return true;
          }, control: 'node-list-by-name',
          cache_node: 'database', cached_level: 'database'
        }, {
          id: 'copy_collation', label: gettext('Copy collation'), cell: 'string',
          control: 'node-ajax-options',
          type: 'text', mode: ['create', 'edit'], group: gettext('Definition'),
          url: 'get_collations', disabled: 'inSchemaWithModelCheck',
          deps: ['locale', 'lc_collate', 'lc_type']
        }, {
          id: 'locale', label: gettext('Locale'), cell: 'string',
          type: 'text', mode: ['create', 'edit'], group: gettext('Definition'),
          disabled: 'inSchemaWithModelCheck',
          deps: ['lc_collate', 'lc_type', 'copy_collation']
        }, {
          id: 'lc_collate', label: gettext('LC_COLLATE'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'], group: gettext('Definition'),
          deps: ['locale', 'copy_collation'], disabled: 'inSchemaWithModelCheck'
        }, {
          id: 'lc_type', label: gettext('LC_TYPE'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'], group: gettext('Definition'),
          disabled: 'inSchemaWithModelCheck',
          deps: ['locale', 'copy_collation']
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline', mode: ['properties', 'create', 'edit'],
          disabled: 'inSchema'
        }],
        validate: function validate() {
          var err = {},
              msg = undefined,
              changedAttrs = this.changed,
              locale_flag = false,
              lc_type_flag = false,
              lc_coll_flag = false,
              copy_coll_flag = false,
              msg = undefined,
              data = this.toJSON();

          this.errorModel.clear();

          if (_.has(changedAttrs, data.name) && _.isUndefined(this.get('name')) || String(this.get('name')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Name cannot be empty.');
            this.errorModel.set('name', msg);
          }
          if (_.has(changedAttrs, data.locale) && (_.isUndefined(this.get('locale')) || String(this.get('locale')).replace(/^\s+|\s+$/g, '') == '')) {
            locale_flag = true;
          }
          if (_.has(changedAttrs, data.lc_collate) && (_.isUndefined(this.get('lc_collate')) || String(this.get('lc_collate')).replace(/^\s+|\s+$/g, '') == '')) {
            lc_coll_flag = true;
          }
          if (_.has(changedAttrs, data.lc_type) && (_.isUndefined(this.get('lc_type')) || String(this.get('lc_type')).replace(/^\s+|\s+$/g, '') == '')) {
            lc_type_flag = true;
          }
          if (_.has(changedAttrs, data.copy_collation) && (_.isUndefined(this.get('copy_collation')) || String(this.get('copy_collation')).replace(/^\s+|\s+$/g, '') == '')) {
            copy_coll_flag = true;
          }
          if (locale_flag && (lc_coll_flag || lc_coll_flag) && copy_coll_flag) {
            msg = gettext('Definition incomplete, Please provide Locale OR Copy collation OR LC_TYPE/LC_COLLATE!');
            err['locale'] = msg;
          }
          return null;
        },
        // We will disable everything if we are under catalog node
        inSchema: function inSchema() {
          if (this.node_info && 'catalog' in this.node_info) {
            return true;
          }
          return false;
        },
        // We will check if we are under schema node & in 'create' mode
        inSchemaWithModelCheck: function inSchemaWithModelCheck(m) {
          if (this.node_info && 'schema' in this.node_info) {
            // Enable copy_collation only if locale & lc_* is not provided
            if (m.isNew() && this.name == "copy_collation") {
              if (m.get('locale')) return true;
              if (m.get('lc_collate') || m.get('lc_type')) return true;
              return false;
            }

            // Enable lc_* only if copy_collation & locale is not provided
            if (m.isNew() && (this.name == 'lc_collate' || this.name == 'lc_type')) {
              if (m.get('locale')) return true;
              if (m.get('copy_collation')) return true;
              return false;
            }

            // Enable localy only if lc_* & copy_collation is not provided
            if (m.isNew() && this.name == 'locale') {
              if (m.get('lc_collate') || m.get('lc_type')) return true;
              if (m.get('copy_collation')) return true;
              return false;
            }

            // We will disbale control if it's in 'edit' mode
            if (m.isNew()) {
              return false;
            } else {
              return true;
            }
          }
          return true;
        }
      }),
      canCreate: function canCreate(itemData, item, data) {
        //If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        // To iterate over tree to check parent node
        while (i) {
          // If it is schema then allow user to create collation
          if (_.indexOf(['schema'], d._type) > -1) return true;

          if ('coll-collation' == d._type) {
            //Check if we are not child of catalog
            var prev_i = t.hasParent(i) ? t.parent(i) : null,
                prev_d = prev_i ? t.itemData(prev_i) : null;
            if (prev_d._type == 'catalog') {
              return false;
            } else {
              return true;
            }
          }
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // by default we do not want to allow create menu
        return true;
      }
    });
  }

  return pgBrowser.Nodes['collation'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backgrid, Backbone) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

// Domain Module: Collection and Node.
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  // Define Domain Collection Node
  if (!pgBrowser.Nodes['coll-domain']) {
    var domains = pgBrowser.Nodes['coll-domain'] = pgBrowser.Collection.extend({
      node: 'domain',
      label: gettext('Domains'),
      type: 'coll-domain',
      columns: ['name', 'owner', 'description']
    });
  };

  // Constraint Model
  var ConstraintModel = pgBrowser.Node.Model.extend({
    idAttribute: 'conoid',
    initialize: function initialize(attrs, args) {
      if (!_.size(attrs) === 0) {
        this.convalidated_default = this.get('convalidated');
      }
      pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
    },
    defaults: {
      conoid: undefined,
      conname: undefined,
      consrc: undefined,
      convalidated: true
    },
    convalidated_default: true,
    schema: [{
      id: 'conoid', type: 'text', cell: 'string', visible: false
    }, {
      id: 'conname', label: gettext('Name'), type: 'text', cell: 'string',
      cellHeaderClasses: 'width_percent_40',
      editable: function editable(m) {
        if (_.isUndefined(m.isNew)) {
          return true;
        }
        if (!m.isNew()) {
          var server = this.get('node_info').server;
          if (server.version < 90200) {
            return false;
          }
        }
        return true;
      }
    }, {
      id: 'consrc', label: gettext('Check'), type: 'multiline',
      cell: Backgrid.Extension.TextareaCell, group: gettext('Definition'),
      cellHeaderClasses: 'width_percent_60', editable: function editable(m) {
        return _.isUndefined(m.isNew) ? true : m.isNew();
      }
    }, {
      id: 'convalidated', label: gettext('Validate?'), type: 'switch', cell: 'boolean', group: gettext('Definition'),
      editable: function editable(m) {
        var server = this.get('node_info').server;
        if (server.version < 90200) {
          return false;
        }
        if (_.isUndefined(m.isNew)) {
          return true;
        }
        if (!m.isNew()) {
          if (m.get('convalidated') && m.convalidated_default) {
            return false;
          }
          return true;
        }
        return true;
      }
    }],
    toJSON: Backbone.Model.prototype.toJSON,
    validate: function validate() {
      return null;
    }
  });

  // Domain Node
  if (!pgBrowser.Nodes['domain']) {
    pgBrowser.Nodes['domain'] = pgBrowser.Node.extend({
      type: 'domain',
      sqlAlterHelp: 'sql-alterdomain.html',
      sqlCreateHelp: 'sql-createdomain.html',
      dialogHelp: url_for('help.static', { 'filename': 'domain_dialog.html' }),
      label: gettext('Domain'),
      collection_type: 'coll-domain',
      hasSQL: true,
      hasDepends: true,
      parent_type: ['schema', 'catalog'],
      Init: function Init() {
        // Avoid mulitple registration of menus
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_domain_on_coll', node: 'coll-domain', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Domain...'),
          icon: 'wcTabIcon icon-domain', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_domain', node: 'domain', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Domain...'),
          icon: 'wcTabIcon icon-domain', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_domain', node: 'schema', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Domain...'),
          icon: 'wcTabIcon icon-domain', data: { action: 'create', check: false },
          enable: 'canCreate'
        }]);
      },
      canDrop: pgBrowser.Nodes['schema'].canChildDrop,
      canDropCascade: pgBrowser.Nodes['schema'].canChildDrop,
      // Domain Node Model
      model: pgBrowser.Node.Model.extend({
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;
          if (isNew) {
            // Set Selected Schema
            var schema = args.node_info.schema.label;
            this.set({ 'basensp': schema }, { silent: true });

            // Set Current User
            var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;
            this.set({ 'owner': userInfo.name }, { silent: true });
          }
          pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
        },
        defaults: {
          name: undefined,
          oid: undefined,
          owner: undefined,
          basensp: undefined,
          description: undefined,
          basetype: undefined,
          typlen: undefined,
          precision: undefined,
          typdefault: undefined,
          typnotnull: undefined,
          sysdomain: undefined,
          collname: undefined,
          constraints: [],
          seclabels: []
        },
        type_options: undefined,
        // Domain Schema
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit']
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', mode: ['properties']
        }, {
          id: 'owner', label: gettext('Owner'), cell: 'string', control: Backform.NodeListByNameControl,
          node: 'role', type: 'text', mode: ['edit', 'create', 'properties']
        }, {
          id: 'basensp', label: gettext('Schema'), cell: 'node-list-by-name',
          control: 'node-list-by-name', cache_level: 'database', type: 'text',
          node: 'schema', mode: ['create', 'edit']
        }, {
          id: 'sysdomain', label: gettext('System domain?'), cell: 'boolean',
          type: 'switch', mode: ['properties'],
          options: {
            'onText': 'Yes', 'offText': 'No',
            'onColor': 'success', 'offColor': 'primary',
            'size': 'small'
          }
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline'
        }, {
          id: 'basetype', label: gettext('Base type'), cell: 'string',
          control: 'node-ajax-options', type: 'text', url: 'get_types',
          mode: ['properties', 'create', 'edit'], group: gettext('Definition'),
          cache_level: 'database', cache_node: 'schema', disabled: function disabled(m) {
            return !m.isNew();
          }, first_empty: true, transform: function transform(d) {
            this.model.type_options = d;
            return d;
          }
        }, {
          id: 'typlen', label: gettext('Length'), cell: 'string',
          type: 'text', group: gettext('Definition'), deps: ['basetype'],
          disabled: function disabled(m) {
            // We will store type from selected from combobox
            if (!m.isNew()) {
              return true;
            }
            var of_type = m.get('basetype');
            if (m.type_options) {
              // iterating over all the types
              _.each(m.type_options, function (o) {
                // if type from selected from combobox matches in options
                if (of_type == o.value) {
                  // if length is allowed for selected type
                  if (o.length) {
                    // set the values in model
                    m.set('is_tlength', true, { silent: true });
                    m.set('min_val', o.min_val, { silent: true });
                    m.set('max_val', o.max_val, { silent: true });
                  }
                }
              });
            }
            return !m.get('is_tlength');
          }
        }, {
          id: 'precision', label: gettext('Precision'), cell: 'string',
          type: 'text', group: gettext('Definition'), deps: ['basetype'],
          disabled: function disabled(m) {
            // We will store type from selected from combobox
            if (!m.isNew()) {
              return true;
            }
            var of_type = m.get('basetype');
            if (m.type_options) {
              // iterating over all the types
              _.each(m.type_options, function (o) {
                // if type from selected from combobox matches in options
                if (of_type == o.value) {
                  // if precession is allowed for selected type
                  if (o.precision) {
                    // set the values in model
                    m.set('is_precision', true, { silent: true });
                    m.set('min_val', o.min_val, { silent: true });
                    m.set('max_val', o.max_val, { silent: true });
                  }
                }
              });
            }
            return !m.get('is_precision');
          }
        }, {
          id: 'typdefault', label: gettext('Default'), cell: 'string',
          type: 'text', group: gettext('Definition'),
          placeholder: "Enter an expression or a value."
        }, {
          id: 'typnotnull', label: gettext('Not Null?'), cell: 'boolean',
          type: 'switch', group: gettext('Definition'),
          options: {
            'onText': 'Yes', 'offText': 'No',
            'onColor': 'success', 'offColor': 'primary',
            'size': 'small'
          }
        }, {
          id: 'collname', label: gettext('Collation'), cell: 'string',
          control: 'node-ajax-options', type: 'text', url: 'get_collations',
          group: gettext('Definition'), cache_level: 'database',
          cache_node: 'schema', disabled: function disabled(m) {
            return !m.isNew();
          }
        }, {
          id: 'constraints', label: gettext('Constraints'), cell: 'string',
          type: 'collection', group: gettext('Constraints'), mode: ['edit', 'create'],
          model: ConstraintModel, canAdd: true, canDelete: true,
          canEdit: false, columns: ['conname', 'consrc', 'convalidated']
        }, pgBrowser.SecurityGroupSchema, {
          id: 'seclabels', label: gettext('Security Labels'),
          model: pgBrowser.SecLabelModel, type: 'collection',
          group: 'security', mode: ['edit', 'create'],
          min_version: 90100, canAdd: true,
          canEdit: false, canDelete: true,
          control: 'unique-col-collection', uniqueCol: ['provider']
        }],
        validate: function validate() {
          // Client Side Validation
          var err = {},
              errmsg,
              seclabels = this.get('seclabels');

          if (_.isUndefined(this.get('name')) || String(this.get('name')).replace(/^\s+|\s+$/g, '') == '') {
            err['name'] = gettext('Name cannot be empty.');
            errmsg = errmsg || err['name'];
          }

          if (_.isUndefined(this.get('basetype')) || String(this.get('basetype')).replace(/^\s+|\s+$/g, '') == '') {
            err['basetype'] = gettext('Base Type cannot be empty.');
            errmsg = errmsg || err['basetype'];
          }

          this.errorModel.clear().set(err);

          return null;
        }
      }),
      canCreate: function canCreate(itemData, item, data) {
        //If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        // To iterate over tree to check parent node
        while (i) {
          // If it is schema then allow user to create domain
          if (_.indexOf(['schema'], d._type) > -1) return true;

          if ('coll-domain' == d._type) {
            //Check if we are not child of catalog
            var prev_i = t.hasParent(i) ? t.parent(i) : null,
                prev_d = prev_i ? t.itemData(prev_i) : null;
            if (prev_d._type == 'catalog') {
              return false;
            } else {
              return true;
            }
          }
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // by default we do not want to allow create menu
        return true;
      },
      isDisabled: function isDisabled(m) {
        if (!m.isNew()) {
          var server = this.node_info.server;
          if (server.version < 90200) {
            return false;
          }
        }
        return true;
      }
    });
  }

  return pgBrowser.Nodes['domain'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13), __webpack_require__(10)))

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

// Domain Constraint Module: Collection and Node
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  // Define Domain Constraint Collection Node
  if (!pgBrowser.Nodes['coll-domain_constraints']) {
    var domain_constraints = pgAdmin.Browser.Nodes['coll-domain_constraints'] = pgAdmin.Browser.Collection.extend({
      node: 'domain_constraints',
      label: gettext('Domain Constraints'),
      type: 'coll-domain_constraints',
      columns: ['name', 'description']
    });
  };

  // Domain Constraint Node
  if (!pgBrowser.Nodes['domain_constraints']) {
    pgAdmin.Browser.Nodes['domain_constraints'] = pgBrowser.Node.extend({
      type: 'domain_constraints',
      sqlAlterHelp: 'sql-alterdomain.html',
      sqlCreateHelp: 'sql-alterdomain.html',
      dialogHelp: url_for('help.static', { 'filename': 'domain_constraint_dialog.html' }),
      label: gettext('Domain Constraints'),
      collection_type: 'coll-domain_constraints',
      hasSQL: true,
      hasDepends: true,
      parent_type: ['domain'],
      Init: function Init() {
        // Avoid mulitple registration of menus
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_domain_on_coll', node: 'coll-domain_constraints', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 5, label: gettext('Domain Constraint...'),
          icon: 'wcTabIcon icon-domain_constraints', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_domain_constraints', node: 'domain_constraints', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 5, label: gettext('Domain Constraint...'),
          icon: 'wcTabIcon icon-domain_constraints', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_domain_constraints', node: 'domain', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 5, label: gettext('Domain Constraint...'),
          icon: 'wcTabIcon icon-domain_constraints', data: { action: 'create', check: false },
          enable: 'canCreate'
        }]);
      },
      canDrop: pgBrowser.Nodes['schema'].canChildDrop,
      model: pgAdmin.Browser.Node.Model.extend({
        defaults: {
          name: undefined,
          oid: undefined,
          description: undefined,
          consrc: undefined,
          connoinherit: undefined,
          convalidated: true
        },
        // Domain Constraint Schema
        schema: [{
          id: 'name', label: gettext('Name'), type: 'text', cell: 'string',
          disabled: 'isDisabled'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', mode: ['properties']
        }, {
          id: 'description', label: gettext('Comment'), type: 'multiline', cell: 'string', mode: ['properties', 'create', 'edit'], min_version: 90500
        }, {
          id: 'consrc', label: gettext('Check'), type: 'multiline', cel: 'string', group: gettext('Definition'), mode: ['properties', 'create', 'edit'], disabled: function disabled(m) {
            return !m.isNew();
          }
        }, {
          id: 'connoinherit', label: gettext('No inherit'), type: 'switch', cell: 'boolean', group: gettext('Definition'), mode: ['properties', 'create', 'edit'], disabled: 'isDisabled',
          visible: false
        }, {
          id: 'convalidated', label: gettext("Validate?"), type: 'switch', cell: 'boolean', group: gettext('Definition'), min_version: 90200,
          disabled: function disabled(m) {
            if (!m.isNew()) {
              var server = this.node_info.server;
              if (server.version < 90200) {
                return true;
              } else if (m.get('convalidated')) {
                return true;
              }
              return false;
            }
            return false;
          },
          mode: ['properties', 'create', 'edit']
        }],
        // Client Side Validation
        validate: function validate() {
          var err = {},
              errmsg;

          if (_.isUndefined(this.get('name')) || String(this.get('name')).replace(/^\s+|\s+$/g, '') == '') {
            err['name'] = gettext('Name cannot be empty.');
            errmsg = errmsg || err['name'];
          }

          if (_.isUndefined(this.get('consrc')) || String(this.get('consrc')).replace(/^\s+|\s+$/g, '') == '') {
            err['consrc'] = gettext('Check cannot be empty.');
            errmsg = errmsg || err['consrc'];
          }

          this.errorModel.clear().set(err);

          if (_.size(err)) {
            this.trigger('on-status', { msg: errmsg });
            return errmsg;
          }

          return null;
        },
        isDisabled: function isDisabled(m) {
          if (!m.isNew()) {
            var server = this.node_info.server;
            if (server.version < 90200) {
              return true;
            }
          }
          return false;
        }
      })
    });
  }

  return pgBrowser.Nodes['domain'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backgrid, Backbone) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/* Create and Register Foreign Table Collection and Node. */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  if (!pgBrowser.Nodes['coll-foreign_table']) {
    var foreigntable = pgBrowser.Nodes['coll-foreign_table'] = pgBrowser.Collection.extend({
      node: 'foreign_table',
      label: gettext('Foreign Tables'),
      type: 'coll-foreign_table',
      columns: ['name', 'owner', 'description']
    });
  };

  // Integer Cell for Columns Length and Precision
  var IntegerDepCell = Backgrid.IntegerCell.extend({
    initialize: function initialize() {
      Backgrid.NumberCell.prototype.initialize.apply(this, arguments);
      Backgrid.Extension.DependentCell.prototype.initialize.apply(this, arguments);
    },
    dependentChanged: function dependentChanged() {
      this.$el.empty();
      var model = this.model;
      var column = this.column;
      var editable = this.column.get("editable");
      var is_editable = _.isFunction(editable) ? !!editable.apply(column, [model]) : !!editable;

      if (is_editable) {
        this.$el.addClass("editable");
      } else {
        this.$el.removeClass("editable");
      }

      this.delegateEvents();
      return this;
    },
    remove: Backgrid.Extension.DependentCell.prototype.remove
  });

  // Options Model
  var ColumnOptionsModel = pgBrowser.Node.Model.extend({
    idAttribute: 'option',
    defaults: {
      option: undefined,
      value: undefined
    },
    schema: [{ id: 'option', label: 'Option', type: 'text', editable: true, cellHeaderClasses: 'width_percent_30' }, {
      id: 'value', label: 'Value', type: 'text', editable: true, cellHeaderClasses: 'width_percent_50'
    }],
    validate: function validate() {
      if (_.isUndefined(this.get('value')) || _.isNull(this.get('value')) || String(this.get('value')).replace(/^\s+|\s+$/g, '') == '') {
        var msg = 'Please enter a value.';

        this.errorModel.set('value', msg);

        return msg;
      } else {
        this.errorModel.unset('value');
      }

      return null;
    }
  });

  // Columns Model
  var ColumnsModel = pgBrowser.Node.Model.extend({
    idAttribute: 'attnum',
    defaults: {
      attname: undefined,
      datatype: undefined,
      typlen: undefined,
      precision: undefined,
      typdefault: undefined,
      attnotnull: undefined,
      collname: undefined,
      attnum: undefined,
      inheritedfrom: undefined,
      inheritedid: undefined,
      attstattarget: undefined,
      coloptions: []
    },
    type_options: undefined,
    schema: [{
      id: 'attname', label: gettext('Name'), cell: 'string', type: 'text',
      editable: 'is_editable_column', cellHeaderClasses: 'width_percent_40'
    }, {
      id: 'datatype', label: gettext('Data Type'), cell: 'node-ajax-options',
      control: 'node-ajax-options', type: 'text', url: 'get_types',
      editable: 'is_editable_column', cellHeaderClasses: 'width_percent_0',
      group: gettext('Definition'),
      transform: function transform(d, self) {
        self.model.type_options = d;
        return d;
      }
    }, {
      id: 'typlen', label: gettext('Length'),
      cell: 'string', group: gettext('Definition'),
      type: 'int', deps: ['datatype'],
      disabled: function disabled(m) {
        var val = m.get('typlen');
        // We will store type from selected from combobox
        if (!(_.isUndefined(m.get('inheritedid')) || _.isNull(m.get('inheritedid')) || _.isUndefined(m.get('inheritedfrom')) || _.isNull(m.get('inheritedfrom')))) {

          if (!_.isUndefined(val)) {
            setTimeout(function () {
              m.set('typlen', undefined);
            }, 10);
          }
          return true;
        }

        var of_type = m.get('datatype'),
            has_length = false;
        if (m.type_options) {
          m.set('is_tlength', false, { silent: true });

          // iterating over all the types
          _.each(m.type_options, function (o) {
            // if type from selected from combobox matches in options
            if (of_type == o.value) {
              // if length is allowed for selected type
              if (o.length) {
                // set the values in model
                has_length = true;
                m.set('is_tlength', true, { silent: true });
                m.set('min_val', o.min_val, { silent: true });
                m.set('max_val', o.max_val, { silent: true });
              }
            }
          });

          if (!has_length && !_.isUndefined(val)) {
            setTimeout(function () {
              m.set('typlen', undefined);
            }, 10);
          }

          return !m.get('is_tlength');
        }
        if (!has_length && !_.isUndefined(val)) {
          setTimeout(function () {
            m.set('typlen', undefined);
          }, 10);
        }
        return true;
      },
      cellHeaderClasses: 'width_percent_10'
    }, {
      id: 'precision', label: gettext('Precision'),
      type: 'int', deps: ['datatype'],
      cell: 'string', group: gettext('Definition'),
      disabled: function disabled(m) {
        var val = m.get('precision');
        if (!(_.isUndefined(m.get('inheritedid')) || _.isNull(m.get('inheritedid')) || _.isUndefined(m.get('inheritedfrom')) || _.isNull(m.get('inheritedfrom')))) {

          if (!_.isUndefined(val)) {
            setTimeout(function () {
              m.set('precision', undefined);
            }, 10);
          }
          return true;
        }

        var of_type = m.get('datatype'),
            has_precision = false;

        if (m.type_options) {
          m.set('is_precision', false, { silent: true });
          // iterating over all the types
          _.each(m.type_options, function (o) {
            // if type from selected from combobox matches in options
            if (of_type == o.value) {
              // if precession is allowed for selected type
              if (o.precision) {
                has_precision = true;
                // set the values in model
                m.set('is_precision', true, { silent: true });
                m.set('min_val', o.min_val, { silent: true });
                m.set('max_val', o.max_val, { silent: true });
              }
            }
          });
          if (!has_precision && !_.isUndefined(val)) {
            setTimeout(function () {
              m.set('precision', undefined);
            }, 10);
          }
          return !m.get('is_precision');
        }
        if (!has_precision && !_.isUndefined(val)) {
          setTimeout(function () {
            m.set('precision', undefined);
          }, 10);
        }
        return true;
      }, cellHeaderClasses: 'width_percent_10'
    }, {
      id: 'typdefault', label: gettext('Default'), type: 'text',
      cell: 'string', min_version: 90300, group: gettext('Definition'),
      placeholder: "Enter an expression or a value.",
      cellHeaderClasses: 'width_percent_10',
      editable: function editable(m) {
        if (!(_.isUndefined(m.get('inheritedid')) || _.isNull(m.get('inheritedid')) || _.isUndefined(m.get('inheritedfrom')) || _.isNull(m.get('inheritedfrom')))) {
          return false;
        }
        if (this.get('node_info').server.version < 90300) {
          return false;
        }
        return true;
      }
    }, {
      id: 'attnotnull', label: gettext('Not Null'),
      cell: 'boolean', type: 'switch', editable: 'is_editable_column',
      cellHeaderClasses: 'width_percent_10', group: gettext('Definition')
    }, {
      id: 'attstattarget', label: gettext('Statistics'), min_version: 90200,
      cell: 'integer', type: 'int', group: gettext('Definition'),
      editable: function editable(m) {
        if (_.isUndefined(m.isNew) || m.isNew()) {
          return false;
        }
        if (this.get('node_info').server.version < 90200) {
          return false;
        }
        return _.isUndefined(m.get('inheritedid')) || _.isNull(m.get('inheritedid')) || _.isUndefined(m.get('inheritedfrom')) || _.isNull(m.get('inheritedfrom')) ? true : false;
      }, cellHeaderClasses: 'width_percent_10'
    }, {
      id: 'collname', label: gettext('Collation'), cell: 'node-ajax-options',
      control: 'node-ajax-options', type: 'text', url: 'get_collations',
      min_version: 90300, editable: function editable(m) {
        if (!_.isUndefined(m.isNew) && !m.isNew()) {
          return false;
        }
        return _.isUndefined(m.get('inheritedid')) || _.isNull(m.get('inheritedid')) || _.isUndefined(m.get('inheritedfrom')) || _.isNull(m.get('inheritedfrom')) ? true : false;
      },
      cellHeaderClasses: 'width_percent_20', group: gettext('Definition')
    }, {
      id: 'attnum', cell: 'string', type: 'text', visible: false
    }, {
      id: 'inheritedfrom', label: gettext('Inherited From'), cell: 'string',
      type: 'text', visible: false, mode: ['properties', 'edit'],
      cellHeaderClasses: 'width_percent_10'
    }, {
      id: 'coloptions', label: gettext('Options'), cell: 'string',
      type: 'collection', group: gettext('Options'), mode: ['edit', 'create'],
      model: ColumnOptionsModel, canAdd: true, canDelete: true, canEdit: false,
      control: Backform.UniqueColCollectionControl, uniqueCol: ['option'],
      min_version: 90200
    }],
    validate: function validate() {
      var errmsg = null;

      if (_.isUndefined(this.get('attname')) || String(this.get('attname')).replace(/^\s+|\s+$/g, '') == '') {
        errmsg = gettext('Column Name cannot be empty!');
        this.errorModel.set('attname', errmsg);
      } else {
        this.errorModel.unset('attname');
      }

      if (_.isUndefined(this.get('datatype')) || String(this.get('datatype')).replace(/^\s+|\s+$/g, '') == '') {
        errmsg = gettext('Column Datatype cannot be empty!');
        this.errorModel.set('datatype', errmsg);
      } else {
        this.errorModel.unset('datatype');
      }

      return errmsg;
    },
    is_editable_column: function is_editable_column(m) {
      return _.isUndefined(m.get('inheritedid')) || _.isNull(m.get('inheritedid')) || _.isUndefined(m.get('inheritedfrom')) || _.isNull(m.get('inheritedfrom')) ? true : false;
    },
    toJSON: Backbone.Model.prototype.toJSON
  });

  /* NodeAjaxOptionsMultipleControl is for multiple selection of Combobox.
  *  This control is used to select Multiple Parent Tables to be inherited.
  *  It also populates/vacates Columns on selection/deselection of the option (i.e. table name).
  *  To populates the column, it calls the server and fetch the columns data
  *  for the selected table.
  */
  var NodeAjaxOptionsMultipleControl = Backform.NodeAjaxOptionsControl.extend({
    onChange: function onChange(e) {
      var model = this.model,
          $el = $(e.target),
          attrArr = this.field.get("name").split('.'),
          name = attrArr.shift(),
          path = attrArr.join('.'),
          value = this.getValueFromDOM(),
          changes = {},
          columns = model.get('columns'),
          inherits = model.get(name);

      if (this.model.errorModel instanceof Backbone.Model) {
        if (_.isEmpty(path)) {
          this.model.errorModel.unset(name);
        } else {
          var nestedError = this.model.errorModel.get(name);
          if (nestedError) {
            this.keyPathSetter(nestedError, path, null);
            this.model.errorModel.set(name, nestedError);
          }
        }
      }

      var self = this;

      if (typeof inherits == "string") {
        inherits = JSON.parse(inherits);
      }

      // Remove Columns if inherit option is deselected from the combobox
      if (_.size(value) < _.size(inherits)) {
        var dif = _.difference(inherits, value);
        var rmv_columns = columns.where({ inheritedid: parseInt(dif[0]) });
        columns.remove(rmv_columns);
      } else {
        _.each(value, function (i) {
          // Fetch Columns from server
          var fnd_columns = columns.where({ inheritedid: parseInt(i) });
          if (fnd_columns && fnd_columns.length <= 0) {
            inhted_columns = self.fetchColumns(i);
            columns.add(inhted_columns);
          }
        });
      }

      changes[name] = _.isEmpty(path) ? value : _.clone(model.get(name)) || {};
      this.stopListening(this.model, "change:" + name, this.render);
      model.set(changes);
      this.listenTo(this.model, "change:" + name, this.render);
    },
    fetchColumns: function fetchColumns(table_id) {
      var self = this,
          url = 'get_columns',
          m = self.model.top || self.model;

      if (url) {
        var node = this.field.get('schema_node'),
            node_info = this.field.get('node_info'),
            full_url = node.generate_url.apply(node, [null, url, this.field.get('node_data'), this.field.get('url_with_id') || false, node_info]),
            cache_level = this.field.get('cache_level') || node.type,
            cache_node = this.field.get('cache_node');

        cache_node = cache_node && pgBrowser.Nodes['cache_node'] || node;

        m.trigger('pgadmin:view:fetching', m, self.field);
        var data = { attrelid: table_id

          // Fetching Columns data for the selected table.
        };$.ajax({
          async: false,
          url: full_url,
          data: data,
          success: function success(res) {
            /*
             * We will cache this data for short period of time for avoiding
             * same calls.
             */
            data = cache_node.cache(url, node_info, cache_level, res.data);
          },
          error: function error() {
            m.trigger('pgadmin:view:fetch:error', m, self.field);
          }
        });
        m.trigger('pgadmin:view:fetched', m, self.field);

        // To fetch only options from cache, we do not need time from 'at'
        // attribute but only options.
        //
        // It is feasible that the data may not have been fetched.
        data = data && data.data || [];
        return data;
      }
    }
  });

  // Constraints Model
  var ConstraintModel = pgBrowser.Node.Model.extend({
    idAttribute: 'conoid',
    initialize: function initialize(attrs, args) {
      var isNew = _.size(attrs) === 0;
      if (!isNew) {
        this.convalidated_default = this.get('convalidated');
      }
      pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
    },
    defaults: {
      conoid: undefined,
      conname: undefined,
      consrc: undefined,
      connoinherit: undefined,
      convalidated: true,
      conislocal: undefined
    },
    convalidated_default: true,
    schema: [{
      id: 'conoid', type: 'text', cell: 'string', visible: false
    }, {
      id: 'conname', label: gettext('Name'), type: 'text', cell: 'string',
      editable: 'is_editable', cellHeaderClasses: 'width_percent_30'
    }, {
      id: 'consrc', label: gettext('Check'), type: 'multiline',
      editable: 'is_editable', cell: Backgrid.Extension.TextareaCell,
      cellHeaderClasses: 'width_percent_30'
    }, {
      id: 'connoinherit', label: gettext('No Inherit'), type: 'switch',
      cell: 'boolean', editable: 'is_editable',
      cellHeaderClasses: 'width_percent_20'
    }, {
      id: 'convalidated', label: gettext('Validate?'), type: 'switch',
      cell: 'boolean', cellHeaderClasses: 'width_percent_20',
      editable: function editable(m) {
        var server = this.get('node_info').server;
        if (_.isUndefined(m.isNew)) {
          return true;
        }
        if (!m.isNew()) {
          if (m.get('convalidated') && m.convalidated_default) {
            return false;
          }
          return true;
        }
        return true;
      }
    }],
    validate: function validate() {
      var err = {},
          errmsg;

      if (_.isUndefined(this.get('conname')) || String(this.get('conname')).replace(/^\s+|\s+$/g, '') == '') {
        err['conname'] = gettext('Constraint Name cannot be empty!');
        errmsg = errmsg || err['conname'];
      }

      if (_.isUndefined(this.get('consrc')) || String(this.get('consrc')).replace(/^\s+|\s+$/g, '') == '') {
        err['consrc'] = gettext('Constraint Check cannot be empty!');
        errmsg = errmsg || err['consrc'];
      }

      this.errorModel.clear().set(err);

      return errmsg;
    },
    is_editable: function is_editable(m) {
      return _.isUndefined(m.isNew) ? true : m.isNew();
    },
    toJSON: Backbone.Model.prototype.toJSON
  });

  // Options Model
  var OptionsModel = pgBrowser.Node.Model.extend({
    defaults: {
      option: undefined,
      value: undefined
    },
    schema: [{
      id: 'option', label: gettext('Option'), cell: 'string', type: 'text',
      editable: true, cellHeaderClasses: 'width_percent_50'
    }, {
      id: 'value', label: gettext('Value'), cell: 'string', type: 'text',
      editable: true, cellHeaderClasses: 'width_percent_50'
    }],
    validate: function validate() {
      // TODO: Add validation here
    },
    toJSON: Backbone.Model.prototype.toJSON
  });

  if (!pgBrowser.Nodes['foreign_table']) {
    pgBrowser.Nodes['foreign_table'] = pgBrowser.Node.extend({
      type: 'foreign_table',
      sqlAlterHelp: 'sql-alterforeigntable.html',
      sqlCreateHelp: 'sql-createforeigntable.html',
      dialogHelp: url_for('help.static', { 'filename': 'foreign_table_dialog.html' }),
      label: gettext('Foreign Table'),
      collection_type: 'coll-foreign_table',
      hasSQL: true,
      hasDepends: true,
      hasScriptTypes: ['create', 'select', 'insert', 'update', 'delete'],
      parent_type: ['schema'],
      Init: function Init() {
        /* Avoid multiple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_foreign_table_on_coll', node: 'coll-foreign_table', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Foreign Table...'),
          icon: 'wcTabIcon icon-foreign_table', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_foreign_table', node: 'foreign_table', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Foreign Table...'),
          icon: 'wcTabIcon icon-foreign_table', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_foreign_table', node: 'schema', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Foreign Table...'),
          icon: 'wcTabIcon icon-foreign_table', data: { action: 'create', check: false },
          enable: 'canCreate'
        }]);
      },
      canDrop: pgBrowser.Nodes['schema'].canChildDrop,
      canDropCascade: pgBrowser.Nodes['schema'].canChildDrop,
      model: pgBrowser.Node.Model.extend({
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;
          if (isNew) {
            var schema = args.node_info.schema._label,
                userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;

            // Set Selected Schema and Current User
            this.set({
              'basensp': schema, 'owner': userInfo.name
            }, { silent: true });
          }
          pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
        },
        defaults: {
          name: undefined,
          oid: undefined,
          owner: undefined,
          basensp: undefined,
          description: undefined,
          ftsrvname: undefined,
          strftoptions: undefined,
          inherits: [],
          columns: [],
          constraints: [],
          ftoptions: [],
          relacl: [],
          stracl: [],
          seclabels: []
        },
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit']
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', mode: ['properties']
        }, {
          id: 'owner', label: gettext('Owner'), cell: 'string',
          control: Backform.NodeListByNameControl,
          node: 'role', type: 'text', select2: { allowClear: false }
        }, {
          id: 'basensp', label: gettext('Schema'), cell: 'node-list-by-name',
          control: 'node-list-by-name', cache_level: 'database', type: 'text',
          node: 'schema', mode: ['create', 'edit']
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline'
        }, {
          id: 'ftsrvname', label: gettext('Foreign server'), cell: 'string', control: 'node-ajax-options',
          type: 'text', group: gettext('Definition'), url: 'get_foreign_servers', disabled: function disabled(m) {
            return !m.isNew();
          }
        }, {
          id: 'inherits', label: gettext('Inherits'), group: gettext('Definition'),
          type: 'array', min_version: 90500, control: NodeAjaxOptionsMultipleControl,
          url: 'get_tables', select2: { multiple: true },
          'cache_level': 'database',
          transform: function transform(d, self) {
            if (this.field.get('mode') == 'edit') {
              var oid = this.model.get('oid');
              var s = _.findWhere(d, { 'id': oid });
              if (s) {
                d = _.reject(d, s);
              }
            }
            return d;
          }
        }, {
          id: 'columns', label: gettext('Columns'), cell: 'string',
          type: 'collection', group: gettext('Columns'), visible: false, mode: ['edit', 'create'],
          model: ColumnsModel, canAdd: true, canDelete: true, canEdit: true,
          columns: ['attname', 'datatype', 'inheritedfrom'],
          canDeleteRow: function canDeleteRow(m) {
            return _.isUndefined(m.get('inheritedid')) || _.isNull(m.get('inheritedid')) || _.isUndefined(m.get('inheritedfrom')) || _.isNull(m.get('inheritedfrom')) ? true : false;
          },
          canEditRow: function canEditRow(m) {
            return _.isUndefined(m.get('inheritedid')) || _.isNull(m.get('inheritedid')) || _.isUndefined(m.get('inheritedfrom')) || _.isNull(m.get('inheritedfrom')) ? true : false;
          }
        }, {
          id: 'constraints', label: gettext('Constraints'), cell: 'string',
          type: 'collection', group: gettext('Constraints'), visible: false, mode: ['edit', 'create'],
          model: ConstraintModel, canAdd: true, canDelete: true, columns: ['conname', 'consrc', 'connoinherit', 'convalidated'],
          canEdit: function canEdit(o) {
            if (o instanceof Backbone.Model) {
              if (o instanceof ConstraintModel) {
                return o.isNew();
              }
            }
            return true;
          }, min_version: 90500, canDeleteRow: function canDeleteRow(m) {
            return m.get('conislocal') == true || _.isUndefined(m.get('conislocal')) ? true : false;
          }
        }, {
          id: 'strftoptions', label: gettext('Options'), cell: 'string',
          type: 'text', group: gettext('Definition'), mode: ['properties']
        }, {
          id: 'ftoptions', label: gettext('Options'), cell: 'string',
          type: 'collection', group: gettext('Options'), mode: ['edit', 'create'],
          model: OptionsModel, canAdd: true, canDelete: true, canEdit: false,
          control: 'unique-col-collection', uniqueCol: ['option']
        }, {
          id: 'relacl', label: gettext('Privileges'), cell: 'string',
          type: 'text', group: gettext('Security'),
          mode: ['properties'], min_version: 90200
        }, pgBrowser.SecurityGroupSchema, {
          id: 'acl', label: gettext('Privileges'), model: pgAdmin.Browser.Node.PrivilegeRoleModel.extend({ privileges: ['a', 'r', 'w', 'x'] }), uniqueCol: ['grantee', 'grantor'],
          editable: false, type: 'collection', group: 'security',
          mode: ['edit', 'create'],
          canAdd: true, canDelete: true, control: 'unique-col-collection',
          min_version: 90200
        }, {
          id: 'seclabels', label: gettext('Security Labels'),
          model: pgBrowser.SecLabelModel, type: 'collection',
          group: 'security', mode: ['edit', 'create'],
          min_version: 90100, canAdd: true,
          canEdit: false, canDelete: true,
          control: 'unique-col-collection', uniqueCol: ['provider']
        }],
        validate: function validate() {
          var err = {},
              errmsg,
              seclabels = this.get('seclabels');

          if (_.isUndefined(this.get('name')) || String(this.get('name')).replace(/^\s+|\s+$/g, '') == '') {
            err['name'] = gettext('Name cannot be empty.');
            errmsg = errmsg || err['name'];
          }

          if (_.isUndefined(this.get('basensp')) || String(this.get('basensp')).replace(/^\s+|\s+$/g, '') == '') {
            err['basensp'] = gettext('Schema cannot be empty.');
            errmsg = errmsg || err['basensp'];
          }

          if (_.isUndefined(this.get('ftsrvname')) || String(this.get('ftsrvname')).replace(/^\s+|\s+$/g, '') == '') {
            err['ftsrvname'] = gettext('Foreign server cannot be empty.');
            errmsg = errmsg || err['ftsrvname'];
          }

          this.errorModel.clear().set(err);

          return null;
        }
      }),
      canCreate: function canCreate(itemData, item, data) {
        //If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        // To iterate over tree to check parent node
        while (i) {
          // If it is schema then allow user to create foreign table
          if (_.indexOf(['schema'], d._type) > -1) return true;

          if ('coll-foreign-table' == d._type) {
            //Check if we are not child of catalog
            var prev_i = t.hasParent(i) ? t.parent(i) : null,
                prev_d = prev_i ? t.itemData(prev_i) : null;
            if (prev_d._type == 'catalog') {
              return false;
            } else {
              return true;
            }
          }
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // by default we do not want to allow create menu
        return true;
      }
    });
  }

  return pgBrowser.Nodes['foreign_table'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13), __webpack_require__(10)))

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backgrid, Backbone) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  // Model for tokens control
  var TokenModel = pgAdmin.Browser.Node.Model.extend({
    defaults: {
      token: undefined,
      dictname: undefined
    },
    keys: ['token'],
    // Define the schema for the token/dictionary list
    schema: [{
      id: 'token', label: 'Token', type: 'text', group: null,
      cellHeaderClasses: 'width_percent_50',
      editable: false, cell: 'string', url: 'tokens'
    }, {
      id: 'dictname', label: 'Dictionaries', type: 'text', group: null,
      cellHeaderClasses: 'width_percent_50', editable: true,
      cell: Backgrid.Extension.MultiSelectAjaxCell, url: 'dictionaries'
    }],
    // Validation for token and dictionary list
    validate: function validate() {
      // Clear any existing errors.
      var msg;
      this.errorModel.clear();
      var token = this.get('token');
      var dictionary = this.get('dictname');

      if (_.isNull(token) || _.isUndefined(token) || String(token).replace(/^\s+|\s+$/g, '') == '') {
        msg = gettext('Token cannot be empty!');
        this.errorModel.set('token', msg);
        return msg;
      }

      if (_.isNull(dictionary) || _.isUndefined(dictionary) || String(dictionary).replace(/^\s+|\s+$/g, '') == '') {
        msg = gettext('Dictionary name cannot be empty!');
        this.errorModel.set('dictname', msg);
        return msg;
      }
      return null;
    }
  });

  // Customized control for token control
  var TokenControl = Backform.TokenControl = Backform.UniqueColCollectionControl.extend({

    initialize: function initialize(opts) {
      Backform.UniqueColCollectionControl.prototype.initialize.apply(this, arguments);

      var that;
      var self = that = this,
          node = 'fts_configuration',
          headerSchema = [{
        id: 'token', label: '', type: 'text', url: 'tokens',
        node: 'fts_configuration', canAdd: true, 'url_with_id': true,

        // Defining control for tokens dropdown control in header
        control: Backform.NodeAjaxOptionsControl.extend({
          formatter: Backform.NodeAjaxOptionsControl.prototype.formatter,
          initialize: function initialize() {
            Backform.NodeAjaxOptionsControl.prototype.initialize.apply(this, arguments);
            var self = this,
                url = self.field.get('url') || self.defaults.url,
                m = self.model.top || self.model;

            /* Fetch the tokens/dict list from 'that' node.
             * Here 'that' refers to unique collection control where
             * 'self' refers to nodeAjaxOptions control for dictionary
             */
            var cfgid = that.model.get('oid');
            if (url) {
              var node = this.field.get('schema_node'),
                  node_info = this.field.get('node_info'),
                  full_url = node.generate_url.apply(node, [null, url, this.field.get('node_data'), this.field.get('url_with_id') || false, node_info]),
                  cache_level = this.field.get('cache_level') || node.type,
                  cache_node = this.field.get('cache_node');

              cache_node = cache_node && pgAdmin.Browser.Nodes['cache_node'] || node;

              /*
               * We needs to check, if we have already cached data
               * for this url. If yes - use it, and do not bother about
               * fetching it again.
               */
              var data = cache_node.cache(url, node_info, cache_level);

              // Fetch token/dictionary list
              if (this.field.get('version_compatible') && (_.isUndefined(data) || _.isNull(data))) {
                m.trigger('pgadmin:view:fetching', m, self.field);
                $.ajax({
                  async: false,
                  url: full_url,
                  success: function success(res) {
                    /*
                     * We will cache this data for short period of time for
                     * avoiding same calls.
                     */
                    data = cache_node.cache(url, node_info, cache_level, res.data);
                  },
                  error: function error() {
                    m.trigger('pgadmin:view:fetch:error', m, self.field);
                  }
                });
                m.trigger('pgadmin:view:fetched', m, self.field);
              }

              // It is feasible that the data may not have been fetched.
              data = data && data.data || [];

              /*
               * Transform the data
               */
              var transform = this.field.get('transform') || self.defaults.transform;
              if (transform && _.isFunction(transform)) {
                self.field.set('options', transform.bind(self, data));
              } else {
                self.field.set('options', data);
              }
            }
          }
        }),
        // Select2 control for adding new tokens
        select2: {
          allowClear: true, width: 'style',
          placeholder: gettext('Select token')
        },
        first_empty: true,
        disabled: function disabled(m) {
          return _.isUndefined(self.model.get('oid'));
        }
      }],
          headerDefaults = { token: null },

      // Grid columns backgrid
      gridCols = ['token', 'dictname'];

      // Creating model for header control which is used to add new tokens
      self.headerData = new (Backbone.Model.extend({
        defaults: headerDefaults,
        schema: headerSchema
      }))({});

      // Creating view from header schema in tokens control
      var headerGroups = Backform.generateViewSchema(self.field.get('node_info'), self.headerData, 'create', self.field.get('schema_node'), self.field.get('node_data')),
          fields = [];

      _.each(headerGroups, function (o) {
        fields = fields.concat(o.fields);
      });
      self.headerFields = new Backform.Fields(fields);

      // creating grid using grid columns
      self.gridSchema = Backform.generateGridColumnsFromModel(self.field.get('node_info'), self.field.get('model'), 'edit', gridCols, self.field.get('schema_node'));

      // Providing behaviour control functions to header and grid control
      self.controls = [];
      self.listenTo(self.headerData, "change", self.headerDataChanged);
      self.listenTo(self.headerData, "select2", self.headerDataChanged);
      self.listenTo(self.collection, "add", self.onAddorRemoveTokens);
      self.listenTo(self.collection, "remove", self.onAddorRemoveTokens);
    },

    // Template for creating header view
    generateHeader: function generateHeader(data) {
      var header = ['<div class="subnode-header-form">', ' <div class="container-fluid">', '  <div class="row">', '   <div class="col-xs-3">', '    <label class="control-label"><%-token_label%></label>', '   </div>', '   <div class="col-xs-6" header="token"></div>', '   <div class="col-xs-2">', '     <button class="btn-sm btn-default add fa fa-plus" <%=canAdd ? "" : "disabled=\'disabled\'"%> ></button>', '   </div>', '  </div>', ' </div>', '</div>'].join("\n");

      _.extend(data, {
        token_label: gettext('Tokens')
      });

      var self = this,
          headerTmpl = _.template(header),
          $header = $(headerTmpl(data)),
          controls = this.controls;

      self.headerFields.each(function (field) {
        var control = new (field.get("control"))({
          field: field,
          model: self.headerData
        });

        $header.find('div[header="' + field.get('name') + '"]').append(control.render().$el);

        control.$el.find('.control-label').remove();
        controls.push(control);
      });

      // We should not show add button in properties mode
      if (data.mode == 'properties') {
        $header.find("button.add").remove();
      }

      // Disable add button in token control in create mode
      if (data.mode == 'create') {
        $header.find("button.add").attr('disabled', true);
      }

      self.$header = $header;
      return $header;
    },

    // Providing event handler for add button in header
    events: _.extend({}, Backform.UniqueColCollectionControl.prototype.events, { 'click button.add': 'addTokens' }),

    // Show token/dictionary grid
    showGridControl: function showGridControl(data) {

      var self = this,
          titleTmpl = _.template("<div class='subnode-header'></div>"),
          $gridBody = $("<div></div>", {
        class: 'pgadmin-control-group backgrid form-group col-xs-12 object subnode'
      }).append(titleTmpl({ label: data.label }));

      $gridBody.append(self.generateHeader(data));

      var gridColumns = _.clone(this.gridSchema.columns);

      // Insert Delete Cell into Grid
      if (data.disabled == false && data.canDelete) {
        gridColumns.unshift({
          name: "pg-backform-delete", label: "",
          cell: Backgrid.Extension.DeleteCell,
          editable: false, cell_priority: -1
        });
      }

      if (self.grid) {
        self.grid.remove();
        self.grid.null;
      }
      // Initialize a new Grid instance
      var grid = self.grid = new Backgrid.Grid({
        columns: gridColumns,
        collection: self.collection,
        className: "backgrid table-bordered"
      });
      self.$grid = grid.render().$el;

      $gridBody.append(self.$grid);

      // Find selected dictionaries in grid and show it all together
      setTimeout(function () {
        self.headerData.set({
          'token': self.$header.find('div[header="token"] select').val()
        }, { silent: true });
      }, 10);

      // Render node grid
      return $gridBody;
    },

    // When user change the header control to add a new token
    headerDataChanged: function headerDataChanged() {
      var self = this,
          val,
          data = this.headerData.toJSON(),
          inSelected = _.isEmpty(data) || _.isUndefined(data),
          checkVars = ['token'];

      if (!self.$header) {
        return;
      }

      self.$header.find('button.add').prop('disabled', inSelected);
    },

    // Get called when user click on add button header
    addTokens: function addTokens(ev) {
      ev.preventDefault();
      var self = this,
          token = self.headerData.get('token');

      if (!token || token == '') {
        return false;
      }

      var coll = self.model.get(self.field.get('name')),
          m = new (self.field.get('model'))(self.headerData.toJSON(), {
        silent: true, top: self.model.top,
        collection: coll, handler: coll
      }),
          checkVars = ['token'],
          idx = -1;

      // Find if token exists in grid
      self.collection.each(function (m) {
        _.each(checkVars, function (v) {
          var val = m.get(v);
          if (val == token) {
            idx = coll.indexOf(m);
          }
        });
      });

      // remove 'm' if duplicate value found.
      if (idx == -1) {
        coll.add(m);
        idx = coll.indexOf(m);
      }
      self.$grid.find('.new').removeClass('new');
      var newRow = self.grid.body.rows[idx].$el;
      newRow.addClass("new");
      //$(newRow).pgMakeVisible('table-bordered');
      $(newRow).pgMakeVisible('backform-tab');

      return false;
    },

    // When user delete token/dictionary entry from grid
    onAddorRemoveTokens: function onAddorRemoveTokens() {
      var self = this;

      /*
       * Wait for collection to be updated before checking for the button to
       * be enabled, or not.
       */
      setTimeout(function () {
        self.collection.trigger('pgadmin:tokens:updated', self.collection);
        self.headerDataChanged();
      }, 10);
    },

    // When control is about to destroy
    remove: function remove() {
      /*
       * Stop listening the events registered by this control.
       */
      this.stopListening(this.headerData, "change", this.headerDataChanged);
      this.listenTo(this.headerData, "select2", this.headerDataChanged);
      this.listenTo(this.collection, "remove", this.onAddorRemoveTokens);

      // Remove header controls.
      _.each(this.controls, function (control) {
        control.remove();
      });
      TokenControl.__super__.remove.apply(this, arguments);

      // Remove the header model
      delete this.headerData;
    }
  });

  // Extend the collection class for FTS Configuration
  if (!pgBrowser.Nodes['coll-fts_configuration']) {
    var fts_configurations = pgAdmin.Browser.Nodes['coll-fts_configuration'] = pgAdmin.Browser.Collection.extend({
      node: 'fts_configuration',
      label: gettext('FTS Configurations'),
      type: 'coll-fts_configuration',
      columns: ['name', 'description']
    });
  };

  // Extend the node class for FTS Configuration
  if (!pgBrowser.Nodes['fts_configuration']) {
    pgAdmin.Browser.Nodes['fts_configuration'] = pgAdmin.Browser.Node.extend({
      parent_type: ['schema', 'catalog'],
      type: 'fts_configuration',
      sqlAlterHelp: 'sql-altertsconfig.html',
      sqlCreateHelp: 'sql-createtsconfig.html',
      dialogHelp: url_for('help.static', { 'filename': 'fts_configuration_dialog.html' }),
      canDrop: true,
      canDropCascade: true,
      label: gettext('FTS Configuration'),
      hasSQL: true,
      hasDepends: true,
      Init: function Init() {

        // Avoid multiple registration of menus
        if (this.initialized) return;

        this.initialized = true;

        // Add context menus for FTS Configuration
        pgBrowser.add_menus([{
          name: 'create_fts_configuration_on_schema', node: 'schema',
          module: this, category: 'create', priority: 4,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          label: gettext('FTS Configuration...'),
          icon: 'wcTabIcon icon-fts_configuration', data: { action: 'create' },
          enable: 'canCreate'
        }, {
          name: 'create_fts_configuration_on_coll', module: this, priority: 4,
          node: 'coll-fts_configuration', applies: ['object', 'context'],
          callback: 'show_obj_properties', category: 'create',
          label: gettext('FTS Configuration...'), data: { action: 'create' },
          icon: 'wcTabIcon icon-fts_configuration', enable: 'canCreate'
        }, {
          name: 'create_fts_configuration', node: 'fts_configuration',
          module: this, applies: ['object', 'context'],
          callback: 'show_obj_properties', category: 'create', priority: 4,
          label: gettext('FTS Configuration...'), data: { action: 'create' },
          icon: 'wcTabIcon icon-fts_configuration', enable: 'canCreate'
        }]);
      },

      // Defining model for FTS Configuration node
      model: pgAdmin.Browser.Node.Model.extend({
        defaults: {
          name: undefined, // FTS Configuration name
          owner: undefined, // FTS Configuration owner
          description: undefined, // Comment on FTS Configuration
          schema: undefined, // Schema name FTS Configuration belongs to
          prsname: undefined, // FTS parser list for FTS Configuration node
          copy_config: undefined, // FTS configuration list to copy from
          tokens: undefined // token/dictionary pair list for node
        },
        initialize: function initialize(attrs, opts) {
          var isNew = _.size(attrs) === 0;
          pgAdmin.Browser.Node.Model.prototype.initialize.apply(this, arguments);

          if (isNew) {
            var user = pgBrowser.serverInfo[opts.node_info.server._id].user;
            this.set({
              'owner': user.name,
              'schema': opts.node_info.schema._id
            }, { silent: true });
          }
        },
        // Defining schema for FTS Configuration
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', cellHeaderClasses: 'width_percent_50'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          editable: false, type: 'text', disabled: true, mode: ['properties']
        }, {
          id: 'owner', label: gettext('Owner'), cell: 'string',
          type: 'text', mode: ['properties', 'edit', 'create'], node: 'role',
          control: Backform.NodeListByNameControl, select2: { allowClear: false }
        }, {
          id: 'schema', label: gettext('Schema'), cell: 'string',
          type: 'text', mode: ['create', 'edit'], node: 'schema',
          control: 'node-list-by-id', cache_node: 'database',
          cache_level: 'database'
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline', cellHeaderClasses: 'width_percent_50'
        }, {
          id: 'prsname', label: gettext('Parser'), type: 'text',
          url: 'parsers', first_empty: true,
          group: gettext('Definition'), control: 'node-ajax-options',
          deps: ['copy_config'],
          //disable parser when user select copy_config manually and vica-versa
          disabled: function disabled(m) {
            var copy_config = m.get('copy_config');
            return m.isNew() && (_.isNull(copy_config) || _.isUndefined(copy_config) || copy_config === '') ? false : true;
          }
        }, {
          id: 'copy_config', label: gettext('Copy Config'), type: 'text',
          mode: ['create'], group: gettext('Definition'),
          control: 'node-ajax-options', url: 'copyConfig', deps: ['prsname'],

          //disable copy_config when user select parser manually and vica-versa
          disabled: function disabled(m) {
            var parser = m.get('prsname');
            return m.isNew() && (_.isNull(parser) || _.isUndefined(parser) || parser === '') ? false : true;
          }
        }, {
          id: 'tokens', label: gettext('Tokens'), type: 'collection',
          group: gettext('Tokens'), control: TokenControl,
          model: TokenModel, columns: ['token', 'dictionary'],
          uniqueCol: ['token'], mode: ['create', 'edit'],
          canAdd: true, canEdit: false, canDelete: true
        }],

        /*
         * Triggers control specific error messages for name,
         * copy_config/parser and schema, if any one of them is not specified
         * while creating new fts configuration
         */
        validate: function validate(keys) {
          var msg;
          var name = this.get('name');
          var parser = this.get('prsname');
          var copy_config_or_parser = !(parser === '' || _.isUndefined(parser) || _.isNull(parser)) ? this.get('prsname') : this.get('copy_config');
          var schema = this.get('schema');

          // Clear the existing error model
          this.errorModel.clear();
          this.trigger('on-status-clear');

          // Validate the name
          if (_.isUndefined(name) || _.isNull(name) || String(name).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Name must be specified!');
            this.errorModel.set('name', msg);
            return msg;
          }

          // Validate parser or copy_config
          else if (_.isUndefined(copy_config_or_parser) || _.isNull(copy_config_or_parser) || String(copy_config_or_parser).replace(/^\s+|\s+$/g, '') == '') {
              msg = gettext('Select parser or configuration to copy!');
              this.errorModel.set('parser', msg);
              return msg;
            }

            // Validate schema
            else if (_.isUndefined(schema) || _.isNull(schema) || String(schema).replace(/^\s+|\s+$/g, '') == '') {
                msg = gettext('Schema must be selected!');
                this.errorModel.set('schema', msg);
                return msg;
              }

          return null;
        }
      }),
      canCreate: function canCreate(itemData, item, data) {
        //If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        // To iterate over tree to check parent node
        while (i) {
          // If it is schema then allow user to create fts configuration
          if (_.indexOf(['schema'], d._type) > -1) return true;

          if ('coll-fts_configuration' == d._type) {
            //Check if we are not child of catalog
            var prev_i = t.hasParent(i) ? t.parent(i) : null,
                prev_d = prev_i ? t.itemData(prev_i) : null;
            if (prev_d._type == 'catalog') {
              return false;
            } else {
              return true;
            }
          }
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // by default we do not want to allow create menu
        return true;
      }
    });
  }

  return pgBrowser.Nodes['coll-fts_configuration'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13), __webpack_require__(10)))

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  // Extend the browser's node model class to create a option/value pair
  var OptionLabelModel = pgAdmin.Browser.Node.Model.extend({
    defaults: {
      options: undefined,
      value: undefined
    },
    // Define the schema for the Options
    schema: [{
      id: 'option', label: gettext('Option'), type: 'text', group: null,
      cellHeaderClasses: 'width_percent_50', editable: true
    }, {
      id: 'value', label: gettext('Value'), type: 'text', group: null,
      cellHeaderClasses: 'width_percent_50', editable: true
    }],
    validate: function validate() {
      // Clear any existing errors.
      this.errorModel.clear();

      if (_.isUndefined(this.get('option')) || String(this.get('option')).replace(/^\s+|\s+$/g, '') == '') {
        var msg = gettext('Option cannot be empty!');
        this.errorModel.set('option', msg);
        return msg;
      }
      if (_.isUndefined(this.get('value')) || String(this.get('value')).replace(/^\s+|\s+$/g, '') == '') {
        var msg = gettext('Value cannot be empty!');
        this.errorModel.set('value', msg);
        return msg;
      }
      return null;
    }
  });

  // Extend the collection class for FTS Dictionary
  if (!pgBrowser.Nodes['coll-fts_dictionary']) {
    var fts_dictionaries = pgAdmin.Browser.Nodes['coll-fts_dictionary'] = pgAdmin.Browser.Collection.extend({
      node: 'fts_dictionary',
      label: gettext('FTS Dictionaries'),
      type: 'coll-fts_dictionary',
      columns: ['name', 'description']
    });
  };

  // Extend the node class for FTS Dictionary
  if (!pgBrowser.Nodes['fts_dictionary']) {
    pgAdmin.Browser.Nodes['fts_dictionary'] = pgAdmin.Browser.Node.extend({
      parent_type: ['schema', 'catalog'],
      type: 'fts_dictionary',
      sqlAlterHelp: 'sql-altertsdictionary.html',
      sqlCreateHelp: 'sql-createtsdictionary.html',
      dialogHelp: url_for('help.static', { 'filename': 'fts_dictionary_dialog.html' }),
      canDrop: true,
      canDropCascade: true,
      label: gettext('FTS Dictionary'),
      hasSQL: true,
      hasDepends: true,
      Init: function Init() {

        // Avoid multiple registration of menus
        if (this.initialized) return;

        this.initialized = true;

        // Add context menus for FTS Dictionary
        pgBrowser.add_menus([{
          name: 'create_fts_dictionary_on_schema', node: 'schema', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('FTS Dictionary...'),
          icon: 'wcTabIcon icon-fts_dictionary', data: { action: 'create' },
          enable: 'canCreate'
        }, {
          name: 'create_fts_dictionary_on_coll', node: 'coll-fts_dictionary',
          module: this, applies: ['object', 'context'], priority: 4,
          callback: 'show_obj_properties', category: 'create',
          label: gettext('FTS Dictionary...'), data: { action: 'create' },
          icon: 'wcTabIcon icon-fts_dictionary', enable: 'canCreate'
        }, {
          name: 'create_fts_dictionary', node: 'fts_dictionary', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('FTS Dictionary...'),
          icon: 'wcTabIcon icon-fts_dictionary', data: { action: 'create' },
          enable: 'canCreate'
        }]);
      },

      // Defining backform model for FTS Dictionary node
      model: pgAdmin.Browser.Node.Model.extend({
        defaults: {
          name: undefined, // FTS Dictionary name
          owner: undefined, // FTS Dictionary owner
          description: undefined, // Comment on FTS Dictionary
          schema: undefined, // Schema name FTS dictionary belongs to
          template: undefined, // Template list for FTS dictionary node
          options: undefined // option/value pair list for FTS Dictionary
        },
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;
          pgAdmin.Browser.Node.Model.prototype.initialize.apply(this, arguments);

          if (isNew) {
            var user = pgBrowser.serverInfo[args.node_info.server._id].user;
            this.set({
              'owner': user.name,
              'schema': args.node_info.schema._id
            }, { silent: true });
          }
        },
        // Defining schema for fts dictionary
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', cellHeaderClasses: 'width_percent_50'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          editable: false, type: 'text', disabled: true, mode: ['properties']
        }, {
          id: 'owner', label: gettext('Owner'), cell: 'string',
          type: 'text', mode: ['properties', 'edit', 'create'], node: 'role',
          control: Backform.NodeListByNameControl
        }, {
          id: 'schema', label: gettext('Schema'), cell: 'string',
          type: 'text', mode: ['create', 'edit'], node: 'schema',
          cache_node: 'database', control: 'node-list-by-id'
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline', cellHeaderClasses: 'width_percent_50'
        }, {
          id: 'template', label: gettext('Template'), type: 'text',
          disabled: function disabled(m) {
            return !m.isNew();
          }, url: 'fetch_templates',
          group: gettext('Definition'), control: 'node-ajax-options',
          cache_node: 'fts_template'
        }, {
          id: 'options', label: gettext('Option'), type: 'collection',
          group: gettext('Options'), control: 'unique-col-collection',
          model: OptionLabelModel, columns: ['option', 'value'],
          uniqueCol: ['option'], mode: ['edit', 'create'],
          canAdd: true, canEdit: false, canDelete: true
        }],

        /*
         * Triggers control specific error messages for dictionary name,
         * template and schema, if any one of them is not specified
         * while creating new fts dictionary
         */
        validate: function validate(keys) {
          var name = this.get('name');
          var template = this.get('template');;
          var schema = this.get('schema');

          // Validate FTS Dictionary name
          if (_.isUndefined(name) || _.isNull(name) || String(name).replace(/^\s+|\s+$/g, '') == '') {
            var msg = gettext('Name must be specified!');
            this.errorModel.set('name', msg);
            return msg;
          }

          // Validate template name
          else if (_.isUndefined(template) || _.isNull(template) || String(template).replace(/^\s+|\s+$/g, '') == '') {
              var msg = gettext('Template must be selected!');
              this.errorModel.set('template', msg);
              return msg;
            }

            // Validate schema
            else if (_.isUndefined(schema) || _.isNull(schema) || String(schema).replace(/^\s+|\s+$/g, '') == '') {
                var msg = gettext('Schema must be selected!');
                this.errorModel.set('schema', msg);
                return msg;
              } else this.errorModel.clear();

          this.trigger('on-status-clear');
          return null;
        }
      }),
      canCreate: function canCreate(itemData, item, data) {
        //If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        // To iterate over tree to check parent node
        while (i) {
          // If it is schema then allow user to create fts dictionary
          if (_.indexOf(['schema'], d._type) > -1) return true;

          if ('coll-fts_dictionary' == d._type) {
            //Check if we are not child of catalog
            var prev_i = t.hasParent(i) ? t.parent(i) : null,
                prev_d = prev_i ? t.itemData(prev_i) : null;
            if (prev_d._type == 'catalog') {
              return false;
            } else {
              return true;
            }
          }
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // by default we do not want to allow create menu
        return true;
      }
    });
  }

  return pgBrowser.Nodes['fts_dictionary'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  // Extend the collection class for fts parser
  if (!pgBrowser.Nodes['coll-fts_parser']) {
    var fts_parsers = pgAdmin.Browser.Nodes['coll-fts_parser'] = pgAdmin.Browser.Collection.extend({
      node: 'fts_parser',
      label: gettext('FTS Parsers'),
      type: 'coll-fts_parser',
      columns: ['name', 'description']
    });
  };

  // Extend the node class for fts parser
  if (!pgBrowser.Nodes['fts_parser']) {
    pgAdmin.Browser.Nodes['fts_parser'] = pgAdmin.Browser.Node.extend({
      parent_type: ['schema', 'catalog'],
      type: 'fts_parser',
      sqlAlterHelp: 'sql-altertsparser.html',
      sqlCreateHelp: 'sql-createtsparser.html',
      dialogHelp: url_for('help.static', { 'filename': 'fts_parser_dialog.html' }),
      canDrop: true,
      canDropCascade: true,
      label: gettext('FTS Parser'),
      hasSQL: true,
      hasDepends: true,
      Init: function Init() {

        // Avoid multiple registration of menus
        if (this.initialized) return;

        this.initialized = true;

        // Add context menus for fts parser
        pgBrowser.add_menus([{
          name: 'create_fts_parser_on_schema', node: 'schema', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('FTS Parser...'),
          icon: 'wcTabIcon icon-fts_parser', data: { action: 'create' },
          enable: 'canCreate'
        }, {
          name: 'create_fts_parser_on_coll', node: 'coll-fts_parser',
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('FTS Parser...'),
          icon: 'wcTabIcon icon-fts_parser', data: { action: 'create' },
          module: this, enable: 'canCreate'
        }, {
          name: 'create_fts_parser', node: 'fts_parser', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('FTS Parser...'),
          icon: 'wcTabIcon icon-fts_parser', data: { action: 'create' },
          enable: 'canCreate'
        }]);
      },

      // Defining backform model for fts parser node
      model: pgAdmin.Browser.Node.Model.extend({
        defaults: {
          name: undefined, // Fts parser name
          description: undefined, // Comment on parser
          schema: undefined, // Schema name to which parser belongs
          prsstart: undefined, // Start function for fts parser
          prstoken: undefined, // Token function for fts parser
          prsend: undefined, // End function for fts parser
          prslextype: undefined, // Lextype function for fts parser
          prsheadline: undefined // Headline function for fts parse
        },
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;
          pgAdmin.Browser.Node.Model.prototype.initialize.apply(this, arguments);
          if (isNew) {
            this.set('schema', args.node_info.schema._id);
          }
        },
        // Defining schema for fts parser
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', cellHeaderClasses: 'width_percent_50'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          editable: false, type: 'text', disabled: true, mode: ['properties']
        }, {
          id: 'schema', label: gettext('Schema'), cell: 'string',
          type: 'text', mode: ['create', 'edit'], node: 'schema',
          control: 'node-list-by-id', cache_node: 'database',
          cache_level: 'database'
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline', cellHeaderClasses: 'width_percent_50'
        }, {
          id: 'prsstart', label: gettext('Start function'),
          type: 'text', disabled: function disabled(m) {
            return !m.isNew();
          },
          control: 'node-ajax-options', url: 'start_functions',
          group: gettext('Definition'), cache_level: 'database',
          cache_node: 'schema'
        }, {
          id: 'prstoken', label: gettext('Get next token function'),
          type: 'text', disabled: function disabled(m) {
            return !m.isNew();
          },
          control: 'node-ajax-options', url: 'token_functions',
          group: gettext('Definition'), cache_level: 'database',
          cache_node: 'schema'
        }, {
          id: 'prsend', label: gettext('End function'),
          type: 'text', disabled: function disabled(m) {
            return !m.isNew();
          },
          control: 'node-ajax-options', url: 'end_functions',
          group: gettext('Definition'), cache_level: 'database',
          cache_node: 'schema'
        }, {
          id: 'prslextype', label: gettext('Lextypes function'),
          type: 'text', disabled: function disabled(m) {
            return !m.isNew();
          },
          control: 'node-ajax-options', url: 'lextype_functions',
          group: gettext('Definition'), cache_level: 'database',
          cache_node: 'schema'
        }, {
          id: 'prsheadline', label: gettext('Headline function'),
          type: 'text', disabled: function disabled(m) {
            return !m.isNew();
          },
          control: 'node-ajax-options', url: 'headline_functions',
          group: gettext('Definition'), cache_level: 'database',
          cache_node: 'schema'
        }],

        /*
         * Triggers control specific error messages for parser name,
         * start, token, end, lextype functions and schema, if any one of them is not specified
         * while creating new fts parser
         */
        validate: function validate(keys) {
          var name = this.get('name');
          var start = this.get('prsstart');
          var token = this.get('prstoken');
          var end = this.get('prsend');
          var lextype = this.get('prslextype');
          var schema = this.get('schema');

          // Validate fts parser name
          if (_.isUndefined(name) || _.isNull(name) || String(name).replace(/^\s+|\s+$/g, '') == '') {
            var msg = gettext('Name must be specified.');
            this.errorModel.set('name', msg);
            return msg;
          }

          // Validate start function control
          else if (_.isUndefined(start) || _.isNull(start) || String(start).replace(/^\s+|\s+$/g, '') == '') {
              var msg = gettext('Start function must be selected.');
              this.errorModel.set('prsstart', msg);
              return msg;
            }

            // Validate gettoken function control
            else if (_.isUndefined(token) || _.isNull(token) || String(token).replace(/^\s+|\s+$/g, '') == '') {
                var msg = gettext('Get next token function must be selected.');
                this.errorModel.set('prstoken', msg);
                return msg;
              }

              // Validate end function control
              else if (_.isUndefined(end) || _.isNull(end) || String(end).replace(/^\s+|\s+$/g, '') == '') {
                  var msg = gettext('End function must be selected.');
                  this.errorModel.set('prsend', msg);
                  return msg;
                }

                // Validate lextype function control
                else if (_.isUndefined(lextype) || _.isNull(lextype) || String(lextype).replace(/^\s+|\s+$/g, '') == '') {
                    var msg = gettext('Lextype function must be selected.');
                    this.errorModel.set('prslextype', msg);
                    return msg;
                  }

                  // Validate schema for fts parser
                  else if (_.isUndefined(schema) || _.isNull(schema) || String(schema).replace(/^\s+|\s+$/g, '') == '') {
                      var msg = gettext('Schema must be selected.');
                      this.errorModel.set('schema', msg);
                      return msg;
                    } else this.errorModel.clear();

          this.trigger('on-status-clear');
          return null;
        }
      }),
      canCreate: function canCreate(itemData, item, data) {
        //If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        // To iterate over tree to check parent node
        while (i) {
          // If it is schema then allow user to create fts parser
          if (_.indexOf(['schema'], d._type) > -1) return true;

          if ('coll-fts_parser' == d._type) {
            //Check if we are not child of catalog
            var prev_i = t.hasParent(i) ? t.parent(i) : null,
                prev_d = prev_i ? t.itemData(prev_i) : null;
            if (prev_d._type == 'catalog') {
              return false;
            } else {
              return true;
            }
          }
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // by default we do not want to allow create menu
        return true;
      }
    });
  }

  return pgBrowser.Nodes['coll-fts_parser'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  // Extend the collection class for fts template
  if (!pgBrowser.Nodes['coll-fts_template']) {
    var fts_templates = pgAdmin.Browser.Nodes['coll-fts_template'] = pgAdmin.Browser.Collection.extend({
      node: 'fts_template',
      label: gettext('FTS Templates'),
      type: 'coll-fts_template',
      columns: ['name', 'description']
    });
  };

  // Extend the node class for fts template
  if (!pgBrowser.Nodes['fts_template']) {
    pgAdmin.Browser.Nodes['fts_template'] = pgAdmin.Browser.Node.extend({
      parent_type: ['schema', 'catalog'],
      type: 'fts_template',
      sqlAlterHelp: 'sql-altertstemplate.html',
      sqlCreateHelp: 'sql-createtstemplate.html',
      dialogHelp: url_for('help.static', { 'filename': 'fts_template_dialog.html' }),
      canDrop: true,
      canDropCascade: true,
      label: gettext('FTS Template'),
      hasSQL: true,
      hasDepends: true,
      Init: function Init() {

        // Avoid multiple registration of menus
        if (this.initialized) return;

        this.initialized = true;

        // Add context menus for fts template
        pgBrowser.add_menus([{
          name: 'create_fts_template_on_schema', node: 'schema', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('FTS Template...'),
          icon: 'wcTabIcon icon-fts_template', data: { action: 'create' },
          enable: 'canCreate'
        }, {
          name: 'create_fts_template_on_coll', node: 'coll-fts_template', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('FTS Template...'),
          icon: 'wcTabIcon icon-fts_template', data: { action: 'create' },
          enable: 'canCreate'
        }, {
          name: 'create_fts_template', node: 'fts_template', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('FTS Template...'),
          icon: 'wcTabIcon icon-fts_template', data: { action: 'create' },
          enable: 'canCreate'
        }]);
      },

      // Defining backform model for fts template node
      model: pgAdmin.Browser.Node.Model.extend({
        defaults: {
          name: undefined, // Fts template name
          description: undefined, // Comment on template
          schema: undefined, // Schema name to which template belongs
          tmplinit: undefined, // Init function for fts template
          tmpllexize: undefined // Lexize function for fts template
        },
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;
          pgAdmin.Browser.Node.Model.prototype.initialize.apply(this, arguments);
          if (isNew) {
            this.set('schema', args.node_info.schema._id);
          }
        },
        // Defining schema for fts template
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', cellHeaderClasses: 'width_percent_50'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          editable: false, type: 'text', disabled: true, mode: ['properties']
        }, {
          id: 'schema', label: gettext('Schema'), cell: 'string',
          type: 'text', mode: ['create', 'edit'], node: 'schema',
          control: 'node-list-by-id', cache_node: 'database',
          cache_level: 'database'
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline', cellHeaderClasses: 'width_percent_50'
        }, {
          id: 'tmplinit', label: gettext('Init function'),
          group: gettext('Definition'), type: 'text', disabled: function disabled(m) {
            return !m.isNew();
          }, control: 'node-ajax-options', url: 'get_init',
          cache_level: 'database', cache_node: 'schema'
        }, {
          id: 'tmpllexize', label: gettext('Lexize function'), group: gettext('Definition'),
          type: 'text', disabled: function disabled(m) {
            return !m.isNew();
          },
          control: 'node-ajax-options', url: 'get_lexize', cache_level: 'database',
          cache_node: 'schema'
        }],

        /*
         * Triggers control specific error messages for template name,
         * lexize function and schema, if any one of them is not specified
         * while creating new fts template
         */
        validate: function validate(keys) {
          var name = this.get('name');
          var lexize = this.get('tmpllexize');
          var schema = this.get('schema');

          // Validate fts template name
          if (_.isUndefined(name) || _.isNull(name) || String(name).replace(/^\s+|\s+$/g, '') == '') {
            var msg = gettext('Name must be specified.');
            this.errorModel.set('name', msg);
            return msg;
          }

          // Validate lexize function control
          else if (_.isUndefined(lexize) || _.isNull(lexize) || String(lexize).replace(/^\s+|\s+$/g, '') == '') {
              var msg = gettext('Lexize function must be selected.');
              this.errorModel.set('tmpllexize', msg);
              return msg;
            }

            // Validate schema for fts template
            else if (_.isUndefined(schema) || _.isNull(schema) || String(schema).replace(/^\s+|\s+$/g, '') == '') {
                var msg = gettext('Schema must be selected.');
                this.errorModel.set('schema', msg);
                return msg;
              } else this.errorModel.clear();

          this.trigger('on-status-clear');
          return null;
        }
      }),
      canCreate: function canCreate(itemData, item, data) {
        //If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        // To iterate over tree to check parent node
        while (i) {
          // If it is schema then allow user to create fts fts_template
          if (_.indexOf(['schema'], d._type) > -1) return true;

          if ('coll-fts_template' == d._type) {
            //Check if we are not child of catalog
            var prev_i = t.hasParent(i) ? t.parent(i) : null,
                prev_d = prev_i ? t.itemData(prev_i) : null;
            if (prev_d._type == 'catalog') {
              return false;
            } else {
              return true;
            }
          }
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // by default we do not want to allow create menu
        return true;
      }
    });
  }

  return pgBrowser.Nodes['fts_template'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/* Create and Register Procedure Collection and Node. */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(196), __webpack_require__(9), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify, Function) {

  if (!pgBrowser.Nodes['coll-procedure']) {
    var procedures = pgAdmin.Browser.Nodes['coll-procedure'] = pgAdmin.Browser.Collection.extend({
      node: 'procedure',
      label: gettext('Procedures'),
      type: 'coll-procedure',
      columns: ['name', 'funcowner', 'description'],
      hasStatistics: true
    });
  };

  var pgSchemaNode = pgBrowser.Nodes['schema'];

  // Inherit Functions Node
  if (!pgBrowser.Nodes['procedure']) {
    pgAdmin.Browser.Nodes['procedure'] = pgBrowser.Node.extend({
      type: 'procedure',
      sqlAlterHelp: 'sql-alterprocedure.html',
      sqlCreateHelp: 'sql-createprocedure.html',
      dialogHelp: url_for('help.static', { 'filename': 'procedure_dialog.html' }),
      label: gettext('Procedure'),
      collection_type: 'coll-procedure',
      hasSQL: true,
      hasDepends: true,
      hasStatistics: true,
      hasScriptTypes: ['create', 'exec'],
      parent_type: ['schema', 'catalog'],
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.proc_initialized) return;

        this.proc_initialized = true;

        pgBrowser.add_menus([{
          name: 'create_procedure_on_coll', node: 'coll-procedure', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Procedure...'),
          icon: 'wcTabIcon icon-procedure', data: { action: 'create', check: false }, enable: 'canCreateProc'
        }, {
          name: 'create_procedure', node: 'procedure', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Procedure...'),
          icon: 'wcTabIcon icon-procedure', data: { action: 'create', check: true }, enable: 'canCreateProc'
        }, {
          name: 'create_procedure', node: 'schema', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Procedure...'),
          icon: 'wcTabIcon icon-procedure', data: { action: 'create', check: true }, enable: 'canCreateProc'
        }]);
      },
      canDrop: pgSchemaNode.canChildDrop,
      canDropCascade: false,
      canCreateProc: function canCreateProc(itemData, item, data) {
        var node_hierarchy = this.getTreeNodeHierarchy.apply(this, [item]);

        // Do not provide Create option in catalog
        if ('catalog' in node_hierarchy) return false;

        // Procedures supported only in PPAS
        if ('server' in node_hierarchy && node_hierarchy['server'].server_type == "ppas") return true;

        return false;
      },
      model: Function.model.extend({
        defaults: _.extend({}, Function.model.prototype.defaults, {
          lanname: 'edbspl'
        }),
        canVarAdd: function canVarAdd(m) {
          var server = this.node_info.server;
          if (server.version < 90500) {
            return false;
          } else {
            return true;
          }
        },
        isVisible: function isVisible(m) {
          if (this.name == 'sysfunc') {
            return false;
          } else if (this.name == 'sysproc') {
            return true;
          }
          return false;
        },
        isDisabled: function isDisabled(m) {
          if (this.node_info && 'catalog' in this.node_info) {
            return true;
          }
          name = this.name;
          switch (name) {
            case 'provolatility':
            case 'proisstrict':
            case 'prosecdef':
            case 'procost':
            case 'proleakproof':
            case 'variables':
              var server = this.node_info.server;
              if (server.version < 90500) {
                return true;
              } else {
                return false;
              }
              break;
            case 'prorows':
              var server = this.node_info.server;
              if (server.version >= 90500 && m.get('proretset') == true) {
                return false;
              } else {
                return true;
              }
              break;
            case 'funcowner':
            case 'lanname':
            case 'proargs':
              return true;
            default:
              return false;
              break;
          }
          return false;
        },
        validate: function validate() {
          var err = {},
              errmsg,
              seclabels = this.get('seclabels');

          if (_.isUndefined(this.get('name')) || String(this.get('name')).replace(/^\s+|\s+$/g, '') == '') {
            err['name'] = gettext('Name cannot be empty.');
            errmsg = errmsg || err['name'];
          }

          if (_.isUndefined(this.get('pronamespace')) || String(this.get('pronamespace')).replace(/^\s+|\s+$/g, '') == '') {
            err['pronamespace'] = gettext('Schema cannot be empty.');
            errmsg = errmsg || err['pronamespace'];
          }

          if (_.isUndefined(this.get('lanname')) || String(this.get('lanname')).replace(/^\s+|\s+$/g, '') == '') {
            err['lanname'] = gettext('Language cannot be empty.');
            errmsg = errmsg || err['lanname'];
          }

          if (_.isUndefined(this.get('prosrc')) || String(this.get('prosrc')).replace(/^\s+|\s+$/g, '') == '') {
            err['prosrc'] = gettext('Code cannot be empty.');
            errmsg = errmsg || err['prosrc'];
          }

          if (seclabels) {
            var secLabelsErr;
            for (var i = 0; i < seclabels.models.length && !secLabelsErr; i++) {
              secLabelsErr = seclabels.models[i].validate.apply(seclabels.models[i]);
              if (secLabelsErr) {
                err['seclabels'] = secLabelsErr;
                errmsg = errmsg || secLabelsErr;
              }
            }
          }

          this.errorModel.clear().set(err);

          return null;
        }
      })
    });
  }

  return pgBrowser.Nodes['procedure'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/* Create and Register Procedure Collection and Node. */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(197), __webpack_require__(9), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify, EdbFunction) {

  if (!pgBrowser.Nodes['coll-edbproc']) {
    pgAdmin.Browser.Nodes['coll-edbproc'] = pgAdmin.Browser.Collection.extend({
      node: 'edbproc',
      label: gettext('Procedures'),
      type: 'coll-edbproc',
      columns: ['name', 'funcowner', 'description'],
      hasStatistics: true
    });
  };

  // Inherit Functions Node
  if (!pgBrowser.Nodes['edbproc']) {
    pgAdmin.Browser.Nodes['edbproc'] = pgBrowser.Node.extend({
      type: 'edbproc',
      dialogHelp: url_for('help.static', { 'filename': 'edbproc_dialog.html' }),
      label: gettext('Procedure'),
      collection_type: 'coll-edbproc',
      hasDepends: true,
      canEdit: false,
      hasSQL: true,
      hasScriptTypes: [],
      parent_type: ['package'],
      Init: function Init() {
        /* Avoid multiple registration of menus */
        if (this.proc_initialized) return;

        this.proc_initialized = true;
      },
      canDrop: false,
      canDropCascade: false,
      model: EdbFunction.model.extend({
        defaults: _.extend({}, EdbFunction.model.prototype.defaults, {
          lanname: 'edbspl'
        }),
        isVisible: function isVisible(m) {
          if (this.name == 'sysfunc') {
            return false;
          } else if (this.name == 'sysproc') {
            return true;
          }
          return false;
        },
        validate: function validate() {
          return null;
        }
      })
    });
  }

  return pgBrowser.Nodes['edbproc'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/* Create and Register Function Collection and Node. */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  if (!pgBrowser.Nodes['coll-edbvar']) {
    pgBrowser.Nodes['coll-edbvar'] = pgBrowser.Collection.extend({
      node: 'edbvar',
      label: gettext('Variables'),
      type: 'coll-edbvar',
      columns: ['name', 'funcowner', 'description']
    });
  };

  if (!pgBrowser.Nodes['edbvar']) {
    pgBrowser.Nodes['edbvar'] = pgBrowser.Node.extend({
      type: 'edbvar',
      dialogHelp: url_for('help.static', { 'filename': 'edbvar_dialog.html' }),
      label: gettext('Function'),
      collection_type: 'coll-edbvar',
      canEdit: false,
      hasSQL: true,
      hasScriptTypes: [],
      parent_type: ['package'],
      Init: function Init(args) {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;
      },
      canDrop: false,
      canDropCascade: false,
      model: pgBrowser.Node.Model.extend({
        defaults: {
          name: undefined,
          oid: undefined,
          datatype: undefined,
          visibility: 'Unknown'
        },
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', mode: ['properties'],
          disabled: true
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', mode: ['properties']
        }, {
          id: 'datatype', label: gettext('Data type'), cell: 'string',
          type: 'text', disabled: true
        }, {
          id: 'visibility', label: gettext('Visibility'), cell: 'string',
          type: 'text', mode: ['properties'],
          disabled: true
        }],
        validate: function validate() {
          return null;
        }
      })
    });
  }

  return pgBrowser.Nodes['edbvar'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/* Create and Register Function Collection and Node. */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  if (!pgBrowser.Nodes['coll-trigger_function']) {
    var trigger_functions = pgBrowser.Nodes['coll-trigger_function'] = pgBrowser.Collection.extend({
      node: 'trigger_function',
      label: gettext('Trigger functions'),
      type: 'coll-trigger_function',
      columns: ['name', 'funcowner', 'description'],
      hasStatistics: true
    });
  };

  if (!pgBrowser.Nodes['trigger_function']) {
    pgBrowser.Nodes['trigger_function'] = pgBrowser.Node.extend({
      type: 'trigger_function',
      sqlAlterHelp: 'plpgsql-trigger.html',
      sqlCreateHelp: 'plpgsql-trigger.html',
      dialogHelp: url_for('help.static', { 'filename': 'trigger_function_dialog.html' }),
      label: gettext('Trigger function'),
      collection_type: 'coll-trigger_function',
      hasSQL: true,
      hasDepends: true,
      hasStatistics: true,
      parent_type: ['schema', 'catalog'],
      Init: function Init(args) {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_trigger_function_on_coll', node: 'coll-trigger_function', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Trigger function...'),
          icon: 'wcTabIcon icon-trigger_function', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_trigger_function', node: 'trigger_function', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Trigger function...'),
          icon: 'wcTabIcon icon-trigger_function', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_trigger_function', node: 'schema', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Trigger function...'),
          icon: 'wcTabIcon icon-trigger_function', data: { action: 'create', check: false },
          enable: 'canCreate'
        }]);
      },
      canDrop: pgBrowser.Nodes['schema'].canChildDrop,
      canDropCascade: pgBrowser.Nodes['schema'].canChildDrop,
      model: pgBrowser.Node.Model.extend({
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;
          if (isNew) {
            // Set Selected Schema
            var schema_id = args.node_info.schema._id;
            this.set({ 'pronamespace': schema_id }, { silent: true });

            // Set Current User
            var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;
            this.set({ 'funcowner': userInfo.name }, { silent: true });
          }
          pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
        },
        defaults: {
          name: undefined,
          oid: undefined,
          xmin: undefined,
          funcowner: undefined,
          pronamespace: undefined,
          description: undefined,
          pronargs: undefined, /* Argument Count */
          proargs: undefined, /* Arguments */
          proargtypenames: undefined, /* Argument Signature */
          prorettypename: 'trigger', /* Return Type */
          lanname: 'plpgsql', /* Language Name in which function is being written */
          provolatile: undefined, /* Volatility */
          proretset: undefined, /* Return Set */
          proisstrict: undefined,
          prosecdef: undefined, /* Security of definer */
          proiswindow: undefined, /* Window Function ? */
          procost: undefined, /* Estimated execution Cost */
          prorows: undefined, /* Estimated number of rows */
          proleakproof: undefined,
          args: [],
          prosrc: undefined,
          prosrc_c: undefined,
          probin: '$libdir/',
          options: [],
          variables: [],
          proacl: undefined,
          seclabels: [],
          acl: [],
          sysfunc: undefined,
          sysproc: undefined
        },
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'],
          disabled: 'isDisabled'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', mode: ['properties']
        }, {
          id: 'funcowner', label: gettext('Owner'), cell: 'string',
          control: Backform.NodeListByNameControl, node: 'role', type: 'text', disabled: 'isDisabled'
        }, {
          id: 'pronamespace', label: gettext('Schema'), cell: 'string',
          control: 'node-list-by-id', type: 'text', cache_level: 'database',
          node: 'schema', disabled: 'isDisabled', mode: ['create', 'edit']
        }, {
          id: 'sysfunc', label: gettext('System function?'),
          cell: 'boolean', type: 'switch',
          mode: ['properties'], visible: 'isVisible'
        }, {
          id: 'sysproc', label: gettext('System procedure?'),
          cell: 'boolean', type: 'switch',
          mode: ['properties'], visible: 'isVisible'
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline', disabled: 'isDisabled'
        }, {
          id: 'pronargs', label: gettext('Argument count'), cell: 'string',
          type: 'text', group: gettext('Definition'), mode: ['properties']
        }, {
          id: 'proargs', label: gettext('Arguments'), cell: 'string',
          type: 'text', group: gettext('Definition'), mode: ['properties', 'edit'],
          disabled: 'isDisabled'
        }, {
          id: 'proargtypenames', label: gettext('Signature arguments'), cell: 'string', type: 'text', group: gettext('Definition'), mode: ['properties'],
          disabled: 'isDisabled'
        }, {
          id: 'prorettypename', label: gettext('Return type'), cell: 'string',
          control: 'select2', type: 'text', group: gettext('Definition'),
          disabled: 'isDisabled', first_empty: true,
          select2: { width: "100%", allowClear: false },
          mode: ['create'], visible: 'isVisible', options: [{ label: 'trigger', value: 'trigger' }, { label: 'event_trigger', value: 'event_trigger' }]
        }, {
          id: 'prorettypename', label: gettext('Return type'), cell: 'string',
          type: 'text', group: gettext('Definition'),
          mode: ['properties', 'edit'], disabled: 'isDisabled', visible: 'isVisible'
        }, {
          id: 'lanname', label: gettext('Language'), cell: 'string',
          control: 'node-ajax-options', type: 'text', group: gettext('Definition'),
          url: 'get_languages', disabled: 'isDisabled', transform: function transform(d, self) {
            return _.reject(d, function (o) {
              return o.label == 'sql' || o.label == 'edbspl';
            });
          }, select2: { allowClear: false }
        }, {
          id: 'prosrc', label: gettext('Code'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'],
          group: gettext('Definition'), deps: ['lanname'],
          control: Backform.SqlFieldControl,
          extraClasses: ['custom_height_css_class'],
          visible: function visible(m) {
            if (m.get('lanname') == 'c') {
              return false;
            }
            return true;
          }, disabled: 'isDisabled'
        }, {
          id: 'probin', label: gettext('Object file'), cell: 'string',
          type: 'text', group: gettext('Definition'), deps: ['lanname'], visible: function visible(m) {
            if (m.get('lanname') == 'c') {
              return true;
            }
            return false;
          }, disabled: 'isDisabled'
        }, {
          id: 'prosrc_c', label: gettext('Link symbol'), cell: 'string',
          type: 'text', group: gettext('Definition'), deps: ['lanname'], visible: function visible(m) {
            if (m.get('lanname') == 'c') {
              return true;
            }
            return false;
          }, disabled: 'isDisabled'
        }, {
          id: 'provolatile', label: gettext('Volatility'), cell: 'string',
          control: 'node-ajax-options', type: 'text', group: gettext('Options'),
          options: [{ 'label': 'VOLATILE', 'value': 'v' }, { 'label': 'STABLE', 'value': 's' }, { 'label': 'IMMUTABLE', 'value': 'i' }], disabled: 'isDisabled', select2: { allowClear: false }
        }, {
          id: 'proretset', label: gettext('Returns a set?'), type: 'switch',
          group: gettext('Options'), disabled: 'isDisabled',
          visible: 'isVisible'
        }, {
          id: 'proisstrict', label: gettext('Strict?'), type: 'switch',
          disabled: 'isDisabled', group: gettext('Options'),
          options: {
            'onText': 'Yes', 'offText': 'No',
            'onColor': 'success', 'offColor': 'primary',
            'size': 'small'
          }
        }, {
          id: 'prosecdef', label: gettext('Security of definer?'),
          group: gettext('Options'), cell: 'boolean', type: 'switch',
          disabled: 'isDisabled'
        }, {
          id: 'proiswindow', label: gettext('Window?'),
          group: gettext('Options'), cell: 'boolean', type: 'switch',
          disabled: 'isDisabled', visible: 'isVisible'
        }, {
          id: 'procost', label: gettext('Estimated cost'), type: 'text',
          group: gettext('Options'), disabled: 'isDisabled'
        }, {
          id: 'prorows', label: gettext('Estimated rows'), type: 'text',
          group: gettext('Options'),
          disabled: 'isDisabled',
          deps: ['proretset'], visible: 'isVisible'
        }, {
          id: 'proleakproof', label: gettext('Leak proof?'),
          group: gettext('Options'), cell: 'boolean', type: 'switch', min_version: 90200,
          disabled: 'isDisabled'
        }, pgBrowser.SecurityGroupSchema, {
          id: 'proacl', label: gettext('Privileges'), mode: ['properties'],
          group: gettext('Security'), type: 'text'
        }, {
          id: 'variables', label: gettext('Parameters'), type: 'collection',
          group: gettext('Parameters'), control: 'variable-collection',
          model: pgBrowser.Node.VariableModel,
          mode: ['edit', 'create'], canAdd: 'canVarAdd', canEdit: false,
          canDelete: true, disabled: 'isDisabled'
        }, {
          id: 'acl', label: gettext('Privileges'), editable: false,
          type: 'collection', group: 'security', mode: ['edit', 'create'],
          model: pgBrowser.Node.PrivilegeRoleModel.extend({
            privileges: ['X']
          }), uniqueCol: ['grantee', 'grantor'], disabled: 'isDisabled',
          canAdd: true, canDelete: true, control: 'unique-col-collection'
        }, {
          id: 'seclabels', label: gettext('Security Labels'), canEdit: true,
          model: pgBrowser.SecLabelModel, type: 'collection',
          min_version: 90100, group: 'security', mode: ['edit', 'create'],
          canDelete: true, control: 'unique-col-collection', canAdd: true,
          uniqueCol: ['provider'], disabled: 'isDisabled'
        }],
        validate: function validate(keys) {
          var err = {},
              errmsg,
              seclabels = this.get('seclabels');

          // Nothing to validate
          if (keys && keys.length == 0) {
            this.errorModel.clear();
            return null;
          }

          if (_.isUndefined(this.get('name')) || String(this.get('name')).replace(/^\s+|\s+$/g, '') == '') {
            err['name'] = gettext('Name cannot be empty.');
            errmsg = errmsg || err['name'];
          }

          if (_.isUndefined(this.get('funcowner')) || String(this.get('funcowner')).replace(/^\s+|\s+$/g, '') == '') {
            err['funcowner'] = gettext('Owner cannot be empty.');
            errmsg = errmsg || err['funcowner'];
          }

          if (_.isUndefined(this.get('pronamespace')) || String(this.get('pronamespace')).replace(/^\s+|\s+$/g, '') == '') {
            err['pronamespace'] = gettext('Schema cannot be empty.');
            errmsg = errmsg || err['pronamespace'];
          }

          if (_.isUndefined(this.get('prorettypename')) || String(this.get('prorettypename')).replace(/^\s+|\s+$/g, '') == '') {
            err['prorettypename'] = gettext('Return type cannot be empty.');
            errmsg = errmsg || err['prorettypename'];
          }

          if (_.isUndefined(this.get('lanname')) || String(this.get('lanname')).replace(/^\s+|\s+$/g, '') == '') {
            err['lanname'] = gettext('Language cannot be empty.');
            errmsg = errmsg || err['lanname'];
          }

          if (String(this.get('lanname')) == 'c') {
            if (_.isUndefined(this.get('probin')) || String(this.get('probin')).replace(/^\s+|\s+$/g, '') == '') {
              err['probin'] = gettext('Object File cannot be empty.');
              errmsg = errmsg || err['probin'];
            }

            if (_.isUndefined(this.get('prosrc_c')) || String(this.get('prosrc_c')).replace(/^\s+|\s+$/g, '') == '') {
              err['prosrc_c'] = gettext('Link Symbol cannot be empty.');
              errmsg = errmsg || err['prosrc_c'];
            }
          } else {
            if (_.isUndefined(this.get('prosrc')) || String(this.get('prosrc')).replace(/^\s+|\s+$/g, '') == '') {
              err['prosrc'] = gettext('Code cannot be empty.');
              errmsg = errmsg || err['prosrc'];
            }
          }

          if (seclabels) {
            var secLabelsErr;
            for (var i = 0; i < seclabels.models.length && !secLabelsErr; i++) {
              secLabelsErr = seclabels.models[i].validate.apply(seclabels.models[i]);
              if (secLabelsErr) {
                err['seclabels'] = secLabelsErr;
                errmsg = errmsg || secLabelsErr;
              }
            }
          }

          this.errorModel.clear().set(err);

          if (_.size(err)) {
            this.trigger('on-status', { msg: errmsg });
            return errmsg;
          }

          return null;
        },
        isVisible: function isVisible(m) {
          if (this.name == 'sysproc') {
            return false;
          }
          return true;
        },
        isDisabled: function isDisabled(m) {
          if (this.node_info && 'catalog' in this.node_info) {
            return true;
          }
          name = this.name;
          switch (name) {
            case 'proargs':
            case 'proargtypenames':
            case 'prorettypename':
            case 'proretset':
            case 'proiswindow':
              return !m.isNew();
              break;
            case 'prorows':
              if (m.get('proretset') == true) {
                return false;
              } else {
                return true;
              }
              break;
            default:
              return false;
              break;
          }
          return false;
        },
        canVarAdd: function canVarAdd(m) {
          if (this.node_info && 'catalog' in this.node_info) {
            return false;
          }
          return true;
        }
      }),
      canCreate: function canCreate(itemData, item, data) {
        //If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        // To iterate over tree to check parent node
        while (i) {
          // If it is schema then allow user to create Function
          if (_.indexOf(['schema'], d._type) > -1) return true;

          if ('coll-trigger_function' == d._type) {
            //Check if we are not child of catalog
            var prev_i = t.hasParent(i) ? t.parent(i) : null,
                prev_d = prev_i ? t.itemData(prev_i) : null;
            if (prev_d._type == 'catalog') {
              return false;
            } else {
              return true;
            }
          }
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // by default we do not want to allow create menu
        return true;
      }
    });
  }

  return pgBrowser.Nodes['trigger_function'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  // Extend the browser's collection class for package collection
  if (!pgBrowser.Nodes['coll-package']) {
    var databases = pgBrowser.Nodes['coll-package'] = pgBrowser.Collection.extend({
      node: 'package',
      label: gettext('Packages'),
      type: 'coll-package',
      columns: ['name', 'owner', 'description']
    });
  };

  // Extend the browser's node class for package node
  if (!pgBrowser.Nodes['package']) {
    pgBrowser.Nodes['package'] = pgBrowser.Node.extend({
      type: 'package',
      dialogHelp: url_for('help.static', { 'filename': 'package_dialog.html' }),
      label: gettext('Package'),
      collection_type: 'coll-package',
      hasSQL: true,
      hasDepends: true,
      parent_type: ['schema', 'catalog'],
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_package_on_coll', node: 'coll-package', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Package...'),
          icon: 'wcTabIcon icon-package', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_package', node: 'package', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Package...'),
          icon: 'wcTabIcon icon-package', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_package', node: 'schema', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Package...'),
          icon: 'wcTabIcon icon-package', data: { action: 'create', check: true },
          enable: 'canCreate'
        }]);
      },
      canDrop: pgBrowser.Nodes['schema'].canChildDrop,
      canDropCascade: pgBrowser.Nodes['schema'].canChildDrop,
      canCreate: function canCreate(itemData, item, data) {
        //If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var treeData = this.getTreeNodeHierarchy(item),
            server = treeData['server'];

        if (server && server.server_type === 'pg') return false;

        // If it is catalog then don't allow user to create package
        if (treeData['catalog'] != undefined) return false;

        // by default we want to allow create menu
        return true;
      },
      // Define the model for package node.
      model: pgBrowser.Node.Model.extend({
        defaults: {
          name: undefined,
          oid: undefined,
          owner: undefined,
          is_sys_object: undefined,
          description: undefined,
          pkgheadsrc: undefined,
          pkgbodysrc: undefined,
          acl: undefined,
          pkgacl: []
        },
        initialize: function initialize(attrs, args) {
          if (_.size(attrs) === 0) {
            var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;
            var schemaInfo = args.node_info.schema;

            this.set({
              'owner': userInfo.name, 'schema': schemaInfo._label
            }, { silent: true });
          }
          pgAdmin.Browser.Node.Model.prototype.initialize.apply(this, arguments);
        },
        // Define the schema for package node.
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'],
          disabled: function disabled(m) {
            return !m.isNew();
          }
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', mode: ['properties']
        }, {
          id: 'owner', label: gettext('Owner'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'],
          disabled: true, editable: false, visible: function visible(m) {
            return !m.isNew();
          }
        }, {
          id: 'schema', label: gettext('Schema'), type: 'text', node: 'schema',
          control: 'node-list-by-name',
          disabled: function disabled(m) {
            return !m.isNew();
          }, filter: function filter(d) {
            // If schema name start with pg_* then we need to exclude them
            if (d && d.label.match(/^pg_/)) {
              return false;
            }
            return true;
          }, cache_node: 'database', cache_level: 'database'
        }, {
          id: 'is_sys_object', label: gettext('System package?'),
          cell: 'boolean', type: 'switch', mode: ['properties']
        }, {
          id: 'description', label: gettext('Comment'), type: 'multiline',
          mode: ['properties', 'create', 'edit']
        }, {
          id: 'pkgheadsrc', label: gettext('Header'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'], group: gettext('Code'),
          control: Backform.SqlFieldControl
        }, {
          id: 'pkgbodysrc', label: gettext('Body'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'], group: gettext('Code'),
          control: Backform.SqlFieldControl
        }, {
          id: 'acl', label: gettext('Privileges'), type: 'text',
          group: gettext('Security'), mode: ['properties']
        }, {
          id: 'pkgacl', label: gettext('Privileges'), type: 'collection',
          model: pgBrowser.Node.PrivilegeRoleModel.extend({
            privileges: ['X']
          }), uniqueCol: ['grantee', 'grantor'], editable: false,
          group: gettext('Security'), mode: ['edit', 'create'],
          canAdd: true, canDelete: true, control: 'unique-col-collection'
        }],
        /* validate function is used to validate the input given by
         * the user. In case of error, message will be displayed on
         * the GUI for the respective control.
         */
        validate: function validate() {
          var msg = undefined;
          // Clear any existing error msg.
          this.errorModel.clear();

          if (_.isUndefined(this.get('name')) || String(this.get('name')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Name cannot be empty.');
            this.errorModel.set('name', msg);
            return msg;
          }

          if (_.isUndefined(this.get('pkgheadsrc')) || String(this.get('pkgheadsrc')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Header cannot be empty.');
            this.errorModel.set('pkgheadsrc', msg);
            return msg;
          }

          return null;
        }
      })
    });
  }

  return pgBrowser.Nodes['package'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  // Extend the browser's collection class for sequence collection
  if (!pgBrowser.Nodes['coll-sequence']) {
    var databases = pgBrowser.Nodes['coll-sequence'] = pgBrowser.Collection.extend({
      node: 'sequence',
      label: gettext('Sequences'),
      type: 'coll-sequence',
      columns: ['name', 'seqowner', 'comment'],
      hasStatistics: true
    });
  };

  // Extend the browser's node class for sequence node
  if (!pgBrowser.Nodes['sequence']) {
    pgBrowser.Nodes['sequence'] = pgBrowser.Node.extend({
      type: 'sequence',
      sqlAlterHelp: 'sql-altersequence.html',
      sqlCreateHelp: 'sql-createsequence.html',
      dialogHelp: url_for('help.static', { 'filename': 'sequence_dialog.html' }),
      label: gettext('Sequence'),
      collection_type: 'coll-sequence',
      hasSQL: true,
      hasDepends: true,
      hasStatistics: true,
      parent_type: ['schema', 'catalog'],
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_sequence_on_coll', node: 'coll-sequence', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Sequence...'),
          icon: 'wcTabIcon icon-sequence', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_sequence', node: 'sequence', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Sequence...'),
          icon: 'wcTabIcon icon-sequence', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_sequence', node: 'schema', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Sequence...'),
          icon: 'wcTabIcon icon-sequence', data: { action: 'create', check: false },
          enable: 'canCreate'
        }]);
      },
      canDrop: pgBrowser.Nodes['schema'].canChildDrop,
      canDropCascade: pgBrowser.Nodes['schema'].canChildDrop,
      canCreate: function canCreate(itemData, item, data) {
        //If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        // To iterate over tree to check parent node
        while (i) {
          // If it is schema then allow user to create collation
          if (_.indexOf(['schema'], d._type) > -1) return true;

          if ('coll-sequence' == d._type) {
            //Check if we are not child of catalog
            var prev_i = t.hasParent(i) ? t.parent(i) : null,
                prev_d = prev_i ? t.itemData(prev_i) : null;
            if (prev_d._type == 'catalog') {
              return false;
            } else {
              return true;
            }
          }
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // by default we want to allow create menu
        return true;
      },
      // Define the model for sequence node.
      model: pgBrowser.Node.Model.extend({
        defaults: {
          name: undefined,
          oid: undefined,
          seqowner: undefined,
          schema: undefined,
          comment: undefined,
          increment: undefined,
          start: undefined,
          current_value: undefined,
          minimum: undefined,
          maximum: undefined,
          cache: undefined,
          cycled: undefined,
          relacl: [],
          securities: []
        },

        // Default values!
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;

          if (isNew) {
            var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;
            var schemaInfo = args.node_info.schema;

            this.set({ 'seqowner': userInfo.name }, { silent: true });
            this.set({ 'schema': schemaInfo._label }, { silent: true });
          }
          pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
        },

        // Define the schema for sequence node.
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit']
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', mode: ['properties']
        }, {
          id: 'seqowner', label: gettext('Owner'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'], node: 'role',
          control: Backform.NodeListByNameControl
        }, {
          id: 'schema', label: gettext('Schema'), cell: 'string',
          control: 'node-list-by-name', node: 'schema',
          type: 'text', mode: ['create', 'edit'], filter: function filter(d) {
            // If schema name start with pg_* then we need to exclude them
            if (d && d.label.match(/^pg_/)) {
              return false;
            }
            return true;
          }, cache_node: 'database', cache_level: 'database'
        }, {
          id: 'comment', label: gettext('Comment'), type: 'multiline',
          mode: ['properties', 'create', 'edit']
        }, {
          id: 'current_value', label: gettext('Current value'), type: 'int',
          mode: ['properties', 'edit'], group: gettext('Definition')
        }, {
          id: 'increment', label: gettext('Increment'), type: 'int',
          mode: ['properties', 'create', 'edit'], group: gettext('Definition'),
          min: 1
        }, {
          id: 'start', label: gettext('Start'), type: 'int',
          mode: ['properties', 'create'], group: gettext('Definition'),
          disabled: function disabled(m) {
            return !m.isNew();
          }
        }, {
          id: 'minimum', label: gettext('Minimum'), type: 'int',
          mode: ['properties', 'create', 'edit'], group: gettext('Definition')
        }, {
          id: 'maximum', label: gettext('Maximum'), type: 'int',
          mode: ['properties', 'create', 'edit'], group: gettext('Definition')
        }, {
          id: 'cache', label: gettext('Cache'), type: 'int',
          mode: ['properties', 'create', 'edit'], group: gettext('Definition'),
          min: 1
        }, {
          id: 'cycled', label: gettext('Cycled'), type: 'switch',
          mode: ['properties', 'create', 'edit'], group: gettext('Definition'),
          options: {
            'onText': 'Yes', 'offText': 'No',
            'onColor': 'success', 'offColor': 'primary',
            'size': 'small'
          }
        }, pgBrowser.SecurityGroupSchema, {
          id: 'acl', label: gettext('Privileges'), type: 'text',
          group: gettext('Security'), mode: ['properties'], disabled: true
        }, {
          id: 'relacl', label: gettext('Privileges'), group: 'security',
          model: pgBrowser.Node.PrivilegeRoleModel.extend({
            privileges: ['r', 'w', 'U']
          }), uniqueCol: ['grantee', 'grantor'], mode: ['edit', 'create'],
          editable: false, type: 'collection', canAdd: true, canDelete: true,
          control: 'unique-col-collection'
        }, {
          id: 'securities', label: gettext('Securitiy Labels'), canAdd: true,
          model: pgBrowser.SecLabelModel, editable: false,
          type: 'collection', canEdit: false, group: 'security',
          mode: ['edit', 'create'], canDelete: true,
          control: 'unique-col-collection',
          min_version: 90200, uniqueCol: ['provider']
        }],
        /* validate function is used to validate the input given by
         * the user. In case of error, message will be displayed on
         * the GUI for the respective control.
         */
        validate: function validate() {
          var msg = undefined,
              minimum = this.get('minimum'),
              maximum = this.get('maximum'),
              start = this.get('start');

          if (_.isUndefined(this.get('name')) || String(this.get('name')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Name cannot be empty.');
            this.errorModel.set('name', msg);
            return msg;
          } else {
            this.errorModel.unset('name');
          }

          if (_.isUndefined(this.get('seqowner')) || String(this.get('seqowner')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Owner cannot be empty.');
            this.errorModel.set('seqowner', msg);
            return msg;
          } else {
            this.errorModel.unset('seqowner');
          }

          if (_.isUndefined(this.get('schema')) || String(this.get('schema')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Schema cannot be empty.');
            this.errorModel.set('schema', msg);
            return msg;
          } else {
            this.errorModel.unset('schema');
          }

          if (!this.isNew()) {
            if (_.isUndefined(this.get('current_value')) || String(this.get('current_value')).replace(/^\s+|\s+$/g, '') == '') {
              msg = gettext('Current value cannot be empty.');
              this.errorModel.set('current_value', msg);
              return msg;
            } else {
              this.errorModel.unset('current_value');
            }

            if (_.isUndefined(this.get('increment')) || String(this.get('increment')).replace(/^\s+|\s+$/g, '') == '') {
              msg = gettext('Increment value cannot be empty.');
              this.errorModel.set('increment', msg);
              return msg;
            } else {
              this.errorModel.unset('increment');
            }

            if (_.isUndefined(this.get('minimum')) || String(this.get('minimum')).replace(/^\s+|\s+$/g, '') == '') {
              msg = gettext('Minimum value cannot be empty.');
              this.errorModel.set('minimum', msg);
              return msg;
            } else {
              this.errorModel.unset('minimum');
            }

            if (_.isUndefined(this.get('maximum')) || String(this.get('maximum')).replace(/^\s+|\s+$/g, '') == '') {
              msg = gettext('Maximum value cannot be empty.');
              this.errorModel.set('maximum', msg);
              return msg;
            } else {
              this.errorModel.unset('maximum');
            }

            if (_.isUndefined(this.get('cache')) || String(this.get('cache')).replace(/^\s+|\s+$/g, '') == '') {
              msg = gettext('Cache value cannot be empty.');
              this.errorModel.set('cache', msg);
              return msg;
            } else {
              this.errorModel.unset('cache');
            }
          }
          var min_lt = gettext('Minimum value must be less than maximum value.'),
              start_lt = gettext('Start value cannot be less than minimum value.'),
              start_gt = gettext('Start value cannot be greater than maximum value.');

          if (minimum == 0 && maximum == 0 || parseInt(minimum, 10) >= parseInt(maximum, 10)) {
            this.errorModel.set('minimum', min_lt);
            return min_lt;
          } else {
            this.errorModel.unset('minimum');
          }

          if (start && minimum && parseInt(start) < parseInt(minimum)) {
            this.errorModel.set('start', start_lt);
            return start_lt;
          } else {
            this.errorModel.unset('start');
          }

          if (start && maximum && parseInt(start) > parseInt(maximum)) {
            this.errorModel.set('start', start_gt);
            return start_gt;
          } else {
            this.errorModel.unset('start');
          }
          return null;
        }
      })
    });
  }

  return pgBrowser.Nodes['sequence'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(17), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  if (!pgBrowser.Nodes['coll-synonym']) {
    var databases = pgAdmin.Browser.Nodes['coll-synonym'] = pgAdmin.Browser.Collection.extend({
      node: 'synonym',
      label: gettext('Synonyms'),
      type: 'coll-synonym',
      columns: ['name', 'owner', 'is_public_synonym']
    });
  };

  if (!pgBrowser.Nodes['synonym']) {
    pgAdmin.Browser.Nodes['synonym'] = pgBrowser.Node.extend({
      type: 'synonym',
      dialogHelp: url_for('help.static', { 'filename': 'synonym_dialog.html' }),
      label: gettext('Synonym'),
      collection_type: 'coll-synonym',
      hasSQL: true,
      hasDepends: true,
      parent_type: ['schema', 'catalog'],
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_synonym_on_coll', node: 'coll-synonym', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Synonym...'),
          icon: 'wcTabIcon icon-synonym', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_synonym', node: 'synonym', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Synonym...'),
          icon: 'wcTabIcon icon-synonym', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_synonym', node: 'schema', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Synonym...'),
          icon: 'wcTabIcon icon-synonym', data: { action: 'create', check: true },
          enable: 'canCreate'
        }]);
      },
      canDrop: pgBrowser.Nodes['schema'].canChildDrop,
      model: pgAdmin.Browser.Node.Model.extend({
        isNew: function isNew() {
          return !this.fetchFromServer;
        },
        idAttribute: 'name',
        // Default values!
        initialize: function initialize(attrs, args) {
          var isNew = _.size(attrs) === 0;

          if (isNew) {
            var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;
            var schemaInfo = args.node_info.schema;
            this.set({
              'owner': userInfo.name,
              'synobjschema': schemaInfo._label,
              'schema': schemaInfo._label,
              'targettype': 'r'
            }, { silent: true });
          } else {
            this.fetchFromServer = true;
          }
          pgAdmin.Browser.Node.Model.prototype.initialize.apply(this, arguments);
        },
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'],
          disabled: 'inSchemaWithModelCheck'
        }, {
          id: 'owner', label: gettext('Owner'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'],
          disabled: true, control: 'node-list-by-name',
          node: 'role', visible: false
        }, {
          id: 'schema', label: gettext('Schema'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'],
          disabled: function disabled(m) {
            return !m.isNew();
          }, node: 'schema',
          control: 'node-list-by-name', cache_node: 'database',
          cache_level: 'database'
        }, {
          id: 'targettype', label: gettext('Target type'), cell: 'string',
          disabled: 'inSchema', group: gettext('Definition'),
          select2: { width: "50%", allowClear: false },
          options: function options(obj) {
            return [{ label: gettext("Function"), value: "f" }, { label: gettext("Package"), value: "P" }, { label: gettext("Procedure"), value: "p" }, { label: gettext("Public Synonym"), value: "s" }, { label: gettext("Sequence"), value: "S" }, { label: gettext("Table"), value: "r" }, { label: gettext("View"), value: "v" }];
          },
          control: 'select2'
        }, {
          id: 'synobjschema', label: gettext('Target schema'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'],
          group: gettext('Definition'), deps: ['targettype'],
          select2: { allowClear: false }, control: 'node-list-by-name',
          node: 'schema', filter: function filter(d) {
            // Exclude PPAS catalogs
            var exclude_catalogs = ['pg_catalog', 'sys', 'dbo', 'pgagent', 'information_schema', 'dbms_job_procedure'];
            return d && _.indexOf(exclude_catalogs, d.label) == -1;
          },
          disabled: function disabled(m) {
            // If tagetType is synonym then disable it
            if (!m.inSchema.apply(this, [m])) {
              var is_synonym = m.get('targettype') == 's';
              if (is_synonym) {
                m.set('synobjschema', 'public', { silent: true });
                return true;
              } else {
                return false;
              }
            }
            return true;
          }
        }, {
          id: 'synobjname', label: gettext('Target object'), cell: 'string',
          type: 'text', disabled: 'inSchema', group: gettext('Definition'),
          deps: ['targettype', 'synobjschema'],
          control: 'node-ajax-options',
          options: function options(control) {
            var trgTyp = control.model.get('targettype');
            var trgSchema = control.model.get('synobjschema');
            var res = [];

            var node = control.field.get('schema_node'),
                _url = node.generate_url.apply(node, [null, 'get_target_objects', control.field.get('node_data'), false, control.field.get('node_info')]);
            $.ajax({
              type: 'GET',
              timeout: 30000,
              url: _url,
              cache: false,
              async: false,
              data: { "trgTyp": trgTyp, "trgSchema": trgSchema },

              // On success return function list from server
              success: function success(result) {
                res = result.data;
                return res;
              },

              // On failure show error appropriate error message to user
              error: function error(xhr, status, _error) {
                try {
                  var err = $.parseJSON(xhr.responseText);
                  if (err.success == 0) {
                    alertify.error(err.errormsg);
                  }
                } catch (e) {}
              }
            });
            return res;
          }
        }, {
          id: 'is_public_synonym', label: gettext('Public synonym?'),
          disabled: true, type: 'switch', mode: ['properties'], cell: 'switch',
          options: { onText: 'Yes', offText: 'No', onColor: 'success',
            offColor: 'primary', size: 'mini' }
        }],
        validate: function validate() {
          var err = {},
              msg = undefined;
          this.errorModel.clear();

          if (_.isUndefined(this.get('name')) || String(this.get('name')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Name cannot be empty.');
            this.errorModel.set('name', msg);
          } else if (_.isUndefined(this.get('synobjschema')) || String(this.get('synobjschema')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Target schema cannot be empty.');
            this.errorModel.set('synobjschema', msg);
          } else if (_.isUndefined(this.get('synobjname')) || String(this.get('synobjname')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Target object cannot be empty.');
            this.errorModel.set('synobjname', msg);
          }
          return null;
        },
        // We will disable everything if we are under catalog node
        inSchema: function inSchema() {
          if (this.node_info && 'catalog' in this.node_info) {
            return true;
          }
          return false;
        },
        // We will check if we are under schema node & in 'create' mode
        inSchemaWithModelCheck: function inSchemaWithModelCheck(m) {
          if (this.node_info && 'schema' in this.node_info) {
            // We will disbale control if it's in 'edit' mode
            if (m.isNew()) {
              return false;
            } else {
              return true;
            }
          }
          return true;
        }
      }),
      canCreate: function canCreate(itemData, item, data) {
        //If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var treeData = this.getTreeNodeHierarchy(item),
            server = treeData['server'];

        if (server && server.server_type === 'pg') return false;

        // If it is catalog then don't allow user to create synonyms
        if (treeData['catalog'] != undefined) return false;

        // by default we do not want to allow create menu
        return true;
      }
    });
  }

  return pgBrowser.Nodes['synonym'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(13), __webpack_require__(28), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify, Backgrid) {

  if (!pgBrowser.Nodes['coll-type']) {
    var databases = pgBrowser.Nodes['coll-type'] = pgBrowser.Collection.extend({
      node: 'type',
      label: gettext('Types'),
      type: 'coll-type',
      columns: ['name', 'typeowner', 'description']
    });
  };

  // Integer Cell for Columns Length and Precision
  var IntegerDepCell = Backgrid.IntegerCell.extend({
    initialize: function initialize() {
      Backgrid.NumberCell.prototype.initialize.apply(this, arguments);
      Backgrid.Extension.DependentCell.prototype.initialize.apply(this, arguments);
    },
    dependentChanged: function dependentChanged() {
      this.$el.empty();
      var model = this.model;
      var column = this.column;
      var editable = this.column.get("editable");

      var is_editable = _.isFunction(editable) ? !!editable.apply(column, [model]) : !!editable;
      if (is_editable) {
        this.$el.addClass("editable");
      } else {
        this.$el.removeClass("editable");
      }

      this.delegateEvents();
      return this;
    },
    remove: Backgrid.Extension.DependentCell.prototype.remove
  });

  // Node-Ajax-Cell with Deps
  var NodeAjaxOptionsDepsCell = Backgrid.Extension.NodeAjaxOptionsCell.extend({
    initialize: function initialize() {
      Backgrid.Extension.NodeAjaxOptionsCell.prototype.initialize.apply(this, arguments);
      Backgrid.Extension.DependentCell.prototype.initialize.apply(this, arguments);
    },
    dependentChanged: function dependentChanged() {
      var model = this.model,
          column = this.column,
          editable = this.column.get("editable"),
          input = this.$el.find('select').first();

      var is_editable = _.isFunction(editable) ? !!editable.apply(column, [model]) : !!editable;
      if (is_editable) {
        this.$el.addClass("editable");
        input.prop('disabled', false);
      } else {
        this.$el.removeClass("editable");
        input.prop('disabled', true);
      }

      this.delegateEvents();
      return this;
    },
    remove: Backgrid.Extension.DependentCell.prototype.remove
  });

  // Composite type model declaration
  var CompositeModel = Backform.CompositeModel = pgBrowser.Node.Model.extend({
    idAttribute: 'attnum',
    defaults: {
      attnum: undefined,
      member_name: undefined,
      type: undefined,
      tlength: undefined,
      is_tlength: false,
      precision: undefined,
      is_precision: false,
      collation: undefined,
      min_val: undefined,
      max_val: undefined
    },
    type_options: undefined,
    subtypes: undefined,
    schema: [{
      id: 'member_name', label: gettext('Member Name'),
      type: 'text', disabled: false, editable: true
    }, {
      id: 'type', label: gettext('Type'), control: 'node-ajax-options',
      type: 'text', url: 'get_types', disabled: false, node: 'type',
      cell: 'node-ajax-options', select2: { allowClear: false },
      editable: true,
      transform: function transform(d, control) {
        control.model.type_options = d;
        return d;
      }
    }, {
      // Note: There are ambiguities in the PG catalogs and docs between
      // precision and scale. In the UI, we try to follow the docs as
      // closely as possible, therefore we use Length/Precision and Scale
      id: 'tlength', label: gettext('Length/precision'), deps: ['type'], type: 'text',
      disabled: false, cell: IntegerDepCell,
      editable: function editable(m) {
        // We will store type from selected from combobox
        var of_type = m.get('type');
        if (m.type_options) {
          // iterating over all the types
          _.each(m.type_options, function (o) {
            // if type from selected from combobox matches in options
            if (of_type == o.value) {
              // if length is allowed for selected type
              if (o.length) {
                // set the values in model
                m.set('is_tlength', true, { silent: true });
                m.set('min_val', o.min_val, { silent: true });
                m.set('max_val', o.max_val, { silent: true });
              } else {
                // set the values in model
                m.set('is_tlength', false, { silent: true });
              }
            }
          });
        }
        return m.get('is_tlength');
      }
    }, {
      // Note: There are ambiguities in the PG catalogs and docs between
      // precision and scale. In the UI, we try to follow the docs as
      // closely as possible, therefore we use Length/Precision and Scale
      id: 'precision', label: gettext('Scale'), deps: ['type'],
      type: 'text', disabled: false, cell: IntegerDepCell,
      editable: function editable(m) {
        // We will store type from selected from combobox
        var of_type = m.get('type');
        if (m.type_options) {
          // iterating over all the types
          _.each(m.type_options, function (o) {
            // if type from selected from combobox matches in options
            if (of_type == o.value) {
              // if precession is allowed for selected type
              if (o.precision) {
                // set the values in model
                m.set('is_precision', true, { silent: true });
                m.set('min_val', o.min_val, { silent: true });
                m.set('max_val', o.max_val, { silent: true });
              } else {
                // set the values in model
                m.set('is_precision', false, { silent: true });
              }
            }
          });
        }
        return m.get('is_precision');
      }
    }, {
      id: 'collation', label: gettext('Collation'),
      cell: NodeAjaxOptionsDepsCell, deps: ['type'],
      select2: { allowClear: false },
      control: 'node-ajax-options', editable: function editable(m) {
        var of_type = m.get('type'),
            flag = false;
        if (m.type_options) {
          _.each(m.type_options, function (o) {
            if (of_type == o.value) {
              if (o.is_collatable) {
                flag = true;
              }
            }
          });
        }

        if (flag) {
          setTimeout(function () {
            m.set('collspcname', "", { silent: true });
          }, 10);
        }
        return flag;
      },
      type: 'text', disabled: false, url: 'get_collations', node: 'type'
    }],
    validate: function validate() {
      var err = {},
          errmsg = null,
          changedAttrs = this.sessAttrs;
      // Clearing previous errors first.
      this.errorModel.clear();
      // Validation for member name
      if (_.isUndefined(this.get('member_name')) || _.isNull(this.get('member_name')) || String(this.get('member_name')).replace(/^\s+|\s+$/g, '') == '') {
        errmsg = gettext('Please specify the value for member name.');
        this.errorModel.set('member_name', errmsg);
        return errmsg;
      } else if (_.isUndefined(this.get('type')) || _.isNull(this.get('type')) || String(this.get('type')).replace(/^\s+|\s+$/g, '') == '') {
        errmsg = gettext('Please specify the type.');
        this.errorModel.set('type', errmsg);
        return errmsg;
      }
      // Validation for Length/precision field (see comments above if confused about the naming!)
      else if (this.get('is_tlength') && !_.isUndefined(this.get('tlength'))) {
          if (this.get('tlength') < this.get('min_val')) errmsg = gettext('Length/precision should not be less than %(value)s', { value: this.get('min_val') });
          if (this.get('tlength') > this.get('max_val')) errmsg = gettext('Length/precision should not be greater than %(value)s', { value: this.get('max_val') });
          // If we have any error set then throw it to user
          if (errmsg) {
            this.errorModel.set('tlength', errmsg);
            return errmsg;
          }
        }
        // Validation for scale field (see comments above if confused about the naming!)
        else if (this.get('is_precision') && !_.isUndefined(this.get('precision'))) {
            if (this.get('precision') < this.get('min_val')) errmsg = gettext('Scale should not be less than  %(value)s', { value: this.get('min_val') });
            if (this.get('precision') > this.get('max_val')) errmsg = gettext('Scale should not be greater than  %(value)s', { value: this.get('max_val') });
            // If we have any error set then throw it to user
            if (errmsg) {
              this.errorModel.set('precision', errmsg);
              return errmsg;
            }
          }
      return null;
    }
  });

  var EnumModel = Backform.EnumModel = pgBrowser.Node.Model.extend({
    defaults: {
      label: undefined
    },
    schema: [{
      id: 'label', label: gettext('Label'), type: 'text', disabled: false,
      cellHeaderClasses: 'width_percent_99', editable: function editable(m) {
        return _.isUndefined(m.get('label'));
      }
    }],
    validate: function validate() {
      return null;
    }
  });

  if (!pgBrowser.Nodes['type']) {
    var _ref;

    pgBrowser.Nodes['type'] = pgBrowser.Node.extend({
      type: 'type',
      sqlAlterHelp: 'sql-altertype.html',
      sqlCreateHelp: 'sql-createtype.html',
      dialogHelp: url_for('help.static', { 'filename': 'type_dialog.html' }),
      label: gettext('Type'),
      collection_type: 'coll-type',
      hasSQL: true,
      hasDepends: true,
      parent_type: ['schema', 'catalog'],
      Init: function Init() {
        /* Avoid multiple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_type_on_coll', node: 'coll-type', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Type...'),
          icon: 'wcTabIcon icon-type', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_type', node: 'type', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Type...'),
          icon: 'wcTabIcon icon-type', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_type', node: 'schema', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Type...'),
          icon: 'wcTabIcon icon-type', data: { action: 'create', check: false },
          enable: 'canCreate'
        }]);
      },
      canDrop: pgBrowser.Nodes['schema'].canChildDrop,
      canDropCascade: pgBrowser.Nodes['schema'].canChildDrop,
      ext_funcs: undefined,
      model: pgBrowser.Node.Model.extend({
        defaults: {
          name: undefined,
          oid: undefined,
          is_sys_type: false,
          typtype: undefined
        },

        // Default values!
        initialize: function initialize(attrs, args) {
          if (_.size(attrs) === 0) {
            var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user,
                schemaInfo = args.node_info.schema;

            this.set({
              'typeowner': userInfo.name, 'schema': schemaInfo._label
            }, { silent: true });
          }
          pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
        },

        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'],
          disabled: 'schemaCheck'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', mode: ['properties'], disabled: true
        }, {
          id: 'typeowner', label: gettext('Owner'), cell: 'string',
          control: 'node-list-by-name',
          type: 'text', mode: ['properties', 'create', 'edit'], node: 'role',
          disabled: 'inSchema', select2: { allowClear: false }
        }, {
          id: 'schema', label: gettext('Schema'), cell: 'string',
          type: 'text', mode: ['create', 'edit'], node: 'schema',
          disabled: 'schemaCheck', filter: function filter(d) {
            // If schema name start with pg_* then we need to exclude them
            if (d && d.label.match(/^pg_/)) {
              return false;
            }
            return true;
          }, cache_node: 'database', cache_level: 'database',
          control: 'node-list-by-name', select2: { allowClear: false }
        }, (_ref = {
          id: 'typtype', label: gettext('Type'),
          mode: ['create', 'edit'], disabled: 'inSchemaWithModelCheck',
          group: gettext('Definition'),
          select2: { width: "50%", allowClear: false },
          options: function options(obj) {
            return [{ label: "Composite", value: "c" }, { label: "Enumeration", value: "e" }, { label: "External", value: "b" }, { label: "Range", value: "r" }, { label: "Shell", value: "p" }];
          }
        }, _defineProperty(_ref, 'disabled', 'inSchemaWithModelCheck'), _defineProperty(_ref, 'control', Backform.Select2Control.extend({
          render: function render() {
            // Initialize parent's render method
            Backform.Select2Control.prototype.render.apply(this, arguments);
            if (this.model.isNew()) {
              this.model.set({ 'typtype': 'c' });
            }
            return this;
          }
        })), _ref), {
          id: 'composite', label: gettext('Composite Type'),
          model: CompositeModel, editable: true, type: 'collection',
          group: gettext('Definition'), mode: ['edit', 'create'],
          control: 'unique-col-collection', uniqueCol: ['member_name'],
          canAdd: true, canEdit: false, canDelete: true, disabled: 'inSchema',
          deps: ['typtype'],
          visible: function visible(m) {
            return m.get('typtype') === 'c';
          }
        }, {
          id: 'enum', label: gettext('Enumeration Type'),
          model: EnumModel, editable: true, type: 'collection',
          group: gettext('Definition'), mode: ['edit', 'create'],
          canAdd: true, canEdit: false, canDelete: function canDelete(m) {
            // We will disable it if it's in 'edit' mode
            if (m.isNew()) {
              return true;
            } else {
              return false;
            }
          },
          disabled: 'inSchema', deps: ['typtype'],
          control: 'unique-col-collection', uniqueCol: ['label'],
          visible: function visible(m) {
            return m.get('typtype') === 'e';
          }
        }, {
          // We will disable range type control in edit mode
          type: 'nested', control: 'plain-fieldset', group: gettext('Definition'),
          mode: ['edit', 'create'],
          visible: function visible(m) {
            return m.get('typtype') === 'r';
          }, deps: ['typtype'], label: '',
          schema: [{
            id: 'typname', label: gettext('Subtype'), cell: 'string',
            control: 'node-ajax-options',
            select2: { allowClear: true, placeholder: "", width: "100%" },
            url: 'get_stypes', type: 'text', mode: ['properties', 'create', 'edit'],
            group: gettext('Range Type'), disabled: 'inSchemaWithModelCheck',
            transform: function transform(d, self) {
              self.model.subtypes = d;
              return d;
            }
          }, {
            id: 'opcname', label: gettext('Subtype operator class'), cell: 'string',
            mode: ['properties', 'create', 'edit'], group: gettext('Range Type'),
            disabled: 'inSchemaWithModelCheck', deps: ['typname'],
            control: 'select', options: function options() {
              var l_typname = this.model.get('typname'),
                  self = this,
                  result = [];
              if (!_.isUndefined(l_typname) && l_typname != '') {
                var node = this.field.get('schema_node'),
                    _url = node.generate_url.apply(node, [null, 'get_subopclass', this.field.get('node_data'), false, this.field.get('node_info')]);
                $.ajax({
                  async: false,
                  url: _url,
                  cache: false,
                  data: { 'typname': l_typname },
                  success: function success(res) {
                    result = res.data;
                  },
                  error: function error() {
                    self.model.trigger('pgadmin:view:fetch:error', self.model, self.field);
                  }
                });
                //
              }
              return result;
            }
          }, {
            id: 'collname', label: gettext('Collation'), cell: 'string',
            type: 'text', mode: ['properties', 'create', 'edit'],
            group: gettext('Range Type'),
            deps: ['typname'], control: 'node-ajax-options', url: 'get_collations',
            select2: { allowClear: true, placeholder: "", width: "100%" },
            disabled: function disabled(m) {
              if (this.node_info && 'catalog' in this.node_info) {
                return true;
              }

              // Disbale in edit mode
              if (!m.isNew()) {
                return true;
              }

              // To check if collation is allowed?
              var of_subtype = m.get('typname'),
                  is_collate = undefined;
              if (!_.isUndefined(of_subtype)) {
                // iterating over all the types
                _.each(m.subtypes, function (s) {
                  // if subtype from selected from combobox matches
                  if (of_subtype === s.label) {
                    // if collation is allowed for selected subtype
                    // then enable it else disable it
                    is_collate = s.is_collate;
                  }
                });
              }
              // If is_collate is true then do not disable
              return is_collate ? false : true;
            }
          }, {
            id: 'rngcanonical', label: gettext('Canonical function'), cell: 'string',
            type: 'text', mode: ['properties', 'create', 'edit'],
            group: gettext('Range Type'),
            disabled: 'inSchemaWithModelCheck', deps: ['name', 'typname'],
            control: 'select', options: function options() {
              var name = this.model.get('name'),
                  self = this,
                  result = [];

              if (!_.isUndefined(name) && name != '') {
                var node = this.field.get('schema_node'),
                    _url = node.generate_url.apply(node, [null, 'get_canonical', this.field.get('node_data'), false, this.field.get('node_info')]);
                $.ajax({
                  async: false,
                  url: _url,
                  cache: false,
                  data: { "name": name },
                  success: function success(res) {
                    result = res.data;
                  },
                  error: function error() {
                    self.model.trigger('pgadmin:view:fetch:error', self.model, self.field);
                  }
                });
              }
              return result;
            }
          }, {
            id: 'rngsubdiff', label: gettext('Subtype diff function'), cell: 'string',
            type: 'text', mode: ['properties', 'create', 'edit'],
            group: gettext('Range Type'),
            disabled: 'inSchemaWithModelCheck', deps: ['opcname'],
            control: 'select', options: function options() {
              var l_typname = this.model.get('typname'),
                  l_opcname = this.model.get('opcname'),
                  self = this,
                  result = [];

              if (!_.isUndefined(l_typname) && l_typname != '' && !_.isUndefined(l_opcname) && l_opcname != '') {
                var node = this.field.get('schema_node'),
                    _url = node.generate_url.apply(node, [null, 'get_stypediff', this.field.get('node_data'), false, this.field.get('node_info')]);
                $.ajax({
                  async: false,
                  url: _url,
                  cache: false,
                  data: { 'typname': l_typname, 'opcname': l_opcname },
                  success: function success(res) {
                    result = res.data;
                  },
                  error: function error() {
                    self.model.trigger('pgadmin:view:fetch:error', self.model, self.field);
                  }
                });
              }
              return result;
            }
          }]
        }, {
          type: 'nested', control: 'tab', group: gettext('Definition'),
          label: gettext('External Type'), deps: ['typtype'],
          mode: ['create', 'edit'],
          visible: function visible(m) {
            return m.get('typtype') === 'b';
          },
          schema: [{
            id: 'typinput', label: gettext('Input function'),
            cell: 'string', type: 'text',
            mode: ['properties', 'create', 'edit'], group: gettext('Required'),
            disabled: 'inSchemaWithModelCheck',
            control: 'node-ajax-options', url: 'get_external_functions',
            transform: 'external_func_combo',
            select2: { allowClear: true, placeholder: "", width: "100%" }
          }, {
            id: 'typoutput', label: gettext('Output function'),
            cell: 'string',
            type: 'text', mode: ['properties', 'create', 'edit'],
            group: gettext('Required'),
            disabled: 'inSchemaWithModelCheck',
            control: 'node-ajax-options', url: 'get_external_functions',
            transform: 'external_func_combo',
            select2: { allowClear: true, placeholder: "", width: "100%" }
          }, {
            id: 'typreceive', label: gettext('Receive function'),
            cell: 'string', type: 'text', group: gettext('Optional-1'),
            mode: ['properties', 'create', 'edit'],
            disabled: 'inSchemaWithModelCheck',
            control: 'node-ajax-options', url: 'get_external_functions',
            transform: 'external_func_combo',
            select2: { allowClear: true, placeholder: "", width: "100%" }
          }, {
            id: 'typsend', label: gettext('Send function'),
            cell: 'string', group: gettext('Optional-1'),
            type: 'text', mode: ['properties', 'create', 'edit'],
            disabled: 'inSchemaWithModelCheck',
            control: 'node-ajax-options', url: 'get_external_functions',
            transform: 'external_func_combo',
            select2: { allowClear: true, placeholder: "", width: "100%" }
          }, {
            id: 'typmodin', label: gettext('Typmod in function'),
            cell: 'string', type: 'text',
            mode: ['properties', 'create', 'edit'], group: gettext('Optional-1'),
            disabled: 'inSchemaWithModelCheck',
            control: 'node-ajax-options', url: 'get_external_functions',
            select2: { allowClear: true, placeholder: "", width: "100%" },
            transform: function transform(d) {
              var result = [{ label: "", value: "" }];
              _.each(d, function (item) {
                // if type from selected from combobox matches in options
                if (item.cbtype === 'typmodin' || item.cbtype === 'all') {
                  result.push(item);
                }
              });
              return result;
            }
          }, {
            id: 'typmodout', label: gettext('Typmod out function'),
            cell: 'string', group: gettext('Optional-1'),
            type: 'text', mode: ['properties', 'create', 'edit'],
            disabled: 'inSchemaWithModelCheck',
            control: 'node-ajax-options', url: 'get_external_functions',
            select2: { allowClear: true, placeholder: "", width: "100%" },
            transform: function transform(d) {
              var result = [{ label: "", value: "" }];
              _.each(d, function (item) {
                // if type from selected from combobox matches in options
                if (item.cbtype === 'typmodout' || item.cbtype === 'all') {
                  result.push(item);
                }
              });
              return result;
            }
          }, {
            id: 'typlen', label: gettext('Internal length'),
            cell: 'integer', group: gettext('Optional-1'),
            type: 'int', mode: ['properties', 'create', 'edit'],
            disabled: 'inSchemaWithModelCheck'
          }, {
            id: 'variable', label: gettext('Variable?'), cell: 'switch',
            group: gettext('Optional-1'), type: 'switch',
            mode: ['create', 'edit'],
            disabled: 'inSchemaWithModelCheck'
          }, {
            id: 'typdefault', label: gettext('Default?'),
            cell: 'string', group: gettext('Optional-1'),
            type: 'text', mode: ['properties', 'create', 'edit'],
            disabled: 'inSchemaWithModelCheck'
          }, {
            id: 'typanalyze', label: gettext('Analyze function'),
            cell: 'string', group: gettext('Optional-1'),
            type: 'text', mode: ['properties', 'create', 'edit'],
            disabled: 'inSchemaWithModelCheck',
            control: 'node-ajax-options', url: 'get_external_functions',
            transform: 'external_func_combo',
            select2: { allowClear: true, placeholder: "", width: "100%" }
          }, {
            id: 'typcategory', label: gettext('Category type'),
            cell: 'string', group: gettext('Optional-1'),
            type: 'text', mode: ['properties', 'create', 'edit'],
            disabled: 'inSchemaWithModelCheck', control: 'select2',
            select2: { allowClear: true, placeholder: "", width: "100%" },
            options: [{ label: "", value: "" }, { label: "Array types", value: "A" }, { label: "Boolean types", value: "B" }, { label: "Composite types", value: "C" }, { label: "Date/time types", value: "D" }, { label: "Enum types", value: "E" }, { label: "Geometric types", value: "G" }, { label: "Network address types", value: "I" }, { label: "Numeric types", value: "N" }, { label: "Pseudo-types", value: "P" }, { label: "String types", value: "S" }, { label: "Timespan types", value: "T" }, { label: "User-defined types", value: "U" }, { label: "Bit-string types", value: "V" }, { label: "unknown type", value: "X" }]
          }, {
            id: 'typispreferred', label: gettext('Preferred?'), cell: 'switch',
            type: 'switch', mode: ['properties', 'create', 'edit'],
            disabled: 'inSchemaWithModelCheck',
            group: gettext('Optional-1')
          }, {
            id: 'element', label: gettext('Element type'), cell: 'string',
            control: 'node-ajax-options', group: gettext('Optional-2'),
            type: 'text', mode: ['properties', 'create', 'edit'],
            disabled: 'inSchemaWithModelCheck', url: 'get_types'
          }, {
            id: 'typdelim', label: gettext('Delimiter'), cell: 'string',
            type: 'text', mode: ['properties', 'create', 'edit'],
            group: gettext('Optional-2'), disabled: 'inSchemaWithModelCheck'
          }, {
            id: 'typalign', label: gettext('Alignment type'),
            cell: 'string', group: gettext('Optional-2'),
            type: 'text', mode: ['properties', 'create', 'edit'],
            disabled: 'inSchemaWithModelCheck', control: 'select2',
            select2: { allowClear: true, placeholder: "", width: "100%" },
            options: [{ label: "", value: "" }, { label: "char", value: "c" }, { label: "int2", value: "s" }, { label: "int4", value: "i" }, { label: "double", value: "d" }]
          }, {
            id: 'typstorage', label: gettext('Storage type'),
            type: 'text', mode: ['properties', 'create', 'edit'],
            group: gettext('Optional-2'), cell: 'string',
            disabled: 'inSchemaWithModelCheck', control: 'select2',
            select2: { allowClear: true, placeholder: "", width: "100%" },
            options: [{ label: "", value: "" }, { label: "PLAIN", value: "p" }, { label: "EXTERNAL", value: "e" }, { label: "MAIN", value: "m" }, { label: "EXTENDED", value: "x" }]
          }, {
            id: 'typbyval', label: gettext('Passed by value?'),
            cell: 'switch',
            type: 'switch', mode: ['properties', 'create', 'edit'],
            disabled: 'inSchemaWithModelCheck', group: gettext('Optional-2')
          }, {
            id: 'is_collatable', label: gettext('Collatable?'),
            cell: 'switch', min_version: 90100, group: gettext('Optional-2'),
            type: 'switch', mode: ['properties', 'create', 'edit'],
            disabled: 'inSchemaWithModelCheck'
            // End of extension tab
          }]
        }, {
          id: 'alias', label: gettext('Alias'), cell: 'string',
          type: 'text', mode: ['properties'],
          disabled: 'inSchema'
        }, pgBrowser.SecurityGroupSchema, {
          id: 'type_acl', label: gettext('Privileges'), cell: 'string',
          type: 'text', mode: ['properties'], group: 'security',
          disabled: 'inSchema'
        }, {
          id: 'member_list', label: gettext('Members'), cell: 'string',
          type: 'text', mode: ['properties'], group: gettext('Definition'),
          disabled: 'inSchema', visible: function visible(m) {
            if (m.get('typtype') === 'c') {
              return true;
            }
            return false;
          }
        }, {
          id: 'enum_list', label: gettext('Labels'), cell: 'string',
          type: 'text', mode: ['properties'], group: gettext('Definition'),
          disabled: 'inSchema', visible: function visible(m) {
            if (m.get('typtype') === 'e') {
              return true;
            }
            return false;
          }
        }, {
          id: 'is_sys_type', label: gettext('System type?'), cell: 'switch',
          type: 'switch', mode: ['properties'],
          disabled: 'inSchema'
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline', mode: ['properties', 'create', 'edit'],
          disabled: 'inSchema'
        }, {
          id: 'typacl', label: gettext('Privileges'), type: 'collection',
          group: 'security', control: 'unique-col-collection',
          model: pgBrowser.Node.PrivilegeRoleModel.extend({
            privileges: ['U']
          }),
          mode: ['edit', 'create'], canDelete: true,
          uniqueCol: ['grantee'], deps: ['typtype'],
          canAdd: function canAdd(m) {
            // Do not allow to add when shell type is selected
            // Clear acl & security label collections as well
            if (m.get('typtype') === 'p') {
              var acl = m.get('typacl');
              if (acl.length > 0) acl.reset();
            }
            return !(m.get('typtype') === 'p');
          }
        }, {
          id: 'seclabels', label: gettext('Security Labels'),
          model: pgBrowser.SecLabelModel, editable: false, type: 'collection',
          group: 'security', mode: ['edit', 'create'],
          min_version: 90100, canEdit: false, canDelete: true,
          control: 'unique-col-collection', deps: ['typtype'],
          canAdd: function canAdd(m) {
            // Do not allow to add when shell type is selected
            // Clear acl & security label collections as well
            if (m.get('typtype') === 'p') {
              var secLabs = m.get('seclabels');
              if (secLabs.length > 0) secLabs.reset();
            }
            return !(m.get('typtype') === 'p');
          }
        }],
        validate: function validate() {
          // Validation code for required fields
          var changedAttrs = this.sessAttrs,
              msg = undefined;

          this.errorModel.clear();

          if (_.isUndefined(this.get('name')) || _.isNull(this.get('name')) || String(this.get('name')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Name cannot be empty.');
            this.errorModel.set('name', msg);
            return msg;
          }

          if (_.isUndefined(this.get('schema')) || _.isNull(this.get('schema')) || String(this.get('schema')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Schema cannot be empty.');
            this.errorModel.set('schema', msg);
            return msg;
          }

          if (_.isUndefined(this.get('typtype')) || _.isNull(this.get('typtype')) || String(this.get('typtype')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Type cannot be empty.');
            this.errorModel.set('typtype', msg);
            return msg;
          }

          // For Range
          if (this.get('typtype') == 'r') {
            if (_.isUndefined(this.get('typname')) || _.isNull(this.get('typname')) || String(this.get('typname')).replace(/^\s+|\s+$/g, '') == '') {
              msg = gettext('Subtype name cannot be empty.');
              this.errorModel.set('typname', msg);
              return msg;
            }
          }

          // For External
          if (this.get('typtype') == 'b') {
            if (_.isUndefined(this.get('typinput')) || _.isNull(this.get('typinput')) || String(this.get('typinput')).replace(/^\s+|\s+$/g, '') == '') {
              msg = gettext('Input function cannot be empty.');
              this.errorModel.set('typinput', msg);
              return msg;
            }
            if (_.isUndefined(this.get('typoutput')) || _.isNull(this.get('typoutput')) || String(this.get('typoutput')).replace(/^\s+|\s+$/g, '') == '') {
              msg = gettext('Output function cannot be empty.');
              this.errorModel.set('typoutput', msg);
              return msg;
            }
          }

          return null;
        },
        // We will disable everything if we are under catalog node
        inSchema: function inSchema() {
          if (this.node_info && 'catalog' in this.node_info) {
            return true;
          }
          return false;
        },
        schemaCheck: function schemaCheck(m) {
          if (this.node_info && 'schema' in this.node_info) {
            if (m.isNew()) {
              return false;
            } else {
              return m.get('typtype') === 'p';
            }
          }
          return true;
        },
        // We will check if we are under schema node & in 'create' mode
        inSchemaWithModelCheck: function inSchemaWithModelCheck(m) {
          if (this.node_info && 'schema' in this.node_info) {
            // We will disbale control if it's in 'edit' mode
            if (m.isNew()) {
              return false;
            } else {
              return true;
            }
          }
          return true;
        },
        // We want to enable only in edit mode
        inSchemaWithEditMode: function inSchemaWithEditMode(m) {
          if (this.node_info && 'schema' in this.node_info) {
            // We will disbale control if it's in 'edit' mode
            if (m.isNew()) {
              return true;
            } else {
              return false;
            }
          }
          return true;
        },
        // Function will help us to fill combobox
        external_func_combo: function external_func_combo(d) {
          var result = [];
          _.each(d, function (item) {
            // if type from selected from combobox matches in options
            if (item.cbtype == 'all') {
              result.push(item);
            }
          });
          return result;
        }
      }),
      canCreate: function canCreate(itemData, item, data) {
        //If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        // To iterate over tree to check parent node
        while (i) {
          // If it is schema then allow user to create table
          if (_.indexOf(['schema'], d._type) > -1) return true;

          if ('coll-type' == d._type) {
            //Check if we are not child of catalog
            var prev_i = t.hasParent(i) ? t.parent(i) : null,
                prev_d = prev_i ? t.itemData(prev_i) : null;
            if (prev_d._type == 'catalog') {
              return false;
            } else {
              return true;
            }
          }
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // by default we do not want to allow create menu
        return true;
      }
    });
  }
  return pgBrowser.Nodes['type'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backgrid, Backbone) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(16), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, Backform, alertify) {

  if (!pgBrowser.Nodes['coll-index']) {
    var databases = pgAdmin.Browser.Nodes['coll-index'] = pgAdmin.Browser.Collection.extend({
      node: 'index',
      label: gettext('Indexes'),
      type: 'coll-index',
      getTreeNodeHierarchy: pgBrowser.tableChildTreeNodeHierarchy,
      sqlAlterHelp: 'sql-alterindex.html',
      sqlCreateHelp: 'sql-createindex.html',
      dialogHelp: url_for('help.static', { 'filename': 'index_dialog.html' }),
      columns: ['name', 'description'],
      hasStatistics: true,
      statsPrettifyFields: ['Size', 'Index size']
    });
  };

  // Node-Ajax-Cell with Deps
  var NodeAjaxOptionsDepsCell = Backgrid.Extension.NodeAjaxOptionsCell.extend({
    initialize: function initialize() {
      Backgrid.Extension.NodeAjaxOptionsCell.prototype.initialize.apply(this, arguments);
      Backgrid.Extension.DependentCell.prototype.initialize.apply(this, arguments);
    },
    dependentChanged: function dependentChanged() {
      var model = this.model,
          column = this.column,
          editable = this.column.get("editable"),
          input = this.$el.find('select').first();

      var is_editable = _.isFunction(editable) ? !!editable.apply(column, [model]) : !!editable;
      if (is_editable) {
        this.$el.addClass("editable");
        input.prop('disabled', false);
      } else {
        this.$el.removeClass("editable");
        input.prop('disabled', true);
      }

      this.delegateEvents();
      return this;
    },
    remove: Backgrid.Extension.DependentCell.prototype.remove
  });

  // Model to create column collection control
  var ColumnModel = pgAdmin.Browser.Node.Model.extend({
    defaults: {
      colname: undefined,
      collspcname: undefined,
      op_class: undefined,
      sort_order: false,
      nulls: false,
      is_sort_nulls_applicable: true
    },
    schema: [{
      id: 'colname', label: gettext('Column'), cell: 'node-list-by-name',
      type: 'text', disabled: 'inSchemaWithModelCheck', editable: function editable(m) {
        // Header cell then skip
        if (m instanceof Backbone.Collection) {
          return false;
        }
        return !m.inSchemaWithModelCheck.apply(this, arguments);
      },
      control: 'node-list-by-name', node: 'column'
    }, {
      id: 'collspcname', label: gettext('Collation'),
      cell: NodeAjaxOptionsDepsCell,
      type: 'text', disabled: 'inSchemaWithModelCheck', editable: function editable(m) {
        // Header cell then skip
        if (m instanceof Backbone.Collection) {
          return false;
        }
        return !m.inSchemaWithModelCheck.apply(this, arguments);
      },
      control: 'node-ajax-options', url: 'get_collations', node: 'index'
    }, {
      id: 'op_class', label: gettext('Operator class'),
      cell: NodeAjaxOptionsDepsCell, tags: true,
      type: 'text', disabled: 'checkAccessMethod',
      editable: function editable(m) {
        // Header cell then skip
        if (m instanceof Backbone.Collection) {
          return false;
        } else if (m.inSchemaWithModelCheck.apply(this, arguments)) {
          return false;
        }
        return !m.checkAccessMethod.apply(this, arguments);
      },
      control: 'node-ajax-options', url: 'get_op_class', node: 'index',
      deps: ['amname'], transform: function transform(data, control) {
        /* We need to extract data from collection according
         * to access method selected by user if not selected
         * send btree related op_class options
         */
        var amname = control.model.top.get('amname'),
            options = data['btree'];

        if (_.isUndefined(amname)) return options;

        _.each(data, function (v, k) {
          if (amname === k) {
            options = v;
          }
        });
        return options;
      }
    }, {
      id: 'sort_order', label: gettext('Sort order'),
      cell: Backgrid.Extension.TableChildSwitchCell, type: 'switch',
      editable: function editable(m) {
        // Header cell then skip
        if (m instanceof Backbone.Collection) {
          return false;
        } else if (m.inSchemaWithModelCheck.apply(this, arguments)) {
          return false;
        } else if (m.top.get('amname') === 'btree') {
          m.set('is_sort_nulls_applicable', true);
          return true;
        } else {
          m.set('is_sort_nulls_applicable', false);
          return false;
        }
      },
      deps: ['amname'],
      options: {
        'onText': 'DESC', 'offText': 'ASC',
        'onColor': 'success', 'offColor': 'primary',
        'size': 'small'
      }
    }, {
      id: 'nulls', label: gettext('NULLs'),
      cell: Backgrid.Extension.TableChildSwitchCell, type: 'switch',
      editable: function editable(m) {
        // Header cell then skip
        if (m instanceof Backbone.Collection) {
          return false;
        } else if (m.inSchemaWithModelCheck.apply(this, arguments)) {
          return false;
        } else if (m.top.get('amname') === 'btree') {
          m.set('is_sort_nulls_applicable', true);
          return true;
        } else {
          m.set('is_sort_nulls_applicable', false);
          return false;
        }
      },
      deps: ['amname', 'sort_order'],
      options: {
        'onText': 'FIRST', 'offText': 'LAST',
        'onColor': 'success', 'offColor': 'primary',
        'size': 'small'
      }
    }],
    validate: function validate() {
      this.errorModel.clear();

      if (_.isUndefined(this.get('colname')) || String(this.get('colname')).replace(/^\s+|\s+$/g, '') == '') {
        var msg = gettext('Column Name cannot be empty.');
        this.errorModel.set('colname', msg);
        return msg;
      }
    },
    // We will check if we are under schema node
    inSchema: function inSchema() {
      if (this.node_info && 'catalog' in this.node_info) {
        return true;
      }
      return false;
    },
    // We will check if we are under schema node & in 'create' mode
    inSchemaWithModelCheck: function inSchemaWithModelCheck(m) {
      if (m.top.node_info && 'schema' in m.top.node_info) {
        // We will disable control if it's in 'edit' mode
        if (m.top.isNew()) {
          return false;
        } else {
          return true;
        }
      }
      return true;
    },
    // We will check if we are under schema node and added condition
    checkAccessMethod: function checkAccessMethod(m) {
      //Access method is empty or btree then do not disable field
      var parent_model = m.top;
      if (_.isUndefined(parent_model.get('amname')) || _.isNull(parent_model.get('amname')) || String(parent_model.get('amname')).replace(/^\s+|\s+$/g, '') == '' || parent_model.get('amname') === 'btree') {
        // We need to set nulls to true if sort_order is set to desc
        // nulls first is default for desc
        if (m.get('sort_order') == true && m.previous('sort_order') == false) {
          setTimeout(function () {
            m.set('nulls', true);
          }, 10);
        }
      } else {
        m.set('is_sort_nulls_applicable', false);
      }
      return false;
    }
  });

  if (!pgBrowser.Nodes['index']) {
    pgAdmin.Browser.Nodes['index'] = pgBrowser.Node.extend({
      getTreeNodeHierarchy: pgBrowser.tableChildTreeNodeHierarchy,
      parent_type: ['table', 'view', 'mview', 'partition'],
      collection_type: ['coll-table', 'coll-view'],
      sqlAlterHelp: 'sql-alterindex.html',
      sqlCreateHelp: 'sql-createindex.html',
      type: 'index',
      label: gettext('Index'),
      hasSQL: true,
      hasDepends: true,
      hasStatistics: true,
      statsPrettifyFields: ['Size', 'Index size'],
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_index_on_coll', node: 'coll-index', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Index...'),
          icon: 'wcTabIcon icon-index', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_index', node: 'index', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Index...'),
          icon: 'wcTabIcon icon-index', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_index_onTable', node: 'table', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Index...'),
          icon: 'wcTabIcon icon-index', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_index_onPartition', node: 'partition', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Index...'),
          icon: 'wcTabIcon icon-index', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_index_onMatView', node: 'mview', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 5, label: gettext('Index...'),
          icon: 'wcTabIcon icon-index', data: { action: 'create', check: true },
          enable: 'canCreate'
        }]);
      },
      canDrop: pgBrowser.Nodes['schema'].canChildDrop,
      canDropCascade: pgBrowser.Nodes['schema'].canChildDrop,
      model: pgAdmin.Browser.Node.Model.extend({
        idAttribute: 'oid',

        defaults: {
          name: undefined,
          oid: undefined,
          nspname: undefined,
          tabname: undefined,
          spcname: undefined,
          amname: 'btree'
        },
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', disabled: 'inSchema'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'int', disabled: true, mode: ['edit', 'properties']
        }, {
          id: 'spcname', label: gettext('Tablespace'), cell: 'string',
          control: 'node-list-by-name', node: 'tablespace',
          select2: { 'allowClear': true },
          type: 'text', mode: ['properties', 'create', 'edit'],
          disabled: 'inSchema', filter: function filter(d) {
            // If tablespace name is not "pg_global" then we need to exclude them
            if (d && d.label.match(/pg_global/)) {
              return false;
            }
            return true;
          }
        }, {
          id: 'amname', label: gettext('Access Method'), cell: 'string',
          type: 'text', mode: ['properties', 'create', 'edit'],
          disabled: 'inSchemaWithModelCheck', url: 'get_access_methods',
          group: gettext('Definition'), select2: { 'allowClear': true },
          control: Backform.NodeAjaxOptionsControl.extend({
            // When access method changes we need to clear columns collection
            onChange: function onChange() {
              Backform.NodeAjaxOptionsControl.prototype.onChange.apply(this, arguments);
              var self = this,

              // current access method
              current_am = self.model.get('amname'),

              // previous access method
              previous_am = self.model.previous('amname');
              if (current_am != previous_am && self.model.get('columns').length !== 0) {
                var msg = gettext('Changing access method will clear columns collection');
                alertify.confirm(msg, function (e) {
                  // User clicks Ok, lets clear collection
                  var column_collection = self.model.get('columns'),
                      col_length = column_collection.length;
                  for (var i = col_length - 1; i >= 0; i--) {
                    column_collection.remove(column_collection.models[i]);
                  }
                }, function () {
                  // User clicks Cancel set previous value again in combo box
                  setTimeout(function () {
                    self.model.set('amname', previous_am);
                  }, 10);
                });
              }
            }
          })
        }, {
          id: 'cols', label: gettext('Columns'), cell: 'string',
          type: 'text', disabled: 'inSchema', mode: ['properties'],
          group: gettext('Definition')
        }, {
          id: 'fillfactor', label: gettext('Fill factor'), cell: 'string',
          type: 'int', disabled: 'inSchema', mode: ['create', 'edit', 'properties'],
          min: 10, max: 100, group: gettext('Definition')
        }, {
          id: 'indisunique', label: gettext('Unique?'), cell: 'string',
          type: 'switch', disabled: 'inSchemaWithModelCheck',
          group: gettext('Definition')
        }, {
          id: 'indisclustered', label: gettext('Clustered?'), cell: 'string',
          type: 'switch', disabled: 'inSchema',
          group: gettext('Definition')
        }, {
          id: 'indisvalid', label: gettext('Valid?'), cell: 'string',
          type: 'switch', disabled: true, mode: ['properties'],
          group: gettext('Definition')
        }, {
          id: 'indisprimary', label: gettext('Primary?'), cell: 'string',
          type: 'switch', disabled: true, mode: ['properties'],
          group: gettext('Definition')
        }, {
          id: 'is_sys_idx', label: gettext('System index?'), cell: 'string',
          type: 'switch', disabled: true, mode: ['properties']
        }, {
          id: 'isconcurrent', label: gettext('Concurrent build?'), cell: 'string',
          type: 'switch', disabled: 'inSchemaWithModelCheck',
          mode: ['create', 'edit'], group: gettext('Definition')
        }, {
          id: 'indconstraint', label: gettext('Constraint'), cell: 'string',
          type: 'text', disabled: 'inSchemaWithModelCheck', mode: ['create', 'edit'],
          control: 'sql-field', visible: true, group: gettext('Definition')
        }, {
          id: 'columns', label: 'Columns', type: 'collection', deps: ['amname'],
          group: gettext('Definition'), model: ColumnModel, mode: ['edit', 'create'],
          canAdd: function canAdd(m) {
            // We will disable it if it's in 'edit' mode
            if (m.isNew()) {
              return true;
            } else {
              return false;
            }
          },
          canEdit: false,
          canDelete: function canDelete(m) {
            // We will disable it if it's in 'edit' mode
            if (m.isNew()) {
              return true;
            } else {
              return false;
            }
          },
          control: 'unique-col-collection', uniqueCol: ['colname'],
          columns: ['colname', 'op_class', 'sort_order', 'nulls', 'collspcname']
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline', mode: ['properties', 'create', 'edit'],
          disabled: 'inSchema'
        }],
        validate: function validate(keys) {
          var err = {},
              changedAttrs = this.changed,
              msg = undefined;

          // Nothing to validate
          if (keys && keys.length == 0) {
            this.errorModel.clear();
            return null;
          } else {
            this.errorModel.clear();
          }

          if (_.isUndefined(this.get('name')) || String(this.get('name')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Name cannot be empty.');
            this.errorModel.set('name', msg);
            return msg;
          }
          if (_.isUndefined(this.get('spcname')) || String(this.get('spcname')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Tablespace cannot be empty.');
            this.errorModel.set('spcname', msg);
            return msg;
          }
          if (_.isUndefined(this.get('amname')) || String(this.get('amname')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Access method cannot be empty.');
            this.errorModel.set('amname', msg);
            return msg;
          }
          // Checks if all columns has names
          var cols = this.get('columns');
          if (cols && cols.length > 0) {
            if (!_.every(cols.pluck('colname'))) {
              msg = gettext('You must specify column name.');
              this.errorModel.set('columns', msg);
              return msg;
            }
          } else if (cols) {
            msg = gettext('You must specify at least one column.');
            this.errorModel.set('columns', msg);
            return msg;
          }
          return null;
        },
        // We will check if we are under schema node & in 'create' mode
        inSchema: function inSchema() {
          if (this.node_info && 'catalog' in this.node_info) {
            return true;
          }
          return false;
        },
        // We will check if we are under schema node & in 'create' mode
        inSchemaWithModelCheck: function inSchemaWithModelCheck(m) {
          if (this.node_info && 'schema' in this.node_info) {
            // We will disable control if it's in 'edit' mode
            if (m.isNew()) {
              return false;
            } else {
              return true;
            }
          }
          return true;
        },
        // Checks weather to enable/disable control
        inSchemaWithColumnCheck: function inSchemaWithColumnCheck(m) {
          if (this.node_info && 'schema' in this.node_info) {
            // We will disable control if it's system columns
            // ie: it's position is less then 1
            if (m.isNew()) {
              return false;
            } else {
              // if we are in edit mode
              if (!_.isUndefined(m.get('attnum')) && m.get('attnum') >= 1) {
                return false;
              } else {
                return true;
              }
            }
          }
          return true;
        }
      }),
      // Below function will enable right click menu for creating column
      canCreate: function canCreate(itemData, item, data) {
        // If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData,
            parents = [],
            immediate_parent_table_found = false,
            is_immediate_parent_table_partitioned = false;
        // To iterate over tree to check parent node
        while (i) {
          // Do not allow creating index on partitioned tables.
          if (!immediate_parent_table_found && _.indexOf(['table', 'partition'], d._type) > -1) {
            immediate_parent_table_found = true;
            if ('is_partitioned' in d && d.is_partitioned) {
              is_immediate_parent_table_partitioned = true;
            }
          }

          // If it is schema then allow user to create index
          if (_.indexOf(['schema'], d._type) > -1) return !is_immediate_parent_table_partitioned;
          parents.push(d._type);
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // If node is under catalog then do not allow 'create' menu
        if (_.indexOf(parents, 'catalog') > -1) {
          return false;
        } else {
          return !is_immediate_parent_table_partitioned;
        }
      }
    });
  }

  return pgBrowser.Nodes['index'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13), __webpack_require__(10)))

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(16), __webpack_require__(17), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, Backform, alertify) {

  var CustomSwitchControl = Backform.CustomSwitchControl = Backform.SwitchControl.extend({
    template: _.template(['<label class="<%=Backform.controlLabelClassName%> custom_switch_label_class"><%=label%></label>', '<div class="<%=Backform.controlsClassName%> custom_switch_control_class">', '  <div class="checkbox">', '    <label>', '      <input type="checkbox" class="<%=extraClasses.join(\' \')%>"', '        name="<%=name%>" <%=value ? "checked=\'checked\'" : ""%>', '        <%=disabled ? "disabled" : ""%> <%=required ? "required" : ""%> />', '    </label>', '  </div>', '</div>', '<% if (helpMessage && helpMessage.length) { %>', '  <span class="<%=Backform.helpMessageClassName%>"><%=helpMessage%></span>', '<% } %>'].join("\n")),
    className: 'pgadmin-control-group form-group col-xs-6'
  });

  if (!pgBrowser.Nodes['coll-trigger']) {
    var triggers = pgAdmin.Browser.Nodes['coll-trigger'] = pgAdmin.Browser.Collection.extend({
      node: 'trigger',
      label: gettext('Triggers'),
      type: 'coll-trigger',
      getTreeNodeHierarchy: pgBrowser.tableChildTreeNodeHierarchy,
      columns: ['name', 'description']
    });
  };

  if (!pgBrowser.Nodes['trigger']) {
    pgAdmin.Browser.Nodes['trigger'] = pgBrowser.Node.extend({
      getTreeNodeHierarchy: pgBrowser.tableChildTreeNodeHierarchy,
      parent_type: ['table', 'view', 'partition'],
      collection_type: ['coll-table', 'coll-view'],
      type: 'trigger',
      label: gettext('Trigger'),
      hasSQL: true,
      hasDepends: true,
      width: '650px',
      sqlAlterHelp: 'sql-altertrigger.html',
      sqlCreateHelp: 'sql-createtrigger.html',
      dialogHelp: url_for('help.static', { 'filename': 'trigger_dialog.html' }),
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_trigger_on_coll', node: 'coll-trigger', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Trigger...'),
          icon: 'wcTabIcon icon-trigger', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_trigger', node: 'trigger', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Trigger...'),
          icon: 'wcTabIcon icon-trigger', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_trigger_onTable', node: 'table', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Trigger...'),
          icon: 'wcTabIcon icon-trigger', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_trigger_onPartition', node: 'partition', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Trigger...'),
          icon: 'wcTabIcon icon-trigger', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'enable_trigger', node: 'trigger', module: this,
          applies: ['object', 'context'], callback: 'enable_trigger',
          category: 'connect', priority: 3, label: gettext('Enable trigger'),
          icon: 'fa fa-check', enable: 'canCreate_with_trigger_enable'
        }, {
          name: 'disable_trigger', node: 'trigger', module: this,
          applies: ['object', 'context'], callback: 'disable_trigger',
          category: 'drop', priority: 3, label: gettext('Disable trigger'),
          icon: 'fa fa-times', enable: 'canCreate_with_trigger_disable'
        }, {
          name: 'create_trigger_onView', node: 'view', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Trigger...'),
          icon: 'wcTabIcon icon-trigger', data: { action: 'create', check: true },
          enable: 'canCreate'
        }]);
      },
      callbacks: {
        /* Enable trigger */
        enable_trigger: function enable_trigger(args) {
          var input = args || {};
          obj = this, t = pgBrowser.tree, i = input.item || t.selected(), d = i && i.length == 1 ? t.itemData(i) : undefined;

          if (!d) return false;

          var data = d;
          $.ajax({
            url: obj.generate_url(i, 'enable', d, true),
            type: 'PUT',
            data: { 'enable': true },
            dataType: "json",
            success: function success(res) {
              if (res.success == 1) {
                alertify.success(res.info);
                t.removeIcon(i);
                data.icon = 'icon-trigger';
                t.addIcon(i, { icon: data.icon });
                t.unload(i);
                t.setInode(i);
                t.deselect(i);
                // Fetch updated data from server
                setTimeout(function () {
                  t.select(i);
                }, 10);
              }
            },
            error: function error(xhr, status, _error) {
              try {
                var err = $.parseJSON(xhr.responseText);
                if (err.success == 0) {
                  alertify.error(err.errormsg);
                }
              } catch (e) {}
              t.unload(i);
            }
          });
        },
        /* Disable trigger */
        disable_trigger: function disable_trigger(args) {
          var input = args || {};
          obj = this, t = pgBrowser.tree, i = input.item || t.selected(), d = i && i.length == 1 ? t.itemData(i) : undefined;

          if (!d) return false;

          var data = d;
          $.ajax({
            url: obj.generate_url(i, 'enable', d, true),
            type: 'PUT',
            data: { 'enable': false },
            dataType: "json",
            success: function success(res) {
              if (res.success == 1) {
                alertify.success(res.info);
                t.removeIcon(i);
                data.icon = 'icon-trigger-bad';
                t.addIcon(i, { icon: data.icon });
                t.unload(i);
                t.setInode(i);
                t.deselect(i);
                // Fetch updated data from server
                setTimeout(function () {
                  t.select(i);
                }, 10);
              }
            },
            error: function error(xhr, status, _error2) {
              try {
                var err = $.parseJSON(xhr.responseText);
                if (err.success == 0) {
                  alertify.error(err.errormsg);
                }
              } catch (e) {}
              t.unload(i);
            }
          });
        }
      },
      canDrop: pgBrowser.Nodes['schema'].canChildDrop,
      canDropCascade: pgBrowser.Nodes['schema'].canChildDrop,
      model: pgAdmin.Browser.Node.Model.extend({
        defaults: {
          name: undefined,
          is_row_trigger: true,
          fires: 'BEFORE'
        },
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', disabled: 'inSchema'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'int', disabled: true, mode: ['properties']
        }, {
          id: 'is_enable_trigger', label: gettext('Trigger enabled?'),
          type: 'switch', disabled: 'inSchema', mode: ['edit', 'properties'],
          group: gettext('Definition')
        }, {
          id: 'is_row_trigger', label: gettext('Row trigger?'),
          type: 'switch', group: gettext('Definition'),
          mode: ['create', 'edit', 'properties'],
          deps: ['is_constraint_trigger'],
          disabled: function disabled(m) {
            // Disabled if table is a partitioned table.
            if (_.has(m, 'node_info') && _.has(m.node_info, 'table') && _.has(m.node_info.table, 'is_partitioned') && m.node_info.table.is_partitioned) {
              setTimeout(function () {
                m.set('is_row_trigger', false);
              }, 10);

              return true;
            }

            // If constraint trigger is set to True then row trigger will
            // automatically set to True and becomes disable
            var is_constraint_trigger = m.get('is_constraint_trigger');
            if (!m.inSchemaWithModelCheck.apply(this, [m])) {
              if (!_.isUndefined(is_constraint_trigger) && is_constraint_trigger === true) {
                // change it's model value
                setTimeout(function () {
                  m.set('is_row_trigger', true);
                }, 10);
                return true;
              } else {
                return false;
              }
            } else {
              // Check if it is row trigger then enabled it.
              var is_row_trigger = m.get('is_row_trigger');
              if (!_.isUndefined(is_row_trigger) && m.node_info['server']['server_type'] == 'ppas') {
                return false;
              }
              // Disable it
              return true;
            }
          }
        }, _defineProperty({
          id: 'is_constraint_trigger', label: gettext('Constraint trigger?'),
          type: 'switch', disabled: 'inSchemaWithModelCheck',
          mode: ['create', 'edit', 'properties'],
          group: gettext('Definition')
        }, 'disabled', function disabled(m) {
          // Disabled if table is a partitioned table.
          if (_.has(m, 'node_info') && _.has(m.node_info, 'table') && _.has(m.node_info.table, 'is_partitioned') && m.node_info.table.is_partitioned) {
            setTimeout(function () {
              m.set('is_constraint_trigger', false);
            }, 10);

            return true;
          }
        }), {
          id: 'tgdeferrable', label: gettext('Deferrable?'),
          type: 'switch', group: gettext('Definition'),
          mode: ['create', 'edit', 'properties'],
          deps: ['is_constraint_trigger'],
          disabled: function disabled(m) {
            // If constraint trigger is set to True then only enable it
            var is_constraint_trigger = m.get('is_constraint_trigger');
            if (!m.inSchemaWithModelCheck.apply(this, [m])) {
              if (!_.isUndefined(is_constraint_trigger) && is_constraint_trigger === true) {
                return false;
              } else {
                // If value is already set then reset it to false
                if (m.get('tgdeferrable')) {
                  setTimeout(function () {
                    m.set('tgdeferrable', false);
                  }, 10);
                }
                return true;
              }
            } else {
              // Disable it
              return true;
            }
          }
        }, {
          id: 'tginitdeferred', label: gettext('Deferred?'),
          type: 'switch', group: gettext('Definition'),
          mode: ['create', 'edit', 'properties'],
          deps: ['tgdeferrable', 'is_constraint_trigger'],
          disabled: function disabled(m) {
            // If Deferrable is set to True then only enable it
            var tgdeferrable = m.get('tgdeferrable');
            if (!m.inSchemaWithModelCheck.apply(this, [m])) {
              if (!_.isUndefined(tgdeferrable) && tgdeferrable) {
                return false;
              } else {
                // If value is already set then reset it to false
                if (m.get('tginitdeferred')) {
                  setTimeout(function () {
                    m.set('tginitdeferred', false);
                  }, 10);
                }
                // If constraint trigger is set then do not disable
                return m.get('is_constraint_trigger') ? false : true;
              }
            } else {
              // Disable it
              return true;
            }
          }
        }, {
          id: 'tfunction', label: gettext('Trigger Function'),
          type: 'text', disabled: 'inSchemaWithModelCheck',
          mode: ['create', 'edit', 'properties'], group: gettext('Definition'),
          control: 'node-ajax-options', url: 'get_triggerfunctions',
          cache_node: 'trigger_function'
        }, {
          id: 'tgargs', label: gettext('Arguments'), cell: 'string',
          group: gettext('Definition'),
          type: 'text', mode: ['create', 'edit', 'properties'], deps: ['tfunction'],
          disabled: function disabled(m) {
            // We will disable it when EDB PPAS and trigger function is
            // set to Inline EDB-SPL
            var tfunction = m.get('tfunction'),
                server_type = m.node_info['server']['server_type'];
            if (!m.inSchemaWithModelCheck.apply(this, [m])) {
              if (server_type === 'ppas' && !_.isUndefined(tfunction) && tfunction === 'Inline EDB-SPL') {
                // Disable and clear its value
                m.set('tgargs', undefined);
                return true;
              } else {
                return false;
              }
            } else {
              // Disable it
              return true;
            }
          }
        }, {
          id: 'fires', label: gettext('Fires'), deps: ['is_constraint_trigger'],
          mode: ['create', 'edit', 'properties'], group: gettext('Events'),
          options: function options(control) {
            var table_options = [{ label: "BEFORE", value: "BEFORE" }, { label: "AFTER", value: "AFTER" }],
                view_options = [{ label: "BEFORE", value: "BEFORE" }, { label: "AFTER", value: "AFTER" }, { label: "INSTEAD OF", value: "INSTEAD OF" }];
            // If we are under table then show table specific options
            if (_.indexOf(Object.keys(control.model.node_info), 'table') != -1) {
              return table_options;
            } else {
              return view_options;
            }
          },
          // If create mode then by default open composite type
          control: 'select2', select2: { allowClear: false, width: "100%" },
          disabled: function disabled(m) {
            // If contraint trigger is set to True then only enable it
            var is_constraint_trigger = m.get('is_constraint_trigger');
            if (!m.inSchemaWithModelCheck.apply(this, [m])) {
              if (!_.isUndefined(is_constraint_trigger) && is_constraint_trigger === true) {
                setTimeout(function () {
                  m.set('fires', 'AFTER');
                }, 10);
                return true;
              } else {
                return false;
              }
            } else {
              // Check if it is row trigger then enabled it.
              var fires_ = m.get('fires');
              if (!_.isUndefined(fires_) && m.node_info['server']['server_type'] == 'ppas') {
                return false;
              }
              // Disable it
              return true;
            }
          }
        }, {
          type: 'nested', control: 'fieldset', mode: ['create', 'edit', 'properties'],
          label: gettext('Events'), group: gettext('Events'),
          schema: [{
            id: 'evnt_insert', label: gettext('INSERT'),
            type: 'switch', mode: ['create', 'edit', 'properties'],
            group: gettext('Events'),
            control: Backform.CustomSwitchControl,
            disabled: function disabled(m) {
              var evn_insert = m.get('evnt_insert');
              if (!_.isUndefined(evn_insert) && m.node_info['server']['server_type'] == 'ppas') return false;
              return m.inSchemaWithModelCheck.apply(this, [m]);
            }
          }, {
            id: 'evnt_update', label: gettext('UPDATE'),
            type: 'switch', mode: ['create', 'edit', 'properties'],
            group: gettext('Events'),
            control: Backform.CustomSwitchControl,
            disabled: function disabled(m) {
              var evn_update = m.get('evnt_update');
              if (!_.isUndefined(evn_update) && m.node_info['server']['server_type'] == 'ppas') return false;
              return m.inSchemaWithModelCheck.apply(this, [m]);
            }
          }, {
            id: 'evnt_delete', label: gettext('DELETE'),
            type: 'switch', mode: ['create', 'edit', 'properties'],
            group: gettext('Events'),
            control: Backform.CustomSwitchControl,
            disabled: function disabled(m) {
              var evn_delete = m.get('evnt_delete');
              if (!_.isUndefined(evn_delete) && m.node_info['server']['server_type'] == 'ppas') return false;
              return m.inSchemaWithModelCheck.apply(this, [m]);
            }
          }, {
            id: 'evnt_truncate', label: gettext('TRUNCATE'),
            type: 'switch', group: gettext('Events'),
            control: Backform.CustomSwitchControl,
            disabled: function disabled(m) {
              var is_constraint_trigger = m.get('is_constraint_trigger'),
                  is_row_trigger = m.get('is_row_trigger'),
                  server_type = m.node_info['server']['server_type'];
              if (!m.inSchemaWithModelCheck.apply(this, [m])) {
                // We will enabale truncate only for EDB PPAS
                // and both triggers row & constarint are set to false
                if (server_type === 'ppas' && !_.isUndefined(is_constraint_trigger) && !_.isUndefined(is_row_trigger) && is_constraint_trigger === false && is_row_trigger === false) {
                  return false;
                } else {
                  return true;
                }
              } else {
                // Disable it
                return true;
              }
            }
          }]
        }, {
          id: 'whenclause', label: gettext('When'),
          type: 'text', disabled: 'inSchemaWithModelCheck',
          mode: ['create', 'edit', 'properties'],
          control: 'sql-field', visible: true, group: gettext('Events')
        }, {
          id: 'columns', label: gettext('Columns'), url: 'nodes',
          control: 'node-list-by-name', cache_node: 'column', type: 'array',
          select2: { 'multiple': true },
          deps: ['evnt_update'], node: 'column', group: gettext('Events'),
          disabled: function disabled(m) {
            if (this.node_info && 'catalog' in this.node_info) {
              return true;
            }
            //Disable in edit mode
            if (!m.isNew()) {
              return true;
            }
            // Enable column only if update event is set true
            var isUpdate = m.get('evnt_update');
            if (!_.isUndefined(isUpdate) && isUpdate) {
              return false;
            }
            return true;
          }
        }, {
          id: 'prosrc', label: gettext('Code'), group: gettext('Code'),
          type: 'text', mode: ['create', 'edit'], deps: ['tfunction'],
          control: 'sql-field', visible: true,
          disabled: function disabled(m) {
            // We will enable it only when EDB PPAS and trigger function is
            // set to Inline EDB-SPL
            var tfunction = m.get('tfunction'),
                server_type = m.node_info['server']['server_type'];

            if (server_type === 'ppas' && !_.isUndefined(tfunction) && tfunction === 'Inline EDB-SPL') return false;else return true;
          }
        }, {
          id: 'is_sys_trigger', label: gettext('System trigger?'), cell: 'string',
          type: 'switch', disabled: 'inSchemaWithModelCheck', mode: ['properties']
        }, {
          id: 'is_constarint', label: gettext('Constraint?'), cell: 'string',
          type: 'switch', disabled: 'inSchemaWithModelCheck', mode: ['properties'],
          group: gettext('Definition')
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline', mode: ['properties', 'create', 'edit'],
          disabled: 'inSchema'
        }],
        validate: function validate(keys) {
          var err = {},
              msg = undefined;
          this.errorModel.clear();

          // If nothing to validate
          if (keys && keys.length == 0) {
            return null;
          }

          if (_.isUndefined(this.get('name')) || String(this.get('name')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Name cannot be empty.');
            this.errorModel.set('name', msg);
            return msg;
          }
          if (_.isUndefined(this.get('tfunction')) || String(this.get('tfunction')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Trigger function cannot be empty.');
            this.errorModel.set('tfunction', msg);
            return msg;
          }

          if (!this.get('evnt_truncate') && !this.get('evnt_delete') && !this.get('evnt_update') && !this.get('evnt_insert')) {
            msg = gettext('Specify at least one event.');
            this.errorModel.set('evnt_truncate', " ");
            this.errorModel.set('evnt_delete', " ");
            this.errorModel.set('evnt_update', " ");
            this.errorModel.set('evnt_insert', msg);
            return msg;
          }

          if (!_.isUndefined(this.get('tfunction')) && this.get('tfunction') === 'Inline EDB-SPL' && (_.isUndefined(this.get('prosrc')) || String(this.get('prosrc')).replace(/^\s+|\s+$/g, '') == '')) {
            msg = gettext('Trigger code cannot be empty.');
            this.errorModel.set('prosrc', msg);
            return msg;
          }
          return null;
        },
        // We will check if we are under schema node & in 'create' mode
        inSchema: function inSchema() {
          if (this.node_info && 'catalog' in this.node_info) {
            return true;
          }
          return false;
        },
        // We will check if we are under schema node & in 'create' mode
        inSchemaWithModelCheck: function inSchemaWithModelCheck(m) {
          if (this.node_info && 'schema' in this.node_info) {
            // We will disable control if it's in 'edit' mode
            if (m.isNew()) {
              return false;
            } else {
              return true;
            }
          }
          return true;
        },
        // Checks weather to enable/disable control
        inSchemaWithColumnCheck: function inSchemaWithColumnCheck(m) {
          if (this.node_info && 'schema' in this.node_info) {
            // We will disable control if it's system columns
            // ie: it's position is less then 1
            if (m.isNew()) {
              return false;
            } else {
              // if we are in edit mode
              if (!_.isUndefined(m.get('attnum')) && m.get('attnum') >= 1) {
                return false;
              } else {
                return true;
              }
            }
          }
          return true;
        }
      }),
      // Below function will enable right click menu for creating column
      canCreate: function canCreate(itemData, item, data) {
        // If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData,
            parents = [];
        // To iterate over tree to check parent node
        while (i) {
          // If it is schema then allow user to c reate table
          if (_.indexOf(['schema'], d._type) > -1) return true;
          parents.push(d._type);
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // If node is under catalog then do not allow 'create' menu
        if (_.indexOf(parents, 'catalog') > -1) {
          return false;
        } else {
          return true;
        }
      },
      // Check to whether trigger is disable ?
      canCreate_with_trigger_enable: function canCreate_with_trigger_enable(itemData, item, data) {
        if (this.canCreate.apply(this, [itemData, item, data])) {
          // We are here means we can create menu, now let's check condition
          if (itemData.icon === 'icon-trigger-bad') {
            return true;
          } else {
            return false;
          }
        }
      },
      // Check to whether trigger is enable ?
      canCreate_with_trigger_disable: function canCreate_with_trigger_disable(itemData, item, data) {
        if (this.canCreate.apply(this, [itemData, item, data])) {
          // We are here means we can create menu, now let's check condition
          if (itemData.icon === 'icon-trigger') {
            return true;
          } else {
            return false;
          }
        }
      }
    });
  }

  return pgBrowser.Nodes['trigger'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, $, _, S, pgAdmin, pgBrowser, alertify) {

  if (!pgBrowser.Nodes['coll-catalog_object_column']) {
    var databases = pgAdmin.Browser.Nodes['coll-catalog_object_column'] = pgAdmin.Browser.Collection.extend({
      node: 'catalog_object_column',
      label: gettext('catalog_object_column'),
      type: 'coll-catalog_object_column',
      columns: ['attname', 'attnum', 'cltype', 'description']
    });
  };

  if (!pgBrowser.Nodes['catalog_object_column']) {
    pgAdmin.Browser.Nodes['catalog_object_column'] = pgAdmin.Browser.Node.extend({
      parent_type: 'catalog_object',
      type: 'catalog_object_column',
      label: gettext('catalog_object_column'),
      hasSQL: false,
      hasScriptTypes: [],
      hasDepends: true,
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;
      },
      model: pgAdmin.Browser.Node.Model.extend({
        defaults: {
          attname: undefined,
          attowner: undefined,
          atttypid: undefined,
          attnum: undefined,
          cltype: undefined,
          collspcname: undefined,
          attacl: undefined,
          description: undefined
        },
        schema: [{
          id: 'attname', label: gettext('Column'), cell: 'string',
          type: 'text', disabled: true
        }, {
          id: 'attowner', label: gettext('Owner'), cell: 'string',
          type: 'text', disabled: true
        }, {
          id: 'attnum', label: gettext('Position'), cell: 'string',
          type: 'text', disabled: true
        }, {
          id: 'cltype', label: gettext('Data type'), cell: 'string',
          group: gettext('Definition'), type: 'text', disabled: true
        }, {
          id: 'collspcname', label: gettext('Collation'), cell: 'string',
          group: gettext('Definition'), type: 'text', disabled: true
        }, {
          id: 'attacl', label: gettext('Privileges'), cell: 'string',
          group: gettext('Security'), type: 'text', disabled: true
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline', disabled: true
        }]
      })
    });
  }

  return pgBrowser.Nodes['catalog_object_column'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(14), __webpack_require__(22), __webpack_require__(198)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, CodeMirror) {

  /**
    Create and add a view collection into nodes
    @param {variable} label - Label for Node
    @param {variable} type - Type of Node
    @param {variable} columns - List of columns to
      display under under properties.
   */
  if (!pgBrowser.Nodes['coll-view']) {
    var views = pgBrowser.Nodes['coll-view'] = pgBrowser.Collection.extend({
      node: 'view',
      label: gettext('Views'),
      type: 'coll-view',
      columns: ["name", "owner"]
    });
  }

  /**
    Create and Add a View Node into nodes
    @param {variable} parent_type - The list of nodes
    under which this node to display
    @param {variable} type - Type of Node
    @param {variable} hasSQL - To show SQL tab
    @param {variable} canDrop - Adds drop view option
    in the context menu
    @param {variable} canDropCascade - Adds drop Cascade
    view option in the context menu
   */
  if (!pgBrowser.Nodes['view']) {
    pgBrowser.Nodes['view'] = pgBrowser.Node.extend({
      parent_type: ['schema', 'catalog'],
      type: 'view',
      sqlAlterHelp: 'sql-alterview.html',
      sqlCreateHelp: 'sql-createview.html',
      dialogHelp: url_for('help.static', { 'filename': 'view_dialog.html' }),
      label: gettext('View'),
      hasSQL: true,
      hasDepends: true,
      hasScriptTypes: ['create', 'select', 'insert'],
      collection_type: 'coll-view',
      canDrop: pgBrowser.Nodes['schema'].canChildDrop,
      canDropCascade: pgBrowser.Nodes['schema'].canChildDrop,
      Init: function Init() {

        // Avoid mulitple registration of menus
        if (this.initialized) return;

        this.initialized = true;

        /**
          Add "create view" menu option into context and object menu
          for the following nodes:
          coll-view, view and schema.
          @property {data} - Allow create view option on schema node or
          system view nodes.
         */
        pgBrowser.add_menus([{
          name: 'create_view_on_coll', node: 'coll-view', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 1, label: gettext('View...'),
          icon: 'wcTabIcon icon-view', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_view', node: 'view', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 1, label: gettext('View...'),
          icon: 'wcTabIcon icon-view', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_view', node: 'schema', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 17, label: gettext('View...'),
          icon: 'wcTabIcon icon-view', data: { action: 'create', check: false },
          enable: 'canCreate'
        }]);
      },

      /**
        Define model for the view node and specify the
        properties of the model in schema.
       */
      model: pgBrowser.Node.Model.extend({
        initialize: function initialize(attrs, args) {
          if (_.size(attrs) === 0) {
            // Set Selected Schema and, Current User
            var schemaLabel = args.node_info.schema._label || 'public',
                userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;
            this.set({
              'schema': schemaLabel, 'owner': userInfo.name
            }, { silent: true });
          }
          pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
        },
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', disabled: 'notInSchema'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', disabled: true, mode: ['properties']
        }, {
          id: 'owner', label: gettext('Owner'), cell: 'string', control: 'node-list-by-name',
          node: 'role', disabled: 'notInSchema', select2: { allowClear: false }
        }, {
          id: 'schema', label: gettext('Schema'), cell: 'string', first_empty: false,
          control: 'node-list-by-name', type: 'text', cache_level: 'database',
          node: 'schema', disabled: 'notInSchema', mode: ['create', 'edit'],
          select2: { allowClear: false }, cache_node: 'database'
        }, {
          id: 'system_view', label: gettext('System view?'), cell: 'string',
          type: 'switch', disabled: true, mode: ['properties']
        }, {
          id: 'acl', label: gettext('Privileges'),
          mode: ['properties'], type: 'text', group: gettext('Security')
        }, {
          id: 'comment', label: gettext('Comment'), cell: 'string',
          type: 'multiline', disabled: 'notInSchema'
        }, {
          id: 'security_barrier', label: gettext('Security barrier'),
          type: 'switch', min_version: '90200', group: gettext('Definition'),
          disabled: 'notInSchema'
        }, {
          id: 'check_option', label: gettext('Check options'),
          control: 'select2', group: gettext('Definition'), type: 'text',
          min_version: '90400', mode: ['properties', 'create', 'edit'],
          select2: {
            // Set select2 option width to 100%
            allowClear: false
          }, disabled: 'notInSchema',
          options: [{
            label: gettext("No"), value: "no"
          }, {
            label: gettext("Local"), value: "local"
          }, {
            label: gettext("Cascaded"), value: "cascaded"
          }]
        }, {
          id: 'definition', label: gettext('Definition'), cell: 'string',
          type: 'text', mode: ['create', 'edit'], group: gettext('Definition'),
          control: Backform.SqlFieldControl,
          disabled: 'notInSchema'
        }, pgBrowser.SecurityGroupSchema, {
          // Add Privilege Control
          id: 'datacl', label: gettext('Privileges'), type: 'collection',
          model: pgBrowser.Node.PrivilegeRoleModel.extend({
            privileges: ['a', 'r', 'w', 'd', 'D', 'x', 't']
          }), uniqueCol: ['grantee'], editable: false, group: 'security',
          mode: ['edit', 'create'], canAdd: true, canDelete: true,
          control: 'unique-col-collection', disabled: 'notInSchema'
        }, {
          // Add Security Labels Control
          id: 'seclabels', label: gettext('Security labels'),
          model: pgBrowser.SecLabelModel, editable: false, type: 'collection',
          canEdit: false, group: 'security', canDelete: true,
          mode: ['edit', 'create'], canAdd: true, disabled: 'notInSchema',
          control: 'unique-col-collection', uniqueCol: ['provider']
        }],
        validate: function validate() {
          // Triggers specific error messages for fields
          var err = {},
              errmsg,
              field_name = this.get('name'),
              field_def = this.get('definition');
          if (_.isUndefined(field_name) || _.isNull(field_name) || String(field_name).replace(/^\s+|\s+$/g, '') == '') {
            err['name'] = gettext('Please specify name.');
            errmsg = errmsg || err['name'];
            this.errorModel.set('name', errmsg);
            return errmsg;
          } else {
            this.errorModel.unset('name');
          }
          if (_.isUndefined(field_def) || _.isNull(field_def) || String(field_def).replace(/^\s+|\s+$/g, '') == '') {
            err['definition'] = gettext('Please enter view definition.');
            errmsg = errmsg || err['definition'];
            this.errorModel.set('definition', errmsg);
            return errmsg;
          } else {
            this.errorModel.unset('definition');
          }
          return null;
        },
        // We will disable everything if we are under catalog node
        notInSchema: function notInSchema() {
          if (this.node_info && 'catalog' in this.node_info) {
            return true;
          }
          return false;
        }
      }),

      /**
        Show or hide create view menu option on parent node
        and hide for system view in catalogs.
       */
      canCreate: function canCreate(itemData, item, data) {

        // If check is false then, we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData;

        // To iterate over tree to check parent node
        while (i) {

          // If it is schema then allow user to create view
          if (_.indexOf(['schema'], d._type) > -1) return true;

          if ('coll-view' == d._type) {

            // Check if we are not child of view
            var prev_i = t.hasParent(i) ? t.parent(i) : null,
                prev_d = prev_i ? t.itemData(prev_i) : null;
            if (prev_d._type == 'catalog') {
              return false;
            } else {
              return true;
            }
          }
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }

        // by default we do not want to allow create menu
        return true;
      }
    });
  }

  return pgBrowser.Nodes['view'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(17), __webpack_require__(6), __webpack_require__(14), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, alertify, pgBrowser, CodeMirror) {

  /**
    Create and add a view collection into nodes
    @param {variable} label - Label for Node
    @param {variable} type - Type of Node
    @param {variable} columns - List of columns to
      display under under properties.
   */
  if (!pgBrowser.Nodes['coll-mview']) {
    var mviews = pgBrowser.Nodes['coll-mview'] = pgBrowser.Collection.extend({
      node: 'mview',
      label: gettext('Materialized Views'),
      type: 'coll-mview',
      columns: ['name', 'owner']
    });
  }

  /**
    Create and Add a View Node into nodes
    @param {variable} parent_type - The list of nodes
    under which this node to display
    @param {variable} type - Type of Node
    @param {variable} hasSQL - To show SQL tab
    @param {variable} canDrop - Adds drop view option
    in the context menu
    @param {variable} canDropCascade - Adds drop Cascade
    view option in the context menu
   */
  if (!pgBrowser.Nodes['mview']) {
    pgBrowser.Nodes['mview'] = pgBrowser.Node.extend({
      parent_type: ['schema', 'catalog'],
      type: 'mview',
      sqlAlterHelp: 'sql-altermaterializedview.html',
      sqlCreateHelp: 'sql-creatematerializedview.html',
      dialogHelp: url_for('help.static', { 'filename': 'materialized_view_dialog.html' }),
      label: gettext('Materialized View'),
      hasSQL: true,
      hasDepends: true,
      hasScriptTypes: ['create', 'select'],
      collection_type: 'coll-mview',
      canDrop: pgBrowser.Nodes['schema'].canChildDrop,
      canDropCascade: pgBrowser.Nodes['schema'].canChildDrop,
      Init: function Init() {

        // Avoid mulitple registration of menus
        if (this.initialized) return;

        this.initialized = true;

        /**
          Add "create view" menu option into context and object menu
          for the following nodes:
          coll-mview, view and schema.
          @property {data} - Allow create view option on schema node or
          system view nodes.
         */
        pgAdmin.Browser.add_menu_category('refresh_mview', gettext('Refresh View'), 18, 'fa fa-recycle');
        pgBrowser.add_menus([{
          name: 'create_mview_on_coll', node: 'coll-mview', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 1, icon: 'wcTabIcon icon-mview',
          data: { action: 'create', check: true }, enable: 'canCreate',
          label: gettext('Materialized View...')
        }, {
          name: 'create_mview', node: 'mview', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 1, icon: 'wcTabIcon icon-mview',
          data: { action: 'create', check: true }, enable: 'canCreate',
          label: gettext('Materialized View...')
        }, {
          name: 'create_mview', node: 'schema', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 18, icon: 'wcTabIcon icon-mview',
          data: { action: 'create', check: false }, enable: 'canCreate',
          label: gettext('Materialized View...')
        }, {
          name: 'refresh_mview_data', node: 'mview', module: this,
          priority: 1, callback: 'refresh_mview', category: 'refresh_mview',
          applies: ['object', 'context'], label: gettext('With data'),
          data: { concurrent: false, with_data: true }, icon: 'fa fa-recycle'
        }, {
          name: 'refresh_mview_nodata', node: 'mview',
          callback: 'refresh_mview', priority: 2, module: this,
          category: 'refresh_mview', applies: ['object', 'context'],
          label: gettext('With no data'), data: {
            concurrent: false, with_data: false
          }, icon: 'fa fa-refresh'
        }, {
          name: 'refresh_mview_concurrent', node: 'mview', module: this,
          category: 'refresh_mview', enable: 'is_version_supported',
          data: { concurrent: true, with_data: true }, priority: 3,
          applies: ['object', 'context'], callback: 'refresh_mview',
          label: gettext('With data (concurrently)'), icon: 'fa fa-recycle'
        }, {
          name: 'refresh_mview_concurrent_nodata', node: 'mview', module: this,
          category: 'refresh_mview', enable: 'is_version_supported',
          data: { concurrent: true, with_data: false }, priority: 4,
          applies: ['object', 'context'], callback: 'refresh_mview',
          label: gettext('With no data (concurrently)'),
          icon: 'fa fa-refresh'
        }]);
      },

      /**
        Define model for the view node and specify the
        properties of the model in schema.
       */
      model: pgBrowser.Node.Model.extend({
        initialize: function initialize(attrs, args) {
          if (_.size(attrs) === 0) {
            // Set Selected Schema and Current User
            var schemaLabel = args.node_info.schema._label || 'public',
                userInfo = pgBrowser.serverInfo[args.node_info.server._id].user;
            this.set({
              'schema': 'public', 'owner': userInfo.name
            }, { silent: true });
          }
          pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
        },
        defaults: {
          spcname: undefined,
          toast_autovacuum_enabled: false,
          autovacuum_enabled: false
        },
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', disabled: 'inSchema'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', disabled: true, mode: ['properties']
        }, {
          id: 'owner', label: gettext('Owner'), cell: 'string',
          control: 'node-list-by-name', select2: { allowClear: false },
          node: 'role', disabled: 'inSchema'
        }, {
          id: 'schema', label: gettext('Schema'), cell: 'string', first_empty: false,
          control: 'node-list-by-name', type: 'text', cache_level: 'database',
          node: 'schema', mode: ['create', 'edit'], cache_node: 'database',
          disabled: 'inSchema', select2: { allowClear: false }
        }, {
          id: 'system_view', label: gettext('System view?'), cell: 'string',
          type: 'switch', disabled: true, mode: ['properties']
        }, pgBrowser.SecurityGroupSchema, {
          id: 'acl', label: gettext('Privileges'),
          mode: ['properties'], type: 'text', group: gettext('Security')
        }, {
          id: 'comment', label: gettext('Comment'), cell: 'string',
          type: 'multiline'
        }, {
          id: 'definition', label: '', cell: 'string',
          type: 'text', mode: ['create', 'edit'], group: gettext('Definition'),
          control: Backform.SqlFieldControl, extraClasses: ['sql_field_width_full']
        }, {
          id: 'with_data', label: gettext('With Data'),
          group: gettext('Storage'), mode: ['edit', 'create'],
          type: 'switch'
        }, {
          id: 'spcname', label: gettext('Tablespace'), cell: 'string',
          type: 'text', group: gettext('Storage'), first_empty: false,
          control: 'node-list-by-name', node: 'tablespace', select2: { allowClear: false },
          filter: function filter(m) {
            if (m.label == "pg_global") return false;else return true;
          }
        }, {
          id: 'fillfactor', label: gettext('Fill Factor'),
          group: gettext('Storage'), mode: ['edit', 'create'],
          type: 'int'
        }, {
          type: 'nested', control: 'tab', id: 'materialization',
          label: gettext('Parameter'), mode: ['edit', 'create'],
          group: gettext('Parameter'),
          schema: Backform.VacuumSettingsSchema
        }, {
          // Add Privilege Control
          id: 'datacl', label: gettext('Privileges'), type: 'collection',
          model: pgBrowser.Node.PrivilegeRoleModel.extend({
            privileges: ['a', 'r', 'w', 'd', 'D', 'x', 't']
          }), uniqueCol: ['grantee'], editable: false,
          group: "security", canAdd: true, canDelete: true,
          mode: ['edit', 'create'], control: 'unique-col-collection'
        }, {
          // Add Security Labels Control
          id: 'seclabels', label: gettext('Security Labels'),
          model: pgBrowser.SecLabelModel, editable: false, type: 'collection',
          canEdit: false, group: "security", canDelete: true,
          mode: ['edit', 'create'], canAdd: true,
          control: 'unique-col-collection', uniqueCol: ['provider']
        }],
        validate: function validate(keys) {

          // Triggers specific error messages for fields
          var err = {},
              errmsg,
              field_name = this.get('name'),
              field_def = this.get('definition');
          if (_.indexOf(keys, 'autovacuum_enabled') != -1 || _.indexOf(keys, 'toast_autovacuum_enabled') != -1) return null;

          if (_.isUndefined(field_name) || _.isNull(field_name) || String(field_name).replace(/^\s+|\s+$/g, '') == '') {
            err['name'] = gettext('Please specify name.');
            errmsg = errmsg || err['name'];
            this.errorModel.set('name', errmsg);
            return errmsg;
          } else {
            this.errorModel.unset('name');
          }
          if (_.isUndefined(field_def) || _.isNull(field_def) || String(field_def).replace(/^\s+|\s+$/g, '') == '') {
            err['definition'] = gettext('Please enter view definition.');
            errmsg = errmsg || err['definition'];
            this.errorModel.set('definition', errmsg);
            return errmsg;
          } else {
            this.errorModel.unset('definition');
          }
          return null;
        },
        // We will disable everything if we are under catalog node
        inSchema: function inSchema() {
          if (this.node_info && 'catalog' in this.node_info) {
            return true;
          }
          return false;
        }

      }),

      /**
        Show or hide create view menu option on parent node
        and hide for system view in catalogs.
       */
      canCreate: function canCreate(itemData, item, data) {

        // If check is false then, we will allow create menu
        if (data && data.check === false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData;

        // To iterate over tree to check parent node
        while (i) {

          // If it is schema then allow user to create view
          if (_.indexOf(['schema'], d._type) > -1) return true;

          if ('coll-mview' == d._type) {

            // Check if we are not child of view
            var prev_i = t.hasParent(i) ? t.parent(i) : null,
                prev_d = prev_i ? t.itemData(prev_i) : null;
            if (prev_d._type == 'catalog') {
              return false;
            } else {
              return true;
            }
          }
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }

        // by default we do not want to allow create menu
        return true;
      },
      refresh_mview: function refresh_mview(args) {
        var input = args || {},
            obj = this,
            t = pgBrowser.tree,
            i = input.item || t.selected(),
            d = i && i.length == 1 ? t.itemData(i) : undefined;

        if (!d) return false;

        // Make ajax call to refresh mview data
        $.ajax({
          url: obj.generate_url(i, 'refresh_data', d, true),
          type: 'PUT',
          data: { 'concurrent': args.concurrent, 'with_data': args.with_data },
          dataType: "json",
          success: function success(res) {
            if (res.success == 1) {
              alertify.success('View refreshed successfully');
            } else {
              alertify.alert('Error refreshing view', res.data.result);
            }
          },
          error: function error(e) {
            var errmsg = $.parseJSON(e.responseText);
            alertify.alert('Error refreshing view', errmsg.errormsg);
          }
        });
      },
      is_version_supported: function is_version_supported(data, item, args) {
        var t = pgAdmin.Browser.tree,
            i = item || t.selected(),
            d = data || (i && i.length == 1 ? t.itemData(i) : undefined),
            node = this || d && pgAdmin.Browser.Nodes[d._type],
            info = node.getTreeNodeHierarchy.apply(node, [i]),
            version = info.server.version;

        // disable refresh concurrently if server version is 9.3
        return version >= 90400;
      }
    });
  }

  return pgBrowser.Nodes['mview'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backgrid) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(17), __webpack_require__(9), __webpack_require__(316), __webpack_require__(317), __webpack_require__(199)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  if (!pgBrowser.Nodes['coll-table']) {
    var databases = pgBrowser.Nodes['coll-table'] = pgBrowser.Collection.extend({
      node: 'table',
      label: gettext('Tables'),
      type: 'coll-table',
      columns: ['name', 'relowner', 'is_partitioned', 'description'],
      hasStatistics: true,
      statsPrettifyFields: ['Size', 'Indexes size', 'Table size', 'Toast table size', 'Tuple length', 'Dead tuple length', 'Free space']
    });
  };

  if (!pgBrowser.Nodes['table']) {
    pgBrowser.Nodes['table'] = pgBrowser.Node.extend({
      getTreeNodeHierarchy: pgBrowser.tableChildTreeNodeHierarchy,
      type: 'table',
      label: gettext('Table'),
      collection_type: 'coll-table',
      hasSQL: true,
      hasDepends: true,
      hasStatistics: true,
      statsPrettifyFields: ['Size', 'Indexes size', 'Table size', 'Toast table size', 'Tuple length', 'Dead tuple length', 'Free space'],
      sqlAlterHelp: 'sql-altertable.html',
      sqlCreateHelp: 'sql-createtable.html',
      dialogHelp: url_for('help.static', { 'filename': 'table_dialog.html' }),
      parent_type: ['schema', 'catalog'],
      hasScriptTypes: ['create', 'select', 'insert', 'update', 'delete'],
      height: '95%',
      width: '85%',
      Init: function Init() {
        /* Avoid multiple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_table_on_coll', node: 'coll-table', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 1, label: gettext('Table...'),
          icon: 'wcTabIcon icon-table', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_table', node: 'table', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 1, label: gettext('Table...'),
          icon: 'wcTabIcon icon-table', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_table__on_schema', node: 'schema', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Table...'),
          icon: 'wcTabIcon icon-table', data: { action: 'create', check: false },
          enable: 'canCreate'
        }, {
          name: 'truncate_table', node: 'table', module: this,
          applies: ['object', 'context'], callback: 'truncate_table',
          category: 'Truncate', priority: 3, label: gettext('Truncate'),
          icon: 'fa fa-eraser', enable: 'canCreate'
        }, {
          name: 'truncate_table_cascade', node: 'table', module: this,
          applies: ['object', 'context'], callback: 'truncate_table_cascade',
          category: 'Truncate', priority: 3, label: gettext('Truncate Cascade'),
          icon: 'fa fa-eraser', enable: 'canCreate'
        }, {
          // To enable/disable all triggers for the table
          name: 'enable_all_triggers', node: 'table', module: this,
          applies: ['object', 'context'], callback: 'enable_triggers_on_table',
          category: 'Trigger(s)', priority: 4, label: gettext('Enable All'),
          icon: 'fa fa-check', enable: 'canCreate_with_trigger_enable'
        }, {
          name: 'disable_all_triggers', node: 'table', module: this,
          applies: ['object', 'context'], callback: 'disable_triggers_on_table',
          category: 'Trigger(s)', priority: 4, label: gettext('Disable All'),
          icon: 'fa fa-times', enable: 'canCreate_with_trigger_disable'
        }, {
          name: 'reset_table_stats', node: 'table', module: this,
          applies: ['object', 'context'], callback: 'reset_table_stats',
          category: 'Reset', priority: 4, label: gettext('Reset Statistics'),
          icon: 'fa fa-bar-chart', enable: 'canCreate'
        }]);
        pgBrowser.Events.on('pgadmin:browser:node:table:updated', this.onTableUpdated, this);
      },
      canDrop: pgBrowser.Nodes['schema'].canChildDrop,
      canDropCascade: pgBrowser.Nodes['schema'].canChildDrop,
      callbacks: {
        /* Enable trigger(s) on table */
        enable_triggers_on_table: function enable_triggers_on_table(args) {
          var params = { 'enable': true };
          this.callbacks.set_triggers.apply(this, [args, params]);
        },
        /* Disable trigger(s) on table */
        disable_triggers_on_table: function disable_triggers_on_table(args) {
          var params = { 'enable': false };
          this.callbacks.set_triggers.apply(this, [args, params]);
        },
        set_triggers: function set_triggers(args, params) {
          // This function will send request to enable or
          // disable triggers on table level
          var input = args || {},
              obj = this,
              t = pgBrowser.tree,
              i = input.item || t.selected(),
              d = i && i.length == 1 ? t.itemData(i) : undefined;
          if (!d) return false;

          $.ajax({
            url: obj.generate_url(i, 'set_trigger', d, true),
            type: 'PUT',
            data: params,
            dataType: "json",
            success: function success(res) {
              if (res.success == 1) {
                alertify.success(res.info);
                t.unload(i);
                t.setInode(i);
                t.deselect(i);
                setTimeout(function () {
                  t.select(i);
                }, 10);
              }
            },
            error: function error(xhr, status, _error) {
              try {
                var err = $.parseJSON(xhr.responseText);
                if (err.success == 0) {
                  alertify.error(err.errormsg);
                }
              } catch (e) {}
              t.unload(i);
            }
          });
        },
        /* Truncate table */
        truncate_table: function truncate_table(args) {
          var params = { 'cascade': false };
          this.callbacks.truncate.apply(this, [args, params]);
        },
        /* Truncate table with cascade */
        truncate_table_cascade: function truncate_table_cascade(args) {
          var params = { 'cascade': true };
          this.callbacks.truncate.apply(this, [args, params]);
        },
        truncate: function truncate(args, params) {
          var input = args || {},
              obj = this,
              t = pgBrowser.tree,
              i = input.item || t.selected(),
              d = i && i.length == 1 ? t.itemData(i) : undefined;

          if (!d) return false;

          alertify.confirm(gettext('Truncate Table'), S(gettext('Are you sure you want to truncate table %s?')).sprintf(d.label).value(), function (e) {
            if (e) {
              var data = d;
              $.ajax({
                url: obj.generate_url(i, 'truncate', d, true),
                type: 'PUT',
                data: params,
                dataType: "json",
                success: function success(res) {
                  if (res.success == 1) {
                    alertify.success(res.info);
                    t.removeIcon(i);
                    data.icon = data.is_partitioned ? 'icon-partition' : 'icon-table';
                    t.addIcon(i, { icon: data.icon });
                    t.unload(i);
                    t.setInode(i);
                    t.deselect(i);
                    // Fetch updated data from server
                    setTimeout(function () {
                      t.select(i);
                    }, 10);
                  }
                },
                error: function error(xhr, status, _error2) {
                  try {
                    var err = $.parseJSON(xhr.responseText);
                    if (err.success == 0) {
                      alertify.error(err.errormsg);
                    }
                  } catch (e) {}
                  t.unload(i);
                }
              });
            }
          }, function () {});
        },
        reset_table_stats: function reset_table_stats(args) {
          var input = args || {},
              obj = this,
              t = pgBrowser.tree,
              i = input.item || t.selected(),
              d = i && i.length == 1 ? t.itemData(i) : undefined;

          if (!d) return false;

          alertify.confirm(gettext('Reset statistics'), S(gettext('Are you sure you want to reset the statistics for table %s?')).sprintf(d._label).value(), function (e) {
            if (e) {
              var data = d;
              $.ajax({
                url: obj.generate_url(i, 'reset', d, true),
                type: 'DELETE',
                success: function success(res) {
                  if (res.success == 1) {
                    alertify.success(res.info);
                    t.removeIcon(i);
                    data.icon = data.is_partitioned ? 'icon-partition' : 'icon-table';
                    t.addIcon(i, { icon: data.icon });
                    t.unload(i);
                    t.setInode(i);
                    t.deselect(i);
                    // Fetch updated data from server
                    setTimeout(function () {
                      t.select(i);
                    }, 10);
                  }
                },
                error: function error(xhr, status, _error3) {
                  try {
                    var err = $.parseJSON(xhr.responseText);
                    if (err.success == 0) {
                      alertify.error(err.errormsg);
                    }
                  } catch (e) {}
                  t.unload(i);
                }
              });
            }
          }, function () {});
        }
      },
      model: pgBrowser.Node.Model.extend({
        defaults: {
          name: undefined,
          oid: undefined,
          spcoid: undefined,
          spcname: undefined,
          relowner: undefined,
          relacl: undefined,
          relhasoids: undefined,
          relhassubclass: undefined,
          reltuples: undefined,
          description: undefined,
          conname: undefined,
          conkey: undefined,
          isrepl: undefined,
          triggercount: undefined,
          relpersistence: undefined,
          fillfactor: undefined,
          reloftype: undefined,
          typname: undefined,
          labels: undefined,
          providers: undefined,
          is_sys_table: undefined,
          coll_inherits: [],
          hastoasttable: true,
          toast_autovacuum_enabled: false,
          autovacuum_enabled: false,
          primary_key: [],
          partitions: [],
          partition_type: 'range',
          is_partitioned: false
        },
        // Default values!
        initialize: function initialize(attrs, args) {
          var self = this;

          if (_.size(attrs) === 0) {
            var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user,
                schemaInfo = args.node_info.schema;

            this.set({
              'relowner': userInfo.name, 'schema': schemaInfo._label
            }, { silent: true });
          }
          pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
        },
        schema: [{
          id: 'name', label: gettext('Name'), type: 'text',
          mode: ['properties', 'create', 'edit'], disabled: 'inSchema'
        }, {
          id: 'oid', label: gettext('OID'), type: 'text', mode: ['properties']
        }, {
          id: 'relowner', label: gettext('Owner'), type: 'text', node: 'role',
          mode: ['properties', 'create', 'edit'], select2: { allowClear: false },
          disabled: 'inSchema', control: 'node-list-by-name'
        }, {
          id: 'schema', label: gettext('Schema'), type: 'text', node: 'schema',
          control: 'node-list-by-name', mode: ['create', 'edit'],
          disabled: 'inSchema', filter: function filter(d) {
            // If schema name start with pg_* then we need to exclude them
            if (d && d.label.match(/^pg_/)) {
              return false;
            }
            return true;
          }, cache_node: 'database', cache_level: 'database'
        }, {
          id: 'spcname', label: gettext('Tablespace'), node: 'tablespace',
          type: 'text', control: 'node-list-by-name', disabled: 'inSchema',
          mode: ['properties', 'create', 'edit'],
          filter: function filter(d) {
            // If tablespace name is not "pg_global" then we need to exclude them
            return !(d && d.label.match(/pg_global/));
          }
        }, {
          id: 'partition', type: 'group', label: gettext('Partition'),
          mode: ['edit', 'create'], min_version: 100000,
          visible: function visible(m) {
            // Always show in case of create mode
            if (m.isNew() || m.get('is_partitioned')) return true;
            return false;
          }
        }, {
          id: 'is_partitioned', label: gettext('Partitioned Table?'), cell: 'switch',
          type: 'switch', mode: ['properties', 'create', 'edit'],
          visible: function visible(m) {
            if (!_.isUndefined(m.node_info) && !_.isUndefined(m.node_info.server) && !_.isUndefined(m.node_info.server.version) && m.node_info.server.version >= 100000) return true;

            return false;
          },
          disabled: function disabled(m) {
            if (!m.isNew()) return true;
            return false;
          }
        }, {
          id: 'description', label: gettext('Comment'), type: 'multiline',
          mode: ['properties', 'create', 'edit'], disabled: 'inSchema'
        }, {
          id: 'coll_inherits', label: gettext('Inherited from table(s)'),
          url: 'get_inherits', type: 'array', group: gettext('Columns'),
          disabled: 'checkInheritance', deps: ['typname', 'is_partitioned'],
          mode: ['create', 'edit'],
          select2: { multiple: true, allowClear: true,
            placeholder: gettext('Select to inherit from...') },
          transform: function transform(data, cell) {
            var control = cell || this,
                m = control.model;
            m.inherited_tables_list = data;
            return data;
          },
          control: Backform.MultiSelectAjaxControl.extend({
            // When changes we need to add/clear columns collection
            onChange: function onChange() {
              Backform.MultiSelectAjaxControl.prototype.onChange.apply(this, arguments);
              var self = this,

              // current table list and previous table list
              cTbl_list = self.model.get('coll_inherits') || [],
                  pTbl_list = self.model.previous('coll_inherits') || [];

              if (!_.isUndefined(cTbl_list)) {
                var tbl_name = undefined,
                    tid = undefined;

                // Add columns logic
                // If new table is added in list
                if (cTbl_list.length > 1 && cTbl_list.length > pTbl_list.length) {
                  // Find newly added table from current list
                  tbl_name = _.difference(cTbl_list, pTbl_list);
                  tid = this.get_table_oid(tbl_name[0]);
                  this.add_columns(tid);
                } else if (cTbl_list.length == 1) {
                  // First table added
                  tid = this.get_table_oid(cTbl_list[0]);
                  this.add_columns(tid);
                }

                // Remove columns logic
                if (cTbl_list.length > 0 && cTbl_list.length < pTbl_list.length) {
                  // Find deleted table from previous list
                  tbl_name = _.difference(pTbl_list, cTbl_list);
                  this.remove_columns(tbl_name[0]);
                } else if (pTbl_list.length === 1 && cTbl_list.length < 1) {
                  // We got last table from list
                  tbl_name = pTbl_list[0];
                  this.remove_columns(tbl_name);
                }
              }
            },
            add_columns: function add_columns(tid) {
              // Create copy of old model if anything goes wrong at-least we have backup
              // Then send AJAX request to fetch table specific columns
              var self = this,
                  url = 'get_columns',
                  m = self.model.top || self.model,
                  data = undefined,
                  old_columns = _.clone(m.get('columns')),
                  column_collection = m.get('columns');

              var arg = { 'tid': tid };
              data = self.model.fetch_columns_ajax.apply(self, [arg]);

              // Update existing column collection
              column_collection.set(data, { merge: false, remove: false });
            },
            remove_columns: function remove_columns(tblname) {
              // Remove all the column models for deleted table
              var tid = this.get_table_oid(tblname),
                  column_collection = this.model.get('columns');
              column_collection.remove(column_collection.where({ 'inheritedid': tid }));
            },
            get_table_oid: function get_table_oid(tblname) {
              // Here we will fetch the table oid from table name
              var tbl_oid = undefined;
              // iterate over list to find table oid
              _.each(this.model.inherited_tables_list, function (obj) {
                if (obj.label === tblname) {
                  tbl_oid = obj.tid;
                }
              });
              return tbl_oid;
            }
          })
        }, {
          id: 'coll_inherits', label: gettext('Inherited from table(s)'),
          type: 'text', group: gettext('Advanced'), mode: ['properties']
        }, {
          id: 'inherited_tables_cnt', label: gettext('Inherited tables count'),
          type: 'text', mode: ['properties'], group: gettext('Advanced'),
          disabled: 'inSchema'
        }, {
          // Tab control for columns
          id: 'columns', label: gettext('Columns'), type: 'collection',
          group: gettext('Columns'),
          model: pgBrowser.Nodes['column'].model,
          subnode: pgBrowser.Nodes['column'].model,
          mode: ['create', 'edit'],
          disabled: function disabled(m) {
            // In case of partitioned table remove inherited columns
            if (m.isNew() && m.get('is_partitioned')) {
              setTimeout(function () {
                var coll = m.get('columns');
                coll.remove(coll.filter(function (model) {
                  if (_.isUndefined(model.get('inheritedfrom'))) return false;
                  return true;
                }));
              }, 10);
            }

            if (this.node_info && 'catalog' in this.node_info) {
              return true;
            }
            return false;
          },
          deps: ['typname', 'is_partitioned'],
          canAdd: 'check_grid_add_condition',
          canEdit: true, canDelete: true,
          // For each row edit/delete button enable/disable
          canEditRow: 'check_grid_row_edit_delete',
          canDeleteRow: 'check_grid_row_edit_delete',
          uniqueCol: ['name'],
          columns: ['name', 'cltype', 'attlen', 'attprecision', 'attnotnull', 'is_primary_key'],
          control: Backform.UniqueColCollectionControl.extend({
            initialize: function initialize() {
              Backform.UniqueColCollectionControl.prototype.initialize.apply(this, arguments);
              var self = this,
                  collection = self.model.get(self.field.get('name'));

              collection.on("change:is_primary_key", function (m) {
                var primary_key_coll = self.model.get('primary_key'),
                    column_name = m.get('name'),
                    primary_key;

                if (m.get('is_primary_key')) {
                  // Add column to primary key.
                  if (primary_key_coll.length < 1) {
                    primary_key = new primary_key_coll.model({}, {
                      top: self.model,
                      collection: primary_key_coll,
                      handler: primary_key_coll
                    });
                    primary_key_coll.add(primary_key);
                  } else {
                    primary_key = primary_key_coll.first();
                  }
                  // Do not alter existing primary key columns.
                  if (_.isUndefined(primary_key.get('oid'))) {
                    var primary_key_column_coll = primary_key.get('columns'),
                        primary_key_column_exist = primary_key_column_coll.where({ column: column_name });

                    if (primary_key_column_exist.length == 0) {
                      var primary_key_column = new primary_key_column_coll.model({ column: column_name }, { silent: true,
                        top: self.model,
                        collection: primary_key_coll,
                        handler: primary_key_coll
                      });

                      primary_key_column_coll.add(primary_key_column);
                    }

                    primary_key_column_coll.trigger('pgadmin:multicolumn:updated', primary_key_column_coll);
                  }
                } else {
                  // remove column from primary key.
                  if (primary_key_coll.length > 0) {
                    var primary_key = primary_key_coll.first();
                    // Do not alter existing primary key columns.
                    if (!_.isUndefined(primary_key.get('oid'))) {
                      return;
                    }

                    var primary_key_column_coll = primary_key.get('columns'),
                        removedCols = primary_key_column_coll.where({ column: column_name });
                    if (removedCols.length > 0) {
                      primary_key_column_coll.remove(removedCols);
                      _.each(removedCols, function (m) {
                        m.destroy();
                      });
                      if (primary_key_column_coll.length == 0) {
                        setTimeout(function () {
                          // There will be only on primary key so remove the first one.
                          primary_key_coll.remove(primary_key_coll.first());
                          /* Ideally above line of code should be "primary_key_coll.reset()".
                           * But our custom DataCollection (extended from Backbone collection in datamodel.js)
                           * does not respond to reset event, it only supports add, remove, change events.
                           * And hence no custom event listeners/validators get called for reset event.
                           */
                        }, 10);
                      }
                    }
                    primary_key_column_coll.trigger('pgadmin:multicolumn:updated', primary_key_column_coll);
                  }
                }
              });
            },
            remove: function remove() {
              var collection = this.model.get(this.field.get('name'));
              if (collection) {
                collection.off("change:is_primary_key");
              }

              Backform.UniqueColCollectionControl.prototype.remove.apply(this, arguments);
            }
          }),
          allowMultipleEmptyRow: false
        }, {
          // Here we will create tab control for constraints
          type: 'nested', control: 'tab', group: gettext('Constraints'),
          mode: ['edit', 'create'],
          schema: [{
            id: 'primary_key', label: gettext('Primary key'),
            model: pgBrowser.Nodes['primary_key'].model,
            subnode: pgBrowser.Nodes['primary_key'].model,
            editable: false, type: 'collection',
            group: gettext('Primary Key'), mode: ['edit', 'create'],
            canEdit: true, canDelete: true, deps: ['is_partitioned'],
            control: 'unique-col-collection',
            columns: ['name', 'columns'],
            canAdd: function canAdd(m) {
              if (m.get('is_partitioned')) {
                setTimeout(function () {
                  var coll = m.get('primary_key');
                  coll.remove(coll.filter(function (model) {
                    return true;
                  }));
                }, 10);
                return false;
              }

              return true;
            },
            canAddRow: function canAddRow(m) {
              // User can only add one primary key
              var columns = m.get('columns');

              return m.get('primary_key') && m.get('primary_key').length < 1 && _.some(columns.pluck('name'));
            }
          }, {
            id: 'foreign_key', label: gettext('Foreign key'),
            model: pgBrowser.Nodes['foreign_key'].model,
            subnode: pgBrowser.Nodes['foreign_key'].model,
            editable: false, type: 'collection',
            group: gettext('Foreign Key'), mode: ['edit', 'create'],
            canEdit: true, canDelete: true, deps: ['is_partitioned'],
            control: 'unique-col-collection',
            canAdd: function canAdd(m) {
              if (m.get('is_partitioned')) {
                setTimeout(function () {
                  var coll = m.get('foreign_key');
                  coll.remove(coll.filter(function (model) {
                    return true;
                  }));
                }, 10);
                return false;
              }

              return true;
            },
            columns: ['name', 'columns'],
            canAddRow: function canAddRow(m) {
              // User can only add if there is at least one column with name.
              var columns = m.get('columns');
              return _.some(columns.pluck('name'));
            }
          }, {
            id: 'check_constraint', label: gettext('Check constraint'),
            model: pgBrowser.Nodes['check_constraints'].model,
            subnode: pgBrowser.Nodes['check_constraints'].model,
            editable: false, type: 'collection',
            group: gettext('Check'), mode: ['edit', 'create'],
            canEdit: true, canDelete: true, deps: ['is_partitioned'],
            control: 'unique-col-collection',
            canAdd: true,
            columns: ['name', 'consrc']
          }, {
            id: 'unique_constraint', label: gettext('Unique Constraint'),
            model: pgBrowser.Nodes['unique_constraint'].model,
            subnode: pgBrowser.Nodes['unique_constraint'].model,
            editable: false, type: 'collection',
            group: gettext('Unique'), mode: ['edit', 'create'],
            canEdit: true, canDelete: true, deps: ['is_partitioned'],
            control: 'unique-col-collection',
            columns: ['name', 'columns'],
            canAdd: function canAdd(m) {
              if (m.get('is_partitioned')) {
                setTimeout(function () {
                  var coll = m.get('unique_constraint');
                  coll.remove(coll.filter(function (model) {
                    return true;
                  }));
                }, 10);
                return false;
              }

              return true;
            },
            canAddRow: function canAddRow(m) {
              // User can only add if there is at least one column with name.
              var columns = m.get('columns');
              return _.some(columns.pluck('name'));
            }
          }, {
            id: 'exclude_constraint', label: gettext('Exclude constraint'),
            model: pgBrowser.Nodes['exclusion_constraint'].model,
            subnode: pgBrowser.Nodes['exclusion_constraint'].model,
            editable: false, type: 'collection',
            group: gettext('Exclude'), mode: ['edit', 'create'],
            canEdit: true, canDelete: true, deps: ['is_partitioned'],
            control: 'unique-col-collection',
            columns: ['name', 'columns', 'constraint'],
            canAdd: function canAdd(m) {
              if (m.get('is_partitioned')) {
                setTimeout(function () {
                  var coll = m.get('exclude_constraint');
                  coll.remove(coll.filter(function (model) {
                    return true;
                  }));
                }, 10);
                return false;
              }

              return true;
            },
            canAddRow: function canAddRow(m) {
              // User can only add if there is at least one column with name.
              var columns = m.get('columns');
              return _.some(columns.pluck('name'));
            }
          }]
        }, {
          id: 'typname', label: gettext('Of type'), type: 'text',
          mode: ['properties', 'create', 'edit'],
          disabled: 'checkOfType', url: 'get_oftype', group: gettext('Advanced'),
          deps: ['coll_inherits'], transform: function transform(data, cell) {
            var control = cell || this,
                m = control.model;
            m.of_types_tables = data;
            return data;
          },
          control: Backform.NodeAjaxOptionsControl.extend({
            // When of_types changes we need to clear columns collection
            onChange: function onChange() {
              Backform.NodeAjaxOptionsControl.prototype.onChange.apply(this, arguments);
              var self = this,
                  tbl_oid = undefined,
                  tbl_name = self.model.get('typname'),
                  data = undefined,
                  arg = undefined,
                  column_collection = self.model.get('columns');

              if (!_.isUndefined(tbl_name) && !_.isNull(tbl_name) && tbl_name !== '' && column_collection.length !== 0) {
                var title = gettext('Remove column definitions?'),
                    msg = gettext('Changing \'Of type\' will remove column definitions.');

                alertify.confirm(title, msg, function (e) {
                  // User clicks Ok, lets clear columns collection
                  column_collection.remove(column_collection.filter(function (model) {
                    return true;
                  }));
                }, function () {
                  setTimeout(function () {
                    self.model.set('typname', null);
                  }, 10);
                });
              } else if (!_.isUndefined(tbl_name) && tbl_name === '') {
                column_collection.remove(column_collection.filter(function (model) {
                  return true;
                }));
              }

              // Run Ajax now to fetch columns
              if (!_.isUndefined(tbl_name) && tbl_name !== '') {
                arg = { 'tname': tbl_name };
                data = self.model.fetch_columns_ajax.apply(self, [arg]);
                // Add into column collection
                column_collection.set(data, { merge: false, remove: false });
              }
            }
          })
        }, {
          id: 'fillfactor', label: gettext('Fill factor'), type: 'int',
          mode: ['create', 'edit'], min: 10, max: 100,
          disabled: 'inSchema', group: gettext('Advanced')
        }, {
          id: 'relhasoids', label: gettext('Has OIDs?'), cell: 'switch',
          type: 'switch', mode: ['properties', 'create', 'edit'],
          disabled: 'inSchema', group: gettext('Advanced')
        }, {
          id: 'relpersistence', label: gettext('Unlogged?'), cell: 'switch',
          type: 'switch', mode: ['properties', 'create', 'edit'],
          disabled: 'inSchemaWithModelCheck',
          group: gettext('Advanced')
        }, {
          id: 'conname', label: gettext('Primary key'), cell: 'string',
          type: 'text', mode: ['properties'], group: gettext('Advanced'),
          disabled: 'inSchema'
        }, {
          id: 'reltuples', label: gettext('Rows (estimated)'), cell: 'string',
          type: 'text', mode: ['properties'], group: gettext('Advanced'),
          disabled: 'inSchema'
        }, {
          id: 'rows_cnt', label: gettext('Rows (counted)'), cell: 'string',
          type: 'text', mode: ['properties'], group: gettext('Advanced'),
          disabled: 'inSchema'
        }, {
          id: 'relhassubclass', label: gettext('Inherits tables?'), cell: 'switch',
          type: 'switch', mode: ['properties'], group: gettext('Advanced'),
          disabled: 'inSchema'
        }, {
          id: 'is_sys_table', label: gettext('System table?'), cell: 'switch',
          type: 'switch', mode: ['properties'],
          disabled: 'inSchema'
        }, {
          type: 'nested', control: 'fieldset', label: gettext('Like'),
          group: gettext('Advanced'),
          schema: [{
            id: 'like_relation', label: gettext('Relation'),
            type: 'text', mode: ['create', 'edit'], deps: ['typname'],
            control: 'node-ajax-options', url: 'get_relations',
            disabled: 'isLikeDisable', group: gettext('Like')
          }, {
            id: 'like_default_value', label: gettext('With default values?'),
            type: 'switch', mode: ['create', 'edit'], deps: ['typname'],
            disabled: 'isLikeDisable', group: gettext('Like')
          }, {
            id: 'like_constraints', label: gettext('With constraints?'),
            type: 'switch', mode: ['create', 'edit'], deps: ['typname'],
            disabled: 'isLikeDisable', group: gettext('Like')
          }, {
            id: 'like_indexes', label: gettext('With indexes?'),
            type: 'switch', mode: ['create', 'edit'], deps: ['typname'],
            disabled: 'isLikeDisable', group: gettext('Like')
          }, {
            id: 'like_storage', label: gettext('With storage?'),
            type: 'switch', mode: ['create', 'edit'], deps: ['typname'],
            disabled: 'isLikeDisable', group: gettext('Like')
          }, {
            id: 'like_comments', label: gettext('With comments?'),
            type: 'switch', mode: ['create', 'edit'], deps: ['typname'],
            disabled: 'isLikeDisable', group: gettext('Like')
          }]
        }, {
          id: 'partition_type', label: gettext('Partition Type'),
          editable: false, type: 'select2', select2: { allowClear: false },
          group: 'partition', deps: ['is_partitioned'],
          options: [{
            label: 'Range', value: 'range'
          }, {
            label: 'List', value: 'list'
          }],
          mode: ['create'],
          visible: function visible(m) {
            if (!_.isUndefined(m.node_info) && !_.isUndefined(m.node_info.server) && !_.isUndefined(m.node_info.server.version) && m.node_info.server.version >= 100000) return true;

            return false;
          },
          disabled: function disabled(m) {
            if (!m.isNew() || !m.get('is_partitioned')) return true;
            return false;
          }
        }, {
          id: 'partition_keys', label: gettext('Partition Keys'),
          model: Backform.PartitionKeyModel,
          subnode: Backform.PartitionKeyModel,
          editable: true, type: 'collection',
          group: 'partition', mode: ['create'],
          deps: ['is_partitioned', 'partition_type', 'typname'],
          canEdit: false, canDelete: true,
          control: 'sub-node-collection',
          canAdd: function canAdd(m) {
            if (m.isNew() && m.get('is_partitioned')) return true;
            return false;
          },
          canAddRow: function canAddRow(m) {
            var columns = m.get('columns'),
                typename = m.get('typname'),
                columns_exist = false;

            var max_row_count = 1000;
            if (m.get('partition_type') && m.get('partition_type') == 'list') max_row_count = 1;

            /* If columns are not specified by the user then it may be
             * possible that he/she selected 'OF TYPE', so we should check
             * for that as well.
             */
            if (columns.length <= 0 && !_.isUndefined(typename) && !_.isNull(typename) && m.of_types_tables.length > 0) {
              _.each(m.of_types_tables, function (data) {
                if (data.label == typename && data.oftype_columns.length > 0) {
                  columns_exist = true;
                }
              });
            } else if (columns.length > 0) {
              columns_exist = _.some(columns.pluck('name'));
            }

            return m.get('partition_keys') && m.get('partition_keys').length < max_row_count && columns_exist;
          },
          visible: function visible(m) {
            if (!_.isUndefined(m.node_info) && !_.isUndefined(m.node_info.server) && !_.isUndefined(m.node_info.server.version) && m.node_info.server.version >= 100000) return true;

            return false;
          },
          disabled: function disabled(m) {
            if (m.get('partition_keys') && m.get('partition_keys').models.length > 0) {
              setTimeout(function () {
                var coll = m.get('partition_keys');
                coll.remove(coll.filter(function (model) {
                  return true;
                }));
              }, 10);
            }
          }
        }, {
          id: 'partition_scheme', label: gettext('Partition Scheme'),
          type: 'note', group: 'partition', mode: ['edit'],
          visible: function visible(m) {
            if (!_.isUndefined(m.node_info) && !_.isUndefined(m.node_info.server) && !_.isUndefined(m.node_info.server.version) && m.node_info.server.version >= 100000) return true;

            return false;
          },
          disabled: function disabled(m) {
            if (!m.isNew()) {
              this.text = m.get('partition_scheme');
            }
          }
        }, {
          id: 'partition_key_note', label: gettext('Partition Keys'),
          type: 'note', group: 'partition', mode: ['create'],
          text: ['<br>&nbsp;&nbsp;', gettext('Partition table supports two types of keys:'), '<br><ul><li>', gettext('Column: User can select any column from the list of available columns.'), '</li><li>', gettext('Expression: User can specify expression to create partition key.'), '<br><p>', gettext('Example'), ':', gettext("Let's say, we want to create a partition table based per year for the column 'saledate', having datatype 'date/timestamp', then we need to specify the expression as 'extract(YEAR from saledate)' as partition key."), '</p></li></ul>'].join(''),
          visible: function visible(m) {
            if (!_.isUndefined(m.node_info) && !_.isUndefined(m.node_info.server) && !_.isUndefined(m.node_info.server.version) && m.node_info.server.version >= 100000) return true;

            return false;
          }
        }, {
          id: 'partitions', label: gettext('Partitions'),
          model: Backform.PartitionsModel,
          subnode: Backform.PartitionsModel,
          editable: true, type: 'collection',
          group: 'partition', mode: ['edit', 'create'],
          deps: ['is_partitioned', 'partition_type', 'typname'],
          canEdit: false, canDelete: true,
          customDeleteTitle: gettext('Detach Partition'),
          customDeleteMsg: gettext('Are you sure you wish to detach this partition?'),
          columns: ['is_attach', 'partition_name', 'values_from', 'values_to', 'values_in'],
          control: Backform.SubNodeCollectionControl.extend({
            row: Backgrid.PartitionRow,
            initialize: function initialize() {
              Backform.SubNodeCollectionControl.prototype.initialize.apply(this, arguments);
              var self = this;
              if (!this.model.isNew()) {
                var node = this.field.get('schema_node'),
                    node_info = this.field.get('node_info');

                // Make ajax call to get the tables to be attached
                $.ajax({
                  url: node.generate_url.apply(node, [null, 'get_attach_tables', this.field.get('node_data'), true, node_info]),

                  type: 'GET',
                  async: false,
                  success: function success(res) {
                    if (res.success == 1) {
                      self.model.table_options = res.data;
                    } else {
                      alertify.alert('Error fetching tables to be attached', res.data.result);
                    }
                  },
                  error: function error(e) {
                    var errmsg = $.parseJSON(e.responseText);
                    alertify.alert('Error fetching tables to be attached.', errmsg.errormsg);
                  }
                });
              }
            }
          }),
          canAdd: function canAdd(m) {
            if (m.get('is_partitioned')) return true;
            return false;
          },
          visible: function visible(m) {
            if (!_.isUndefined(m.node_info) && !_.isUndefined(m.node_info.server) && !_.isUndefined(m.node_info.server.version) && m.node_info.server.version >= 100000) return true;

            return false;
          },
          disabled: function disabled(m) {
            if (m.isNew() && m.get('partitions') && m.get('partitions').models.length > 0) {
              setTimeout(function () {
                var coll = m.get('partitions');
                coll.remove(coll.filter(function (model) {
                  return true;
                }));
              }, 10);
            }
          }
        }, {
          id: 'partition_note', label: gettext('Partitions'),
          type: 'note', group: 'partition',
          text: ['<ul>', ' <li>', gettext('Create a table: User can create multiple partitions while creating new partitioned table. Operation switch is disabled in this scenario.'), '</li><li>', gettext('Edit existing table: User can create/attach/detach multiple partitions. In attach operation user can select table from the list of suitable tables to be attached.'), '</li><li>', gettext('From/To/In input: Values for these fields must be quoted with single quote. For more than one partition key values must be comma(,) separated.'), '<br>', gettext('Example'), ':<ul><li>', gettext("From/To: Enabled for range partition. Consider partitioned table with multiple keys of type Integer, then values should be specified like '100','200'."), '</li><li> ', gettext('In: Enabled for list partition. Values must be comma(,) separated and quoted with single quote.'), '</li></ul></li></ul>'].join(''),
          visible: function visible(m) {
            if (!_.isUndefined(m.node_info) && !_.isUndefined(m.node_info.server) && !_.isUndefined(m.node_info.server.version) && m.node_info.server.version >= 100000) return true;

            return false;
          }
        }, {
          // Here - we will create tab control for storage parameters
          // (auto vacuum).
          type: 'nested', control: 'tab', group: gettext('Parameter'),
          mode: ['edit', 'create'], deps: ['is_partitioned'],
          schema: Backform.VacuumSettingsSchema
        }, {
          id: 'relacl_str', label: gettext('Privileges'), disabled: 'inSchema',
          type: 'text', mode: ['properties'], group: gettext('Security')
        }, pgBrowser.SecurityGroupSchema, {
          id: 'relacl', label: gettext('Privileges'), type: 'collection',
          group: 'security', control: 'unique-col-collection',
          model: pgBrowser.Node.PrivilegeRoleModel.extend({
            privileges: ['a', 'r', 'w', 'd', 'D', 'x', 't'] }),
          mode: ['edit', 'create'], canAdd: true, canDelete: true,
          uniqueCol: ['grantee']
        }, {
          id: 'seclabels', label: gettext('Security labels'), canEdit: false,
          model: pgBrowser.SecLabelModel, editable: false, canAdd: true,
          type: 'collection', min_version: 90100, mode: ['edit', 'create'],
          group: 'security', canDelete: true, control: 'unique-col-collection'
        }, {
          id: 'vacuum_settings_str', label: gettext('Storage settings'),
          type: 'multiline', group: gettext('Advanced'), mode: ['properties']
        }],
        validate: function validate(keys) {
          var err = {},
              changedAttrs = this.changed,
              msg = undefined,
              name = this.get('name'),
              schema = this.get('schema'),
              relowner = this.get('relowner'),
              is_partitioned = this.get('is_partitioned'),
              partition_keys = this.get('partition_keys');

          if (_.isUndefined(name) || _.isNull(name) || String(name).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Table name cannot be empty.');
            this.errorModel.set('name', msg);
            return msg;
          }
          this.errorModel.unset('name');
          if (_.isUndefined(schema) || _.isNull(schema) || String(schema).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Table schema cannot be empty.');
            this.errorModel.set('schema', msg);
            return msg;
          }
          this.errorModel.unset('schema');
          if (_.isUndefined(relowner) || _.isNull(relowner) || String(relowner).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Table owner cannot be empty.');
            this.errorModel.set('relowner', msg);
            return msg;
          }
          this.errorModel.unset('relowner');
          if (is_partitioned && this.isNew() && !_.isNull(partition_keys) && partition_keys.length <= 0) {
            msg = gettext('Please specify at least one key for partitioned table.');
            this.errorModel.set('partition_keys', msg);
            return msg;
          }
          this.errorModel.unset('partition_keys');
          return null;
        },
        // We will disable everything if we are under catalog node
        inSchema: function inSchema() {
          if (this.node_info && 'catalog' in this.node_info) {
            return true;
          }
          return false;
        },
        isInheritedTable: function isInheritedTable(m) {
          if (!m.inSchema.apply(this, [m])) {
            if (!_.isUndefined(m.get('coll_inherits')) && m.get('coll_inherits').length != 0 || !_.isUndefined(m.get('typname')) && String(m.get('typname')).replace(/^\s+|\s+$/g, '') !== '') {
              // Either of_types or coll_inherits has value
              return false;
            } else {
              return true;
            }
          }
          return false;
        },
        // Oftype is defined?
        checkInheritance: function checkInheritance(m) {
          // Disabled if it is partitioned table
          if (m.get('is_partitioned')) {
            setTimeout(function () {
              m.set('coll_inherits', []);
            }, 10);
            return true;
          }

          // coll_inherits || typname
          if (!m.inSchema.apply(this, [m]) && (_.isUndefined(m.get('typname')) || _.isNull(m.get('typname')) || String(m.get('typname')).replace(/^\s+|\s+$/g, '') == '')) {
            return false;
          }
          return true;
        },
        // We will disable Like if ofType is defined
        isLikeDisable: function isLikeDisable(m) {
          if (!m.inSchemaWithModelCheck.apply(this, [m]) && (_.isUndefined(m.get('typname')) || _.isNull(m.get('typname')) || String(m.get('typname')).replace(/^\s+|\s+$/g, '') == '')) {
            return false;
          }
          return true;
        },
        // Check for column grid when to Add
        check_grid_add_condition: function check_grid_add_condition(m) {
          var enable_flag = true;
          if (!m.inSchema.apply(this, [m])) {
            // if of_type then disable add in grid
            if (!_.isUndefined(m.get('typname')) && !_.isNull(m.get('typname')) && m.get('typname') !== '') {
              enable_flag = false;
            }
          }
          return enable_flag;
        },
        // Check for column grid when to edit/delete (for each row)
        check_grid_row_edit_delete: function check_grid_row_edit_delete(m) {
          var flag = true;
          if (!_.isUndefined(m.get('inheritedfrom')) && !_.isNull(m.get('inheritedfrom')) && String(m.get('inheritedfrom')).replace(/^\s+|\s+$/g, '') !== '') {
            flag = false;
          }
          return flag;
        },
        // We will disable it if Inheritance is defined
        checkOfType: function checkOfType(m) {
          //coll_inherits || typname
          if (!m.inSchemaWithModelCheck.apply(this, [m]) && (_.isUndefined(m.get('coll_inherits')) || _.isNull(m.get('coll_inherits')) || String(m.get('coll_inherits')).replace(/^\s+|\s+$/g, '') == '')) {
            return false;
          }
          return true;
        },
        // We will check if we are under schema node & in 'create' mode
        inSchemaWithModelCheck: function inSchemaWithModelCheck(m) {
          if (this.node_info && 'schema' in this.node_info) {
            // We will disbale control if it's in 'edit' mode
            if (m.isNew()) {
              return false;
            } else {
              return true;
            }
          }
          return true;
        },
        isTableAutoVacuumEnable: function isTableAutoVacuumEnable(m) {
          // We need to check additional condition to toggle enable/disable
          // for table auto-vacuum
          if (!m.inSchema.apply(this, [m]) && m.get('autovacuum_enabled') === true) {
            return false;
          }
          return true;
        },
        isToastTableAutoVacuumEnable: function isToastTableAutoVacuumEnable(m) {
          // We need to check additional condition to toggle enable/disable
          // for toast table auto-vacuum
          if (!m.inSchemaWithModelCheck.apply(this, [m]) && m.get('toast_autovacuum_enabled') == true) {
            return false;
          }
          return true;
        },
        fetch_columns_ajax: function fetch_columns_ajax(arg) {
          var self = this,
              url = 'get_columns',
              m = self.model.top || self.model,
              old_columns = _.clone(m.get('columns')),
              data = undefined,
              node = this.field.get('schema_node'),
              node_info = this.field.get('node_info'),
              full_url = node.generate_url.apply(node, [null, url, this.field.get('node_data'), this.field.get('url_with_id') || false, node_info]),
              cache_level = this.field.get('cache_level') || node.type,
              cache_node = this.field.get('cache_node');

          cache_node = cache_node && pgBrowser.Nodes['cache_node'] || node;

          m.trigger('pgadmin:view:fetching', m, self.field);
          // Fetching Columns data for the selected table.
          $.ajax({
            async: false,
            url: full_url,
            data: arg,
            success: function success(res) {
              data = cache_node.cache(url, node_info, cache_level, res.data);
            },
            error: function error() {
              m.trigger('pgadmin:view:fetch:error', m, self.field);
            }
          });
          m.trigger('pgadmin:view:fetched', m, self.field);
          data = data && data.data || [];
          return data;
        }
      }),
      canCreate: function canCreate(itemData, item, data) {
        //If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData;
        // To iterate over tree to check parent node
        while (i) {
          // If it is schema then allow user to create table
          if (_.indexOf(['schema'], d._type) > -1) return true;

          if ('coll-table' == d._type) {
            //Check if we are not child of catalog
            var prev_i = t.hasParent(i) ? t.parent(i) : null,
                prev_d = prev_i ? t.itemData(prev_i) : null;
            if (prev_d._type == 'catalog') {
              return false;
            } else {
              return true;
            }
          }
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // by default we do not want to allow create menu
        return true;
      },
      // Check to whether table has disable trigger(s)
      canCreate_with_trigger_enable: function canCreate_with_trigger_enable(itemData, item, data) {
        if (this.canCreate.apply(this, [itemData, item, data])) {
          // We are here means we can create menu, now let's check condition
          if (itemData.tigger_count > 0) {
            return true;
          } else {
            return false;
          }
        }
      },
      // Check to whether table has enable trigger(s)
      canCreate_with_trigger_disable: function canCreate_with_trigger_disable(itemData, item, data) {
        if (this.canCreate.apply(this, [itemData, item, data])) {
          // We are here means we can create menu, now let's check condition
          if (itemData.tigger_count > 0 && itemData.has_enable_triggers > 0) {
            return true;
          } else {
            return false;
          }
        }
      },
      onTableUpdated: function onTableUpdated(_node, _oldNodeData, _newNodeData) {
        if (_newNodeData.is_partitioned && 'affected_partitions' in _newNodeData) {
          var partitions = _newNodeData.affected_partitions,
              idx,
              node_info,
              self = this,
              newPartitionsIDs = [],
              insertChildTreeNodes = [],
              insertChildrenNodes = function insertChildrenNodes() {
            if (!insertChildTreeNodes.length) return;
            var option = insertChildTreeNodes.pop();
            pgBrowser.addChildTreeNodes(option.treeHierarchy, option.parent, option.type, option.childrenIDs, insertChildrenNodes);
          };

          if ('detached' in partitions && partitions.detached.length > 0) {
            // Remove it from the partition collections node first
            pgBrowser.removeChildTreeNodesById(_node, 'coll-partition', _.map(partitions.detached, function (_d) {
              return parseInt(_d.oid);
            }));

            var schemaNode = pgBrowser.findParentTreeNodeByType(_node, 'schema'),
                detachedBySchema = _.groupBy(partitions.detached, function (_d) {
              return parseInt(_d.schema_id);
            }),
                childIDs;

            for (var key in detachedBySchema) {
              schemaNode = pgBrowser.findSiblingTreeNode(schemaNode, key);

              if (schemaNode) {
                childIDs = _.map(detachedBySchema[key], function (_d) {
                  return parseInt(_d.oid);
                });

                var tablesCollNode = pgBrowser.findChildCollectionTreeNode(schemaNode, 'coll-table');

                if (tablesCollNode) {
                  insertChildTreeNodes.push({
                    'parent': tablesCollNode,
                    'type': 'table',
                    'treeHierarchy': pgAdmin.Browser.Nodes.schema.getTreeNodeHierarchy(schemaNode),
                    'childrenIDs': _.clone(childIDs)
                  });
                }
              }
            }
          }

          if ('attached' in partitions && partitions.attached.length > 0) {
            var schemaNode = pgBrowser.findParentTreeNodeByType(_node, 'schema'),
                attachedBySchema = _.groupBy(partitions.attached, function (_d) {
              return parseInt(_d.schema_id);
            }),
                childIDs;

            for (var key in attachedBySchema) {
              schemaNode = pgBrowser.findSiblingTreeNode(schemaNode, key);

              if (schemaNode) {
                childIDs = _.map(attachedBySchema[key], function (_d) {
                  return parseInt(_d.oid);
                });
                // Remove it from the table collections node first
                pgBrowser.removeChildTreeNodesById(schemaNode, 'coll-table', childIDs);
              }
              newPartitionsIDs = newPartitionsIDs.concat(childIDs);
            }
          }

          if ('created' in partitions && partitions.created.length > 0) {
            _.each(partitions.created, function (_data) {
              newPartitionsIDs.push(_data.oid);
            });
          }

          if (newPartitionsIDs.length) {
            node_info = self.getTreeNodeHierarchy(_node);

            var partitionsCollNode = pgBrowser.findChildCollectionTreeNode(_node, 'coll-partition');

            if (partitionsCollNode) {
              insertChildTreeNodes.push({
                'parent': partitionsCollNode,
                'type': 'partition',
                'treeHierarchy': self.getTreeNodeHierarchy(_node),
                'childrenIDs': newPartitionsIDs
              });
            }
          }
          insertChildrenNodes();
        }
      }
    });
  }

  return pgBrowser.Nodes['table'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backgrid, Backbone) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(16), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, Backform, alertify) {

  if (!pgBrowser.Nodes['coll-column']) {
    var databases = pgBrowser.Nodes['coll-column'] = pgBrowser.Collection.extend({
      node: 'column',
      label: gettext('Columns'),
      type: 'coll-column',
      columns: ['name', 'atttypid', 'description']
    });
  };

  // This Node model will be used for variable control for column
  var VariablesModel = Backform.VariablesModel = pgBrowser.Node.Model.extend({
    idAttribute: 'name',
    defaults: {
      name: null,
      value: null
    },
    schema: [{
      id: 'name', label: gettext('Name'), cell: 'select2',
      type: 'text', disabled: false, node: 'column',
      options: [['n_distinct', 'n_distinct'], ['n_distinct_inherited', 'n_distinct_inherited']],
      select2: { placeholder: "Select variable" },
      cellHeaderClasses: 'width_percent_50'
    }, {
      id: 'value', label: gettext('Value'),
      type: 'text', disabled: false,
      cellHeaderClasses: 'width_percent_50'
    }],
    validate: function validate() {
      var err = {},
          errmsg = null;

      if (_.isUndefined(this.get('value')) || _.isNull(this.get('value')) || String(this.get('value')).replace(/^\s+|\s+$/g, '') == '') {
        errmsg = gettext('Please provide input for variable.');
        this.errorModel.set('value', errmsg);
        return errmsg;
      } else {
        this.errorModel.unset('value');
      }
      return null;
    }
  });

  // Integer Cell for Columns Length and Precision
  var IntegerDepCell = Backgrid.Extension.IntegerDepCell = Backgrid.IntegerCell.extend({
    initialize: function initialize() {
      Backgrid.NumberCell.prototype.initialize.apply(this, arguments);
      Backgrid.Extension.DependentCell.prototype.initialize.apply(this, arguments);
    },
    dependentChanged: function dependentChanged() {
      this.$el.empty();
      var model = this.model,
          column = this.column,
          editable = this.column.get("editable"),
          is_editable = _.isFunction(editable) ? !!editable.apply(column, [model]) : !!editable;

      if (is_editable) {
        this.$el.addClass("editable");
      } else {
        this.$el.removeClass("editable");
      }

      this.delegateEvents();
      return this;
    },
    render: function render() {
      Backgrid.NumberCell.prototype.render.apply(this, arguments);

      var model = this.model,
          column = this.column,
          editable = this.column.get("editable"),
          is_editable = _.isFunction(editable) ? !!editable.apply(column, [model]) : !!editable;

      if (is_editable) {
        this.$el.addClass("editable");
      } else {
        this.$el.removeClass("editable");
      }
      return this;
    },
    remove: Backgrid.Extension.DependentCell.prototype.remove
  });

  if (!pgBrowser.Nodes['column']) {
    pgBrowser.Nodes['column'] = pgBrowser.Node.extend({
      getTreeNodeHierarchy: pgBrowser.tableChildTreeNodeHierarchy,
      parent_type: ['table', 'view', 'mview'],
      collection_type: ['coll-table', 'coll-view', 'coll-mview'],
      type: 'column',
      label: gettext('Column'),
      hasSQL: true,
      sqlAlterHelp: 'sql-altertable.html',
      sqlCreateHelp: 'sql-altertable.html',
      dialogHelp: url_for('help.static', { 'filename': 'column_dialog.html' }),
      canDrop: function canDrop(itemData, item, data) {
        if (pgBrowser.Nodes['schema'].canChildDrop.apply(this, [itemData, item, data])) {
          var t = pgBrowser.tree,
              i = item,
              d = itemData,
              parents = [];
          // To iterate over tree to check parent node
          while (i) {
            parents.push(d._type);
            i = t.hasParent(i) ? t.parent(i) : null;
            d = i ? t.itemData(i) : null;
          }

          // Check if menu is allowed ?
          if (_.indexOf(parents, 'catalog') > -1 || _.indexOf(parents, 'view') > -1 || _.indexOf(parents, 'mview') > -1) {
            return false;
          } else if (_.indexOf(parents, 'table') > -1) {
            return true;
          }
        } else {
          return false;
        }
      },
      hasDepends: true,
      hasStatistics: true,
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_column_on_coll', node: 'coll-column', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Column...'),
          icon: 'wcTabIcon icon-column', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_column', node: 'column', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Column...'),
          icon: 'wcTabIcon icon-column', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_column_onTable', node: 'table', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Column...'),
          icon: 'wcTabIcon icon-column', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'create_column_onView', node: 'view', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Column...'),
          icon: 'wcTabIcon icon-column', data: { action: 'create', check: true },
          enable: 'canCreate'
        }]);
      },
      model: pgBrowser.Node.Model.extend({
        idAttribute: 'attnum',

        defaults: {
          name: undefined,
          attowner: undefined,
          atttypid: undefined,
          attnum: undefined,
          cltype: undefined,
          collspcname: undefined,
          attacl: undefined,
          description: undefined,
          parent_tbl: undefined,
          min_val: undefined,
          max_val: undefined,
          edit_types: undefined,
          is_primary_key: false,
          inheritedfrom: undefined,
          attstattarget: undefined,
          attnotnull: false,
          attlen: null,
          attprecision: null
        },
        schema: [{
          id: 'name', label: gettext('Name'), cell: 'string',
          type: 'text', disabled: 'inSchemaWithColumnCheck',
          cellHeaderClasses: 'width_percent_30',
          editable: 'editable_check_for_table'
        }, {
          // Need to show this field only when creating new table
          // [in SubNode control]
          id: 'is_primary_key', label: gettext('Primary key?'),
          cell: Backgrid.Extension.TableChildSwitchCell, type: 'switch',
          deps: ['name'], cellHeaderClasses: 'width_percent_5',
          options: {
            onText: gettext('Yes'), offText: gettext('No'),
            onColor: 'success', offColor: 'primary'
          },
          visible: function visible(m) {
            return _.isUndefined(m.top.node_info['table'] || m.top.node_info['view'] || m.top.node_info['mview']);
          },
          disabled: function disabled(m) {
            // Disable it, when one of this:
            // - Primary key already exist
            // - Table is a partitioned table
            if (m.top && (!_.isUndefined(m.top.get('oid')) && m.top.get('primary_key').length > 0 && !_.isUndefined(m.top.get('primary_key').first().get('oid')) || m.top.has('is_partitioned') && m.top.get('is_partitioned'))) {
              return true;
            }

            var name = m.get('name');

            if (!m.inSchemaWithColumnCheck.apply(this, [m]) && (_.isUndefined(name) || _.isNull(name) || name == '')) {
              return true;
            }
            return false;
          },
          editable: function editable(m) {
            var name = m.get('name');
            // If HeaderCell then allow True
            if (m instanceof Backbone.Collection) {
              return true;
            }
            // If primary key already exist then disable.
            if (m.top && !_.isUndefined(m.top.get('oid')) && m.top.get('primary_key').length > 0 && !_.isUndefined(m.top.get('primary_key').first().get('oid'))) {

              return false;
            }

            // If table is partitioned table then disable
            if (m.top && !_.isUndefined(m.top.get('is_partitioned')) && m.top.get('is_partitioned')) {
              setTimeout(function () {
                m.set('is_primary_key', false);
              }, 10);

              return false;
            }

            if (!m.inSchemaWithColumnCheck.apply(this, [m]) && !_.isUndefined(name) && !_.isNull(name) && name !== '') {
              return true;
            }
            return false;
            // Set to false if no condition is met
            m.set('is_primary_key', false);
          }
        }, {
          id: 'attnum', label: gettext('Position'), cell: 'string',
          type: 'text', disabled: 'notInSchema', mode: ['properties']
        }, {
          id: 'cltype', label: gettext('Data type'),
          cell: Backgrid.Extension.NodeAjaxOptionsCell.extend({
            exitEditMode: function exitEditMode(e) {
              var self = this;
              this.$select.off('blur', this.exitEditMode);
              this.$select.select2('close');
              this.$el.removeClass('editor');
              // Once user have selected a value
              // we can shift to next cell if it is editable
              var next_cell,
                  length_cell = this.$el.next(),
                  not_null_cell = this.$el.next().next().next();

              // Add delay so that Select2 cell tab event is captured
              // first before triggerring backgrid:edited event.
              setTimeout(function () {
                // First check Length column if it is disable then goto
                // Not Null column
                if (length_cell && length_cell.hasClass('editable') && e) {
                  next_cell = length_cell;
                } else if (not_null_cell && not_null_cell.hasClass('editable') && e) {
                  next_cell = not_null_cell;
                }

                if (next_cell) {
                  e.preventDefault();
                  e.stopPropagation();
                  var command = new Backgrid.Command({ key: "Tab", keyCode: 9, which: 9 });
                  self.model.trigger("backgrid:edited", self.model, self.column, command);
                  next_cell.focus();
                }
              }, 20);
            }
          }),
          type: 'text', disabled: 'inSchemaWithColumnCheck',
          control: 'node-ajax-options', url: 'get_types', node: 'table',
          cellHeaderClasses: 'width_percent_30', first_empty: true,
          select2: { allowClear: false }, group: gettext('Definition'),
          transform: function transform(data, cell) {
            /* 'transform' function will be called by control, and cell both.
             * The way, we use the transform in cell, and control is different.
             * Because - options are shared using 'column' object in backgrid,
             * hence - the cell is passed as second parameter, while the control
             * uses (this) as a object.
             */
            var control = cell || this,
                m = control.model;

            /* We need different data in create mode & in edit mode
             * if we are in create mode then return data as it is
             * if we are in edit mode then we need to filter data
             */
            control.model.datatypes = data;
            var edit_types = m.get('edit_types'),
                result = [];

            // If called from Table, We will check if in edit mode
            // then send edit_types only
            if (!_.isUndefined(m.top) && !m.top.isNew()) {
              _.each(data, function (t) {
                if (_.indexOf(edit_types, t.value) != -1) {
                  result.push(t);
                }
              });
              // There may be case that user adds new column in  existing collection
              // we will not have edit types then
              return result.length > 0 ? result : data;
            }

            // If called from Column
            if (m.isNew()) {
              return data;
            } else {
              //edit mode
              _.each(data, function (t) {
                if (_.indexOf(edit_types, t.value) != -1) {
                  result.push(t);
                }
              });

              return result;
            }
          },
          editable: 'editable_check_for_table'
        }, {
          // Need to show this field only when creating new table [in SubNode control]
          id: 'inheritedfrom', label: gettext('Inherited from table'),
          type: 'text', disabled: true, editable: false,
          cellHeaderClasses: 'width_percent_10',
          visible: function visible(m) {
            return _.isUndefined(m.top.node_info['table'] || m.top.node_info['view'] || m.top.node_info['mview']);
          }
        }, {
          id: 'attlen', label: gettext('Length'), cell: IntegerDepCell,
          deps: ['cltype'], type: 'int', group: gettext('Definition'), cellHeaderClasses: 'width_percent_20',
          disabled: function disabled(m) {
            var of_type = m.get('cltype'),
                flag = true;
            _.each(m.datatypes, function (o) {
              if (of_type == o.value) {
                if (o.length) {
                  m.set('min_val', o.min_val, { silent: true });
                  m.set('max_val', o.max_val, { silent: true });
                  flag = false;
                }
              }
            });

            flag && setTimeout(function () {
              if (m.get('attlen')) {
                m.set('attlen', null);
              }
            }, 10);

            return flag;
          },
          editable: function editable(m) {
            // inheritedfrom has value then we should disable it
            if (!_.isUndefined(m.get('inheritedfrom'))) {
              return false;
            }

            if (!m.datatypes) {
              // datatypes not loaded, may be this call is from CallByNeed from backgrid cell initialize.
              return true;
            }
            var of_type = m.get('cltype'),
                flag = false;

            _.each(m.datatypes, function (o) {
              if (of_type == o.value) {
                if (o.length) {
                  m.set('min_val', o.min_val, { silent: true });
                  m.set('max_val', o.max_val, { silent: true });
                  flag = true;
                }
              }
            });

            !flag && setTimeout(function () {
              if (m.get('attlen')) {
                m.set('attlen', null, { silent: true });
              }
            }, 10);

            return flag;
          }
        }, {
          id: 'attprecision', label: gettext('Precision'), cell: IntegerDepCell,
          deps: ['cltype'], type: 'int', group: gettext('Definition'), cellHeaderClasses: 'width_percent_20',
          disabled: function disabled(m) {
            var of_type = m.get('cltype'),
                flag = true;
            _.each(m.datatypes, function (o) {
              if (of_type == o.value) {
                if (o.precision) {
                  m.set('min_val', o.min_val, { silent: true });
                  m.set('max_val', o.max_val, { silent: true });
                  flag = false;
                }
              }
            });

            flag && setTimeout(function () {
              if (m.get('attprecision')) {
                m.set('attprecision', null);
              }
            }, 10);
            return flag;
          },
          editable: function editable(m) {
            // inheritedfrom has value then we should disable it
            if (!_.isUndefined(m.get('inheritedfrom'))) {
              return false;
            }

            if (!m.datatypes) {
              // datatypes not loaded yet, may be this call is from CallByNeed from backgrid cell initialize.
              return true;
            }

            var of_type = m.get('cltype'),
                flag = false;
            _.each(m.datatypes, function (o) {
              if (of_type == o.value) {
                if (o.precision) {
                  m.set('min_val', o.min_val, { silent: true });
                  m.set('max_val', o.max_val, { silent: true });
                  flag = true;
                }
              }
            });

            !flag && setTimeout(function () {
              if (m.get('attprecision')) {
                m.set('attprecision', null);
              }
            }, 10);

            return flag;
          }
        }, {
          id: 'collspcname', label: gettext('Collation'), cell: 'string',
          type: 'text', control: 'node-ajax-options', url: 'get_collations',
          group: gettext('Definition'), node: 'collation',
          deps: ['cltype'], disabled: function disabled(m) {
            var of_type = m.get('cltype'),
                flag = true;
            _.each(m.datatypes, function (o) {
              if (of_type == o.value) {
                if (o.is_collatable) {
                  flag = false;
                }
              }
            });
            if (flag) {
              setTimeout(function () {
                if (m.get('collspcname') && m.get('collspcname') !== '') {
                  m.set('collspcname', "");
                }
              }, 10);
            }
            return flag;
          }
        }, {
          id: 'defval', label: gettext('Default Value'), cell: 'string',
          type: 'text', group: gettext('Definition'), deps: ['cltype'],
          disabled: function disabled(m) {
            if (!m.inSchemaWithModelCheck.apply(this, [m])) {
              var type = m.get('cltype');
              return type == 'serial' || type == 'bigserial' || type == 'smallserial';
            }
          }
        }, {
          id: 'attnotnull', label: gettext('Not NULL?'), cell: 'switch',
          type: 'switch', disabled: 'inSchemaWithColumnCheck', cellHeaderClasses: 'width_percent_20',
          group: gettext('Definition'), editable: 'editable_check_for_table',
          options: { onText: 'Yes', offText: 'No', onColor: 'success', offColor: 'primary' }
        }, {
          id: 'attstattarget', label: gettext('Statistics'), cell: 'string',
          type: 'text', disabled: 'inSchemaWithColumnCheck', mode: ['properties', 'edit'],
          group: gettext('Definition')
        }, {
          id: 'attstorage', label: gettext('Storage'), group: gettext('Definition'),
          type: 'text', mode: ['properties', 'edit'],
          cell: 'string', disabled: 'inSchemaWithColumnCheck', first_empty: true,
          control: 'select2', select2: { placeholder: "Select storage",
            allowClear: false,
            width: "100%"
          },
          options: [{ label: "PLAIN", value: "p" }, { label: "MAIN", value: "m" }, { label: "EXTERNAL", value: "e" }, { label: "EXTENDED", value: "x" }]
        }, {
          id: 'is_pk', label: gettext('Primary key?'),
          type: 'switch', disabled: true, mode: ['properties'],
          group: gettext('Definition')
        }, {
          id: 'is_fk', label: gettext('Foreign key?'),
          type: 'switch', disabled: true, mode: ['properties'],
          group: gettext('Definition')
        }, {
          id: 'is_inherited', label: gettext('Inherited?'),
          type: 'switch', disabled: true, mode: ['properties'],
          group: gettext('Definition')
        }, {
          id: 'tbls_inherited', label: gettext('Inherited from table(s)'),
          type: 'text', disabled: true, mode: ['properties'], deps: ['is_inherited'],
          group: gettext('Definition'),
          visible: function visible(m) {
            if (!_.isUndefined(m.get('is_inherited')) && m.get('is_inherited')) {
              return true;
            } else {
              return false;
            }
          }
        }, {
          id: 'is_sys_column', label: gettext('System column?'), cell: 'string',
          type: 'switch', disabled: true, mode: ['properties']
        }, {
          id: 'description', label: gettext('Comment'), cell: 'string',
          type: 'multiline', mode: ['properties', 'create', 'edit'],
          disabled: 'notInSchema'
        }, {
          id: 'attoptions', label: 'Variables', type: 'collection',
          group: gettext('Variables'), control: 'unique-col-collection',
          model: VariablesModel, uniqueCol: ['name'],
          mode: ['edit', 'create'], canAdd: true, canEdit: false,
          canDelete: true
        }, pgBrowser.SecurityGroupSchema, {
          id: 'attacl', label: 'Privileges', type: 'collection',
          group: 'security', control: 'unique-col-collection',
          model: pgBrowser.Node.PrivilegeRoleModel.extend({
            privileges: ['a', 'r', 'w', 'x'] }),
          mode: ['edit'], canAdd: true, canDelete: true,
          uniqueCol: ['grantee']
        }, {
          id: 'seclabels', label: gettext('Security Labels'), canAdd: true,
          model: pgBrowser.SecLabelModel, group: 'security',
          mode: ['edit', 'create'], editable: false, type: 'collection',
          min_version: 90100, canEdit: false, canDelete: true,
          control: 'unique-col-collection'
        }],
        validate: function validate(keys) {
          var err = {},
              changedAttrs = this.changed,
              msg = undefined;

          // Nothing to validate
          if (keys && keys.length == 0) {
            this.errorModel.clear();
            return null;
          } else {
            this.errorModel.clear();
          }

          if (_.isUndefined(this.get('name')) || String(this.get('name')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Column name cannot be empty.');
            this.errorModel.set('name', msg);
            return msg;
          }

          if (_.isUndefined(this.get('cltype')) || String(this.get('cltype')).replace(/^\s+|\s+$/g, '') == '') {
            msg = gettext('Column type cannot be empty.');
            this.errorModel.set('cltype', msg);
            return msg;
          }

          if (!_.isUndefined(this.get('cltype')) && !_.isUndefined(this.get('attlen')) && !_.isNull(this.get('attlen')) && this.get('attlen') !== '') {
            // Validation for Length field
            if (this.get('attlen') < this.get('min_val')) msg = gettext('Length should not be less than: ') + this.get('min_val');
            if (this.get('attlen') > this.get('max_val')) msg = gettext('Length should not be greater than: ') + this.get('max_val');
            // If we have any error set then throw it to user
            if (msg) {
              this.errorModel.set('attlen', msg);
              return msg;
            }
          }

          if (!_.isUndefined(this.get('cltype')) && !_.isUndefined(this.get('attprecision')) && !_.isNull(this.get('attprecision')) && this.get('attprecision') !== '') {
            // Validation for precision field
            if (this.get('attprecision') < this.get('min_val')) msg = gettext('Precision should not be less than: ') + this.get('min_val');
            if (this.get('attprecision') > this.get('max_val')) msg = gettext('Precision should not be greater than: ') + this.get('max_val');
            // If we have any error set then throw it to user
            if (msg) {
              this.errorModel.set('attprecision', msg);
              return msg;
            }
          }

          return null;
        },
        // We will check if we are under schema node & in 'create' mode
        notInSchema: function notInSchema() {
          if (this.node_info && 'catalog' in this.node_info) {
            return true;
          }
          return false;
        },
        // We will check if we are under schema node & in 'create' mode
        inSchemaWithModelCheck: function inSchemaWithModelCheck(m) {
          if (this.node_info && 'schema' in this.node_info) {
            // We will disable control if it's in 'edit' mode
            if (m.isNew()) {
              return false;
            } else {
              return true;
            }
          }
          return true;
        },
        // Checks weather to enable/disable control
        inSchemaWithColumnCheck: function inSchemaWithColumnCheck(m) {
          var node_info = this.node_info || m.node_info || m.top.node_info;

          // disable all fields if column is listed under view or mview
          if (node_info && ('view' in node_info || 'mview' in node_info)) {
            if (this && _.has(this, 'name') && this.name != 'defval') {
              return true;
            }
          }

          if (node_info && 'schema' in node_info) {
            // We will disable control if it's system columns
            // inheritedfrom check is useful when we use this schema in table node
            // inheritedfrom has value then we should disable it
            if (!_.isUndefined(m.get('inheritedfrom'))) {
              return true;
            }
            // ie: it's position is less then 1
            if (m.isNew()) {
              return false;
            }
            // if we are in edit mode
            if (!_.isUndefined(m.get('attnum')) && m.get('attnum') > 0) {
              return false;
            } else {
              return true;
            }
          }
          return true;
        },
        editable_check_for_table: function editable_check_for_table(arg) {
          if (arg instanceof Backbone.Collection) {
            return !arg.model.prototype.inSchemaWithColumnCheck.apply(this, [arg.top]);
          } else {
            return !arg.inSchemaWithColumnCheck.apply(this, [arg]);
          }
        }
      }),
      // Below function will enable right click menu for creating column
      canCreate: function canCreate(itemData, item, data) {
        // If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData,
            parents = [];
        // To iterate over tree to check parent node
        while (i) {
          // If it is schema then allow user to create table
          if (_.indexOf(['schema'], d._type) > -1) {
            return true;
          } else if (_.indexOf(['view', 'coll-view', 'mview', 'coll-mview'], d._type) > -1) {
            parents.push(d._type);
            break;
          }
          parents.push(d._type);
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // If node is under catalog then do not allow 'create' menu
        if (_.indexOf(parents, 'catalog') > -1 || _.indexOf(parents, 'coll-view') > -1 || _.indexOf(parents, 'coll-mview') > -1 || _.indexOf(parents, 'mview') > -1 || _.indexOf(parents, 'view') > -1) {
          return false;
        } else {
          return true;
        }
      }
    });
  }

  return pgBrowser.Nodes['column'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13), __webpack_require__(10)))

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(9), __webpack_require__(318), __webpack_require__(319), __webpack_require__(320), __webpack_require__(321), __webpack_require__(322)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, $, _, S, pgAdmin, pgBrowser) {

  if (!pgBrowser.Nodes['coll-constraints']) {
    var databases = pgAdmin.Browser.Nodes['coll-constraints'] = pgAdmin.Browser.Collection.extend({
      node: 'constraints',
      label: gettext('Constraints'),
      type: 'coll-constraints',
      getTreeNodeHierarchy: pgBrowser.tableChildTreeNodeHierarchy,
      columns: ['name', 'comment']
    });
  };

  if (!pgBrowser.Nodes['constraints']) {
    pgAdmin.Browser.Nodes['constraints'] = pgBrowser.Node.extend({
      getTreeNodeHierarchy: pgBrowser.tableChildTreeNodeHierarchy,
      type: 'constraints',
      label: gettext('Constraints'),
      collection_type: 'coll-constraints',
      parent_type: ['table', 'partition'],
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([]);
      },
      model: pgAdmin.Browser.Node.Model.extend({
        defaults: {
          name: undefined,
          oid: undefined,
          comment: undefined
        },
        schema: [{
          id: 'name', label: gettext('Name'), type: 'text',
          mode: ['properties', 'create', 'edit']
        }, {
          id: 'oid', label: gettext('Oid'), cell: 'string',
          type: 'text', mode: ['properties']
        }, {
          id: 'comment', label: gettext('Comment'), cell: 'string',
          type: 'multiline', mode: ['properties', 'create', 'edit']
        }]
      })
    });
  }

  return pgBrowser.Nodes['constraints'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backgrid) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  // Extend the browser's node class for index constraint node
  if (!pgBrowser.Nodes['unique_constraint']) {
    pgAdmin.Browser.Nodes['unique_constraint'] = pgBrowser.Node.extend({
      type: 'unique_constraint',
      label: gettext('Unique constraint'),
      collection_type: 'coll-constraints',
      sqlAlterHelp: 'ddl-alter.html',
      sqlCreateHelp: 'ddl-constraints.html',
      dialogHelp: url_for('help.static', { filename: 'unique_constraint_dialog.html' }),
      hasSQL: true,
      hasDepends: true,
      hasStatistics: true,
      statsPrettifyFields: ['Index size'],
      parent_type: ['table', 'partition'],
      canDrop: true,
      canDropCascade: true,
      getTreeNodeHierarchy: pgBrowser.tableChildTreeNodeHierarchy,
      Init: function Init() {
        /* Avoid multiple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_unique_constraint_on_coll', node: 'coll-constraints', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Unique constraint'),
          icon: 'wcTabIcon icon-unique_constraint', data: { action: 'create', check: true },
          enable: 'canCreate'

        }]);
      },
      canCreate: function canCreate(itemData, item, data) {
        // If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData,
            parents = [],
            immediate_parent_table_found = false,
            is_immediate_parent_table_partitioned = false;

        // To iterate over tree to check parent node
        while (i) {
          // If table is partitioned table then return false
          if (!immediate_parent_table_found && (d._type == 'table' || d._type == 'partition')) {
            immediate_parent_table_found = true;
            if ('is_partitioned' in d && d.is_partitioned) {
              is_immediate_parent_table_partitioned = true;
            }
          }

          // If it is schema then allow user to c reate table
          if (_.indexOf(['schema'], d._type) > -1) {
            return !is_immediate_parent_table_partitioned;
          }
          parents.push(d._type);
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // If node is under catalog then do not allow 'create' menu
        if (_.indexOf(parents, 'catalog') > -1) {
          return false;
        } else {
          return !is_immediate_parent_table_partitioned;
        }
      },

      // Define the model for index constraint node
      model: pgAdmin.Browser.Node.Model.extend({
        idAttribute: 'oid',

        defaults: {
          name: undefined,
          oid: undefined,
          comment: undefined,
          spcname: undefined,
          index: undefined,
          fillfactor: undefined,
          condeferrable: undefined,
          condeferred: undefined,
          columns: []
        },

        // Define the schema for the index constraint node
        schema: [{
          id: 'name', label: gettext('Name'), type: 'text',
          mode: ['properties', 'create', 'edit'], editable: true,
          cellHeaderClasses: 'width_percent_40'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', mode: ['properties'], editable: false,
          cellHeaderClasses: 'width_percent_20'
        }, {
          id: 'comment', label: gettext('Comment'), cell: 'string',
          type: 'multiline', mode: ['properties', 'create', 'edit'],
          deps: ['name'], disabled: function disabled(m) {
            var name = m.get('name');
            if (!(name && name != '')) {
              setTimeout(function () {
                if (m.get('comment') && m.get('comment') !== '') {
                  m.set('comment', null);
                }
              }, 10);
              return true;
            } else {
              return false;
            }
          }
        }, {
          id: 'columns', label: gettext('Columns'),
          type: 'collection', group: gettext('Definition'),
          editable: false,
          cell: Backgrid.StringCell.extend({
            initialize: function initialize() {
              Backgrid.StringCell.prototype.initialize.apply(this, arguments);

              var self = this,
                  collection = this.model.get('columns');

              // Do not listen for any event(s) for existing constraint.
              if (_.isUndefined(self.model.get('oid'))) {
                var tableCols = self.model.top.get('columns');
                self.listenTo(tableCols, 'remove', self.removeColumn);
                self.listenTo(tableCols, 'change:name', self.resetColOptions);
              }

              collection.on('pgadmin:multicolumn:updated', function () {
                self.render.apply(self);
              });
              self.listenTo(collection, "add", self.render);
              self.listenTo(collection, "remove", self.render);
            },
            removeColumn: function removeColumn(m) {
              var self = this,
                  removedCols = self.model.get('columns').where({ column: m.get('name') });

              self.model.get('columns').remove(removedCols);
              setTimeout(function () {
                self.render();
              }, 10);

              var key = 'unique_constraint';
              setTimeout(function () {
                constraints = self.model.top.get(key);
                var removed = [];
                constraints.each(function (constraint) {
                  if (constraint.get("columns").length == 0) {
                    removed.push(constraint);
                  }
                });
                constraints.remove(removed);
              }, 100);
            },
            resetColOptions: function resetColOptions(m) {
              var self = this,
                  updatedCols = self.model.get('columns').where({ column: m.previous('name') });
              if (updatedCols.length > 0) {
                /*
                 * Table column name has changed so update
                 * column name in primary key as well.
                 */
                updatedCols[0].set({ "column": m.get('name') }, { silent: true });
              }

              setTimeout(function () {
                self.render();
              }, 10);
            },
            formatter: {
              fromRaw: function fromRaw(rawValue, model) {
                return rawValue.pluck("column").toString();
              },
              toRaw: function toRaw(val, model) {
                return val;
              }
            },
            render: function render() {
              return Backgrid.StringCell.prototype.render.apply(this, arguments);
            },
            remove: function remove() {
              var tableCols = this.model.top.get('columns'),
                  primary_key_col = this.model.get('columns');

              if (primary_key_col) {
                primary_key_col.off('pgadmin:multicolumn:updated');
              }

              this.stopListening(tableCols, 'remove', self.removeColumn);
              this.stopListening(tableCols, 'change:name', self.resetColOptions);

              Backgrid.StringCell.prototype.remove.apply(this, arguments);
            }
          }),
          canDelete: true, canAdd: true,
          control: Backform.MultiSelectAjaxControl.extend({
            defaults: _.extend({}, Backform.NodeListByNameControl.prototype.defaults, {
              select2: {
                multiple: true,
                allowClear: true,
                width: 'style',
                placeholder: gettext('Select the column(s)')
              }
            }),
            keyPathAccessor: function keyPathAccessor(obj, path) {
              var res = obj;
              if (_.isArray(res)) {
                return _.map(res, function (o) {
                  return o['column'];
                });
              }
              path = path.split('.');
              for (var i = 0; i < path.length; i++) {
                if (_.isNull(res)) return null;
                if (_.isEmpty(path[i])) continue;
                if (!_.isUndefined(res[path[i]])) res = res[path[i]];
              }
              return _.isObject(res) && !_.isArray(res) ? null : res;
            },
            initialize: function initialize() {
              // Here we will decide if we need to call URL
              // Or fetch the data from parent columns collection
              var self = this;
              if (this.model.handler) {
                Backform.Select2Control.prototype.initialize.apply(this, arguments);
                // Do not listen for any event(s) for existing constraint.
                if (_.isUndefined(self.model.get('oid'))) {
                  var tableCols = self.model.top.get('columns');
                  self.listenTo(tableCols, 'remove', self.resetColOptions);
                  self.listenTo(tableCols, 'change:name', self.resetColOptions);
                }

                self.custom_options();
              } else {
                Backform.MultiSelectAjaxControl.prototype.initialize.apply(this, arguments);
              }
              self.model.get('columns').on('pgadmin:multicolumn:updated', function () {
                self.render.apply(self);
              });
            },
            resetColOptions: function resetColOptions(m) {
              var self = this;

              setTimeout(function () {
                self.custom_options();
                self.render.apply(self);
              }, 50);
            },
            custom_options: function custom_options() {
              // We will add all the columns entered by user in table model
              var columns = this.model.top.get('columns'),
                  added_columns_from_tables = [];

              if (columns.length > 0) {
                _.each(columns.models, function (m) {
                  var col = m.get('name');
                  if (!_.isUndefined(col) && !_.isNull(col)) {
                    added_columns_from_tables.push({ label: col, value: col, image: 'icon-column' });
                  }
                });
              }
              // Set the values in to options so that user can select
              this.field.set('options', added_columns_from_tables);
            },
            onChange: function onChange(e) {
              var self = this,
                  model = this.model,
                  $el = $(e.target),
                  attrArr = this.field.get("name").split('.'),
                  name = attrArr.shift(),
                  path = attrArr.join('.'),
                  vals = this.getValueFromDOM(),
                  collection = model.get(name),
                  removed = [];

              this.stopListening(this.model, "change:" + name, this.render);

              /*
               * Iterate through all the values, and find out how many are already
               * present in the collection.
               */
              collection.each(function (m) {
                var column = m.get('column'),
                    idx = _.indexOf(vals, column);

                if (idx > -1) {
                  vals.splice(idx, 1);
                } else {
                  removed.push(column);
                }
              });

              /*
               * Adding new values
               */

              _.each(vals, function (v) {
                var m = new (self.field.get('model'))({ column: v }, { silent: true,
                  top: self.model.top,
                  collection: collection,
                  handler: collection
                });

                collection.add(m);
              });

              /*
               * Removing unwanted!
               */
              _.each(removed, function (v) {
                collection.remove(collection.where({ column: v }));
              });

              this.listenTo(this.model, "change:" + name, this.render);
            },
            remove: function remove() {
              if (this.model.handler) {
                var self = this,
                    tableCols = self.model.top.get('columns');
                self.stopListening(tableCols, 'remove', self.resetColOptions);
                self.stopListening(tableCols, 'change:name', self.resetColOptions);
                self.model.get('columns').off('pgadmin:multicolumn:updated');

                Backform.Select2Control.prototype.remove.apply(this, arguments);
              } else {
                Backform.MultiSelectAjaxControl.prototype.remove.apply(this, arguments);
              }
            }
          }),
          deps: ['index'], node: 'column',
          model: pgBrowser.Node.Model.extend({
            defaults: {
              column: undefined
            },
            validate: function validate() {
              return null;
            }
          }),
          transform: function transform(data) {
            var res = [];
            if (data && _.isArray(data)) {
              _.each(data, function (d) {
                res.push({ label: d.label, value: d.label, image: 'icon-column' });
              });
            }
            return res;
          },
          select2: { allowClear: false },
          disabled: function disabled(m) {
            // If we are in table edit mode then
            if (_.has(m, 'top') && !_.isUndefined(m.top) && !m.top.isNew()) {
              // If OID is undefined then user is trying to add
              // new constraint which should be allowed for Unique
              return !_.isUndefined(m.get('oid'));
            }

            // We can't update columns of existing index constraint.
            if (!m.isNew()) {
              return true;
            }
            // Disable if index is selected.
            var index = m.get('index');
            if (_.isUndefined(index) || index == '') {
              return false;
            } else {
              var col = m.get('columns');
              col.reset();
              return true;
            }
          }
        }, {
          id: 'spcname', label: gettext('Tablespace'),
          type: 'text', group: gettext('Definition'),
          control: 'node-list-by-name', node: 'tablespace',
          deps: ['index'],
          select2: { allowClear: false },
          filter: function filter(m) {
            // Don't show pg_global tablespace in selection.
            if (m.label == "pg_global") return false;else return true;
          },
          disabled: function disabled(m) {
            // Disable if index is selected.
            m = m.top || m;
            var index = m.get('index');
            if (_.isUndefined(index) || index == '') {
              return false;
            } else {
              setTimeout(function () {
                m.set('spcname', '');
              }, 10);
              return true;
            }
          }
        }, {
          id: 'index', label: gettext('Index'),
          type: 'text', group: gettext('Definition'),
          control: Backform.NodeListByNameControl.extend({
            initialize: function initialize() {
              if (_.isUndefined(this.model.top)) {
                Backform.NodeListByNameControl.prototype.initialize.apply(this, arguments);
              } else {
                Backform.Control.prototype.initialize.apply(this, arguments);
              }
            }
          }),
          select2: { allowClear: true }, node: 'index',
          disabled: function disabled(m) {
            // If we are in table edit mode then disable it
            if (_.has(m, 'top') && !_.isUndefined(m.top) && !m.top.isNew()) {
              return true;
            }

            // We can't update index of existing index constraint.
            return !m.isNew();
          },
          // We will not show this field in Create Table mode
          visible: function visible(m) {
            return !_.isUndefined(m.top.node_info['table']);
          }
        }, {
          id: 'fillfactor', label: gettext('Fill factor'), deps: ['index'],
          type: 'int', group: gettext('Definition'), allowNull: true,
          disabled: function disabled(m) {
            // Disable if index is selected.
            var index = m.get('index');
            if (_.isUndefined(index) || index == '') {
              return false;
            } else {
              setTimeout(function () {
                m.set('fillfactor', null);
              }, 10);
              return true;
            }
          }
        }, {
          id: 'condeferrable', label: gettext('Deferrable?'),
          type: 'switch', group: gettext('Definition'), deps: ['index'],
          disabled: function disabled(m) {
            // If we are in table edit mode then
            if (_.has(m, 'top') && !_.isUndefined(m.top) && !m.top.isNew()) {
              // If OID is undefined then user is trying to add
              // new constraint which should allowed for Unique
              return !_.isUndefined(m.get('oid'));
            }

            // We can't update condeferrable of existing index constraint.
            if (!m.isNew()) {
              return true;
            }
            // Disable if index is selected.
            var index = m.get('index');
            if (_.isUndefined(index) || index == '') {
              return false;
            } else {
              setTimeout(function () {
                if (m.get('condeferrable')) m.set('condeferrable', false);
              }, 10);
              return true;
            }
          }
        }, {
          id: 'condeferred', label: gettext('Deferred?'),
          type: 'switch', group: gettext('Definition'),
          deps: ['condeferrable'],
          disabled: function disabled(m) {
            // If we are in table edit mode then
            if (_.has(m, 'top') && !_.isUndefined(m.top) && !m.top.isNew()) {
              // If OID is undefined then user is trying to add
              // new constraint which should allowed for Unique
              return !_.isUndefined(m.get('oid'));
            }

            // We can't update condeferred of existing index constraint.
            if (!m.isNew()) {
              return true;
            }
            // Disable if condeferred is false or unselected.
            if (m.get('condeferrable') == true) {
              return false;
            } else {
              setTimeout(function () {
                if (m.get('condeferred')) m.set('condeferred', false);
              }, 10);
              return true;
            }
          }
        }],
        validate: function validate() {
          this.errorModel.clear();
          // Clear parent's error as well
          if (_.has(this, 'top')) {
            this.top.errorModel.clear();
          }

          var columns = this.get('columns'),
              index = this.get('index');

          if ((_.isUndefined(index) || String(index).replace(/^\s+|\s+$/g, '') == '') && (_.isUndefined(columns) || _.isNull(columns) || columns.length < 1)) {
            var msg = gettext('Please specify columns for %(node)s', { node: gettext('Unique constraint') });
            this.errorModel.set('columns', msg);
            return msg;
          }

          return null;
        }
      })
    });
  }

  return pgBrowser.Nodes['unique_constraint'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

// Check Constraint Module: Node
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(17), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  // Check Constraint Node
  if (!pgBrowser.Nodes['check_constraints']) {
    pgAdmin.Browser.Nodes['check_constraints'] = pgBrowser.Node.extend({
      getTreeNodeHierarchy: pgBrowser.tableChildTreeNodeHierarchy,
      type: 'check_constraints',
      label: gettext('Check'),
      collection_type: 'coll-constraints',
      sqlAlterHelp: 'ddl-alter.html',
      sqlCreateHelp: 'ddl-constraints.html',
      dialogHelp: url_for('help.static', { 'filename': 'check_dialog.html' }),
      hasSQL: true,
      hasDepends: true,
      parent_type: ['table', 'partition'],
      Init: function Init() {
        // Avoid mulitple registration of menus
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_check_constraints_on_coll', node: 'coll-constraints', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 5, label: gettext('Check...'),
          icon: 'wcTabIcon icon-check_constraints', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'validate_check_constraint', node: 'check_constraints', module: this,
          applies: ['object', 'context'], callback: 'validate_check_constraint',
          category: 'validate', priority: 4, label: gettext('Validate check constraint'),
          icon: 'fa fa-link', enable: 'is_not_valid', data: { action: 'edit', check: true }
        }]);
      },
      is_not_valid: function is_not_valid(itemData, item, data) {
        if (this.canCreate(itemData, item, data)) {
          return itemData && !itemData.valid;
        } else {
          return false;
        }
      },
      callbacks: {
        validate_check_constraint: function validate_check_constraint(args) {
          var input = args || {},
              obj = this,
              t = pgBrowser.tree,
              i = input.item || t.selected(),
              d = i && i.length == 1 ? t.itemData(i) : undefined;

          if (!d) {
            return false;
          }
          var data = d;
          $.ajax({
            url: obj.generate_url(i, 'validate', d, true),
            type: 'GET',
            success: function success(res) {
              if (res.success == 1) {
                alertify.success(res.info);
                t.removeIcon(i);
                data.valid = true;
                data.icon = 'icon-check_constraints';
                t.addIcon(i, { icon: data.icon });
                setTimeout(function () {
                  t.deselect(i);
                }, 10);
                setTimeout(function () {
                  t.select(i);
                }, 100);
              }
            },
            error: function error(xhr, status, _error) {
              try {
                var err = $.parseJSON(xhr.responseText);
                if (err.success == 0) {
                  alertify.error(err.errormsg);
                }
              } catch (e) {}
              t.unload(i);
            }
          });

          return false;
        }
      },
      canDrop: pgBrowser.Nodes['schema'].canChildDrop,
      model: pgAdmin.Browser.Node.Model.extend({
        idAttribute: 'oid',

        defaults: {
          name: undefined,
          oid: undefined,
          description: undefined,
          consrc: undefined,
          connoinherit: undefined,
          convalidated: true
        },
        // Check Constraint Schema
        schema: [{
          id: 'name', label: gettext('Name'), type: 'text', cell: 'string',
          disabled: 'isDisabled'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', mode: ['properties']
        }, {
          id: 'comment', label: gettext('Comment'), type: 'multiline', cell: 'string', mode: ['properties', 'create', 'edit'],
          deps: ['name'], disabled: function disabled(m) {
            var name = m.get('name');
            if (!(name && name != '')) {
              setTimeout(function () {
                if (m.get('comment') && m.get('comment') !== '') m.set('comment', null);
              }, 10);
              return true;
            } else {
              return false;
            }
          }
        }, {
          id: 'consrc', label: gettext('Check'), type: 'multiline', cell: 'string', group: gettext('Definition'), mode: ['properties', 'create', 'edit'], disabled: function disabled(m) {
            return _.has(m, 'handler') && !_.isUndefined(m.handler) && !_.isUndefined(m.get('oid')) || _.isFunction(m.isNew) && !m.isNew();
          }, editable: false
        }, {
          id: 'connoinherit', label: gettext('No Inherit?'), type: 'switch', cell: 'boolean', group: gettext('Definition'), mode: ['properties', 'create', 'edit'], min_version: 90200,
          disabled: function disabled(m) {
            // Disabled if table is a partitioned table.
            if (_.has(m, 'top') && !_.isUndefined(m.top) && m.top.get('is_partitioned') || _.has(m, 'node_info') && _.has(m.node_info, 'table') && _.has(m.node_info.table, 'is_partitioned') && m.node_info.table.is_partitioned) {
              setTimeout(function () {
                m.set('connoinherit', false);
              }, 10);

              return true;
            }

            return _.has(m, 'handler') && !_.isUndefined(m.handler) && !_.isUndefined(m.get('oid')) || _.isFunction(m.isNew) && !m.isNew();
          }
        }, {
          id: 'convalidated', label: gettext("Don't validate?"), type: 'switch', cell: 'boolean', group: gettext('Definition'), min_version: 90200,
          disabled: function disabled(m) {
            if (_.isFunction(m.isNew) && !m.isNew() || _.has(m, 'handler') && !_.isUndefined(m.handler) && !_.isUndefined(m.get('oid'))) {

              return !m.get("convalidated");
            } else {
              return false;
            }
          },
          mode: ['properties', 'create', 'edit']
        }],
        // Client Side Validation
        validate: function validate() {
          var err = {},
              errmsg;

          if (_.isUndefined(this.get('consrc')) || String(this.get('consrc')).replace(/^\s+|\s+$/g, '') == '') {
            err['consrc'] = gettext('Check cannot be empty!');
            errmsg = errmsg || err['consrc'];
          }

          this.errorModel.clear().set(err);

          if (_.size(err)) {
            this.trigger('on-status', { msg: errmsg });
            return errmsg;
          }

          return null;
        },
        isDisabled: function isDisabled(m) {
          if (_.has(m, 'handler') && !_.isUndefined(m.handler) && !_.isUndefined(m.get('oid')) || _.isFunction(m.isNew) && !m.isNew()) {
            var server = (this.node_info || m.top.node_info).server;
            if (server.version < 90200) {
              return true;
            }
          }
          return false;
        }
      }),
      // Below function will enable right click menu for creating check constraint.
      canCreate: function canCreate(itemData, item, data) {
        // If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData,
            parents = [];
        // To iterate over tree to check parent node
        while (i) {
          // If it is schema then allow user to c reate table
          if (_.indexOf(['schema'], d._type) > -1) return true;
          parents.push(d._type);
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // If node is under catalog then do not allow 'create' menu
        if (_.indexOf(parents, 'catalog') > -1) {
          return false;
        } else {
          return true;
        }
      }
    });
  }

  return pgBrowser.Nodes['check_constraints'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backgrid, Backbone) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(17), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  var formatNode = function formatNode(opt) {
    if (!opt.id) {
      return opt.text;
    }

    var optimage = $(opt.element).data('image');

    if (!optimage) {
      return opt.text;
    } else {
      return $('<span><span class="wcTabIcon ' + optimage + '"/>' + opt.text + '</span>');
    }
  },
      headerSelectControlTemplate = _.template(['<div class="<%=Backform.controlsClassName%> <%=extraClasses.join(\' \')%>">', '  <select class="pgadmin-node-select form-control" name="<%=name%>" style="width:100%;" value="<%-value%>" <%=disabled ? "disabled" : ""%> <%=required ? "required" : ""%> >', '    <%=select2.first_empty ? " <option></option>" : ""%>', '    <% for (var i=0; i < options.length; i++) { %>', '    <% var option = options[i]; %>', '    <option <% if (option.image) { %> data-image=<%= option.image %> <% } %> value=<%= formatter.fromRaw(option.value) %> <%=option.value === rawValue ? "selected=\'selected\'" : "" %>><%-option.label%></option>', '    <% } %>', '  </select>', '</div>'].join("\n"));

  var ForeignKeyColumnModel = pgBrowser.Node.Model.extend({
    defaults: {
      local_column: undefined,
      references: undefined,
      referenced: undefined
    },
    schema: [{
      id: 'local_column', label: 'Local', type: 'text', editable: false,
      cellHeaderClasses: 'width_percent_50', cell: 'string',
      headerCell: Backgrid.Extension.CustomHeaderCell
    }, {
      id: 'referenced', label: 'Referenced', type: 'text', editable: false,
      cell: 'string', cellHeaderClasses: 'width_percent_50',
      headerCell: Backgrid.Extension.CustomHeaderCell
    }]
  });

  var ForeignKeyColumnControl = Backform.ForeignKeyColumnControl = Backform.UniqueColCollectionControl.extend({

    initialize: function initialize(opts) {
      Backform.UniqueColCollectionControl.prototype.initialize.apply(this, arguments);

      var self = this,
          node = 'foreign_key',
          headerSchema = [{
        id: 'local_column', label: '', type: 'text',
        node: 'column', control: Backform.NodeListByNameControl.extend({
          initialize: function initialize() {
            // Here we will decide if we need to call URL
            // Or fetch the data from parent columns collection
            if (self.model.handler) {
              Backform.Select2Control.prototype.initialize.apply(this, arguments);
              // Do not listen for any event(s) for existing constraint.
              if (_.isUndefined(self.model.get('oid'))) {
                var tableCols = self.model.top.get('columns');
                this.listenTo(tableCols, 'remove', this.removeColumn);
                this.listenTo(tableCols, 'change:name', this.resetColOptions);
              }

              this.custom_options();
            } else {
              Backform.NodeListByNameControl.prototype.initialize.apply(this, arguments);
            }
          },
          removeColumn: function removeColumn(m) {
            var that = this;
            setTimeout(function () {
              that.custom_options();
              that.render.apply(that);
            }, 50);
          },
          resetColOptions: function resetColOptions(m) {
            var that = this;

            if (m.previous('name') == self.headerData.get('local_column')) {
              /*
               * Table column name has changed so update
               * column name in foreign key as well.
               */
              self.headerData.set({ "local_column": m.get('name') });
              self.headerDataChanged();
            }

            setTimeout(function () {
              that.custom_options();
              that.render.apply(that);
            }, 50);
          },
          custom_options: function custom_options() {
            // We will add all the columns entered by user in table model
            var columns = self.model.top.get('columns'),
                added_columns_from_tables = [];

            if (columns.length > 0) {
              _.each(columns.models, function (m) {
                var col = m.get('name');
                if (!_.isUndefined(col) && !_.isNull(col)) {
                  added_columns_from_tables.push({ label: col, value: col, image: 'icon-column' });
                }
              });
            }
            // Set the values in to options so that user can select
            this.field.set('options', added_columns_from_tables);
          },
          template: headerSelectControlTemplate,
          remove: function remove() {
            if (self.model.handler) {
              var tableCols = self.model.top.get('columns');
              this.stopListening(tableCols, 'remove', this.removeColumn);
              this.stopListening(tableCols, 'change:name', this.resetColOptions);

              Backform.Select2Control.prototype.remove.apply(this, arguments);
            } else {
              Backform.NodeListByNameControl.prototype.remove.apply(this, arguments);
            }
          }
        }),
        select2: {
          allowClear: false, width: 'style',
          placeholder: gettext('Select column'),
          first_empty: !_.isUndefined(self.model.get('oid'))
        },
        version_compatible: self.field.get('version_compatible'),
        disabled: function disabled(m) {
          return !_.isUndefined(self.model.get('oid'));
        }
      }, {
        id: 'references', label: '', type: 'text', cache_level: 'server',
        select2: {
          allowClear: false, width: 'style',
          placeholder: 'Select foreign table'
        }, first_empty: true,
        control: Backform.NodeListByNameControl.extend({
          formatter: Backform.ControlFormatter,
          template: headerSelectControlTemplate
        }),
        url: 'all_tables', node: 'table',
        version_compatible: self.field.get('version_compatible'),
        disabled: function disabled(m) {
          return !_.isUndefined(self.model.get('oid'));
        },
        transform: function transform(rows) {
          var res = [];
          _.each(rows, function (r) {
            res.push({
              'value': r.value,
              'image': "icon-table",
              'label': r.label
            });
          });
          return res;
        }
      }, {
        id: 'referenced', label: '', type: 'text', cache_level: 'server',
        transform: function transform(rows) {
          var res = [];
          _.each(rows, function (r) {
            res.push({
              'value': r.name,
              'image': 'icon-column',
              'label': r.name
            });
          });
          return res;
        },
        control: Backform.Select2Control.extend({
          formatter: Backform.ControlFormatter,
          template: headerSelectControlTemplate,
          render: function render() {
            var self = this,
                url = self.field.get('url') || self.defaults.url,
                m = self.model,
                tid = m.get('references');

            // Clear any existing value before setting new options.
            m.set(self.field.get('name'), null, { silent: true });

            if (url && !_.isUndefined(tid) && !_.isNull(tid) && tid != '') {
              var node = this.field.get('schema_node'),
                  node_info = this.field.get('node_info'),
                  full_url = node.generate_url.apply(node, [null, url, this.field.get('node_data'), this.field.get('url_with_id') || false, node_info]),
                  data = [];

              if (this.field.get('version_compatible')) {
                m.trigger('pgadmin:view:fetching', m, self.field);
                $.ajax({
                  async: false,
                  data: { tid: tid },
                  url: full_url,
                  success: function success(res) {
                    data = res.data;
                  },
                  error: function error() {
                    m.trigger('pgadmin:view:fetch:error', m, self.field);
                  }
                });
                m.trigger('pgadmin:view:fetched', m, self.field);
              }
              /*
               * Transform the data
               */
              var transform = this.field.get('transform') || self.defaults.transform;
              if (transform && _.isFunction(transform)) {
                // We will transform the data later, when rendering.
                // It will allow us to generate different data based on the
                // dependencies.
                self.field.set('options', transform.bind(self, data));
              } else {
                self.field.set('options', data);
              }
            } else {
              self.field.set('options', []);
            }
            Backform.Select2Control.prototype.render.apply(this, arguments);
            return this;
          }
        }), url: 'get_columns',
        select2: {
          allowClear: false,
          width: "style",
          placeholder: gettext('Select column'),
          templateResult: formatNode,
          templateSelection: formatNode
        },
        deps: ['references'], node: 'table',
        version_compatible: self.field.get('version_compatible'),
        disabled: function disabled(m) {
          return !_.isUndefined(self.model.get('oid'));
        }
      }],
          headerDefaults = { local_column: null,
        references: null,
        referenced: null },
          gridCols = ['local_column', 'references', 'referenced'];

      if (!self.model.isNew() && _.isUndefined(self.model.handler) || _.has(self.model, 'handler') && !_.isUndefined(self.model.handler) && !_.isUndefined(self.model.get('oid'))) {
        var column = self.collection.first();
        if (column) {
          headerDefaults["references"] = column.get("references");
        }
      }

      self.headerData = new (Backbone.Model.extend({
        defaults: headerDefaults,
        schema: headerSchema
      }))({});

      var headerGroups = Backform.generateViewSchema(self.field.get('node_info'), self.headerData, 'create', node, self.field.get('node_data')),
          fields = [];

      _.each(headerGroups, function (o) {
        fields = fields.concat(o.fields);
      });

      self.headerFields = new Backform.Fields(fields);
      self.gridSchema = Backform.generateGridColumnsFromModel(
      //null, ForeignKeyColumnModel, 'edit', gridCols
      self.field.get('node_info'), self.field.get('model'), 'edit', gridCols, self.field.get('schema_node'));

      self.controls = [];
      self.listenTo(self.headerData, "change", self.headerDataChanged);
      self.listenTo(self.headerData, "select2", self.headerDataChanged);
      self.listenTo(self.collection, "add", self.onAddorRemoveColumns);
      self.listenTo(self.collection, "remove", self.onAddorRemoveColumns);
    },

    generateHeader: function generateHeader(data) {
      var header = ['<div class="subnode-header-form">', ' <div class="container-fluid">', '  <div class="row">', '   <div class="col-md-4">', '    <label class="control-label"><%-column_label%></label>', '   </div>', '   <div class="col-md-6" header="local_column"></div>', '   <div class="col-md-2">', '     <button class="btn-sm btn-default add fa fa-plus" <%=canAdd ? "" : "disabled=\'disabled\'"%> ></button>', '   </div>', '  </div>', '  <div class="row">', '   <div class="col-md-4">', '    <label class="control-label"><%-references_label%></label>', '   </div>', '   <div class="col-md-6" header="references"></div>', '  </div>', '  <div class="row">', '   <div class="col-md-4">', '    <label class="control-label"><%-referenced_label%></label>', '   </div>', '   <div class="col-md-6" header="referenced"></div>', '  </div>', ' </div>', '</div>'].join("\n");

      _.extend(data, {
        column_label: gettext('Local column'),
        references_label: gettext('References'),
        referenced_label: gettext('Referencing')
      });

      var self = this,
          headerTmpl = _.template(header),
          $header = $(headerTmpl(data)),
          controls = this.controls;

      this.headerFields.each(function (field) {
        var control = new (field.get("control"))({
          field: field,
          model: self.headerData
        });

        $header.find('div[header="' + field.get('name') + '"]').append(control.render().$el);

        controls.push(control);
      });

      // We should not show add but in properties mode
      if (data.mode == 'properties') {
        $header.html('');
      }

      self.$header = $header;

      return $header;
    },

    events: _.extend({}, Backform.UniqueColCollectionControl.prototype.events, { 'click button.add': 'addColumns' }),

    showGridControl: function showGridControl(data) {

      var self = this,
          titleTmpl = _.template(["<div class='subnode-header'>", "<label class='control-label'><%-label%></label>", "</div>"].join("\n")),
          $gridBody = $("<div class='pgadmin-control-group backgrid form-group col-xs-12 object subnode'></div>").append(
      // Append titleTmpl only if create/edit mode
      data.mode !== 'properties' ? titleTmpl({ label: data.label }) : '');

      // Clean up existing grid if any (in case of re-render)
      if (self.grid) {
        self.grid.remove();
      }

      $gridBody.append(self.generateHeader(data));

      var gridSchema = _.clone(this.gridSchema);

      // Insert Delete Cell into Grid
      if (data.disabled == false && data.canDelete) {
        gridSchema.columns.unshift({
          name: "pg-backform-delete", label: "",
          cell: Backgrid.Extension.DeleteCell,
          editable: false, cell_priority: -1
        });
      }

      // Initialize a new Grid instance
      var grid = self.grid = new Backgrid.Grid({
        columns: gridSchema.columns,
        collection: self.collection,
        className: "backgrid table-bordered"
      });
      self.$grid = grid.render().$el;

      $gridBody.append(self.$grid);

      setTimeout(function () {
        self.headerData.set({
          'local_column': self.$header.find('div[header="local_column"] select option:first').val(),
          'referenced': self.$header.find('div[header="referenced"] select option:first').val(),
          'references': self.$header.find('div[header="references"] select option:first').val()
        }, { silent: true });
      }, 10);

      // Remove unwanted class from grid to display it properly
      if (data.mode === 'properties') $gridBody.find('.subnode-header-form').removeClass('subnode-header-form');

      // Render node grid
      return $gridBody;
    },

    headerDataChanged: function headerDataChanged() {
      var self = this,
          val,
          data = this.headerData.toJSON(),
          inSelected = false,
          checkVars = ['local_column', 'referenced'];

      if (!self.$header) {
        return;
      }

      if (self.control_data.canAdd) {
        self.collection.each(function (m) {
          if (!inSelected) {
            _.each(checkVars, function (v) {
              if (!inSelected) {
                val = m.get(v);
                inSelected = (_.isUndefined(val) || _.isNull(val)) && (_.isUndefined(data[v]) || _.isNull(data[v])) || val == data[v];
              }
            });
          }
        });
      } else {
        inSelected = true;
      }

      self.$header.find('button.add').prop('disabled', inSelected);
    },

    addColumns: function addColumns(ev) {
      ev.preventDefault();
      var self = this,
          local_column = self.headerData.get('local_column'),
          referenced = self.headerData.get('referenced');

      if (!local_column || local_column == '' || !referenced || referenced == '') {
        return false;
      }

      var m = new (self.field.get('model'))(self.headerData.toJSON()),
          coll = self.model.get(self.field.get('name'));

      coll.add(m);

      var idx = coll.indexOf(m);

      // idx may not be always > -1 because our UniqueColCollection may
      // remove 'm' if duplicate value found.
      if (idx > -1) {
        self.$grid.find('.new').removeClass('new');

        var newRow = self.grid.body.rows[idx].$el;

        newRow.addClass("new");
        $(newRow).pgMakeVisible('backform-tab');
      } else {
        //delete m;
      }

      return false;
    },

    onAddorRemoveColumns: function onAddorRemoveColumns() {
      var self = this;

      // Wait for collection to be updated before checking for the button to be
      // enabled, or not.
      setTimeout(function () {
        if (self.collection.length > 0) {
          self.$header.find('div[header="references"] select').prop('disabled', true);
        } else {
          self.$header.find('div[header="references"] select').prop('disabled', false);
        }

        self.collection.trigger('pgadmin:columns:updated', self.collection);

        self.headerDataChanged();

        if (!_.has(self.model, 'handler') || _.has(self.model, 'handler') && _.isUndefined(self.model.handler) || _.has(self.model, 'handler') && !_.isUndefined(self.model.handler) && !_.isUndefined(self.model.handler.get('oid'))) {
          self.getCoveringIndex();
        }
      }, 10);
    },

    getCoveringIndex: function getCoveringIndex() {

      var self = this,
          url = 'get_coveringindex',
          m = self.model,
          cols = [],
          coveringindex = null;

      self.collection.each(function (m) {
        cols.push(m.get('local_column'));
      });

      if (cols.length > 0) {
        var node = this.field.get('schema_node'),
            node_info = this.field.get('node_info'),
            full_url = node.generate_url.apply(node, [null, url, this.field.get('node_data'), this.field.get('url_with_id') || false, node_info]);

        if (this.field.get('version_compatible')) {
          m.trigger('pgadmin:view:fetching', m, self.field);
          $.ajax({
            async: false,
            data: { cols: JSON.stringify(cols) },
            url: full_url,
            success: function success(res) {
              coveringindex = res.data;
            },
            error: function error() {
              m.trigger('pgadmin:view:fetch:error', m, self.field);
            }
          });
          m.trigger('pgadmin:view:fetched', m, self.field);
        }
      }

      if (coveringindex) {
        m.set('hasindex', true);
        m.set('autoindex', false);
        m.set('coveringindex', coveringindex);
      } else {
        m.set('coveringindex', null);
        m.set('autoindex', true);
        m.set('hasindex', false);
      }
    },

    remove: function remove() {
      /*
       * Stop listening the events registered by this control.
       */
      this.stopListening(this.headerData, "change", this.headerDataChanged);
      this.listenTo(this.headerData, "select2", this.headerDataChanged);
      this.listenTo(this.collection, "remove", this.onRemoveVariable);
      // Remove header controls.
      _.each(this.controls, function (controls) {
        controls.remove();
      });

      ForeignKeyColumnControl.__super__.remove.apply(this, arguments);

      // Remove the header model
      delete this.headerData;
    }
  });

  // Extend the browser's node class for foreign key node
  if (!pgBrowser.Nodes['foreign_key']) {
    pgAdmin.Browser.Nodes['foreign_key'] = pgBrowser.Node.extend({
      getTreeNodeHierarchy: pgBrowser.tableChildTreeNodeHierarchy,
      type: 'foreign_key',
      label: gettext('Foreign key'),
      collection_type: 'coll-constraints',
      sqlAlterHelp: 'ddl-alter.html',
      sqlCreateHelp: 'ddl-constraints.html',
      dialogHelp: url_for('help.static', { 'filename': 'foreign_key_dialog.html' }),
      hasSQL: true,
      parent_type: ['table', 'partition'],
      canDrop: true,
      canDropCascade: true,
      hasDepends: true,
      Init: function Init() {
        /* Avoid multiple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_foreign_key_on_coll', node: 'coll-constraints', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Foreign key...'),
          icon: 'wcTabIcon icon-foreign_key', data: { action: 'create', check: true },
          enable: 'canCreate'
        }, {
          name: 'validate_foreign_key', node: 'foreign_key', module: this,
          applies: ['object', 'context'], callback: 'validate_foreign_key',
          category: 'validate', priority: 4, label: gettext('Validate foreign key'),
          icon: 'fa fa-link', enable: 'is_not_valid'
        }]);
      },
      is_not_valid: function is_not_valid(node) {
        return node && !node.valid;
      },
      callbacks: {
        validate_foreign_key: function validate_foreign_key(args) {
          var input = args || {},
              obj = this,
              t = pgBrowser.tree,
              i = input.item || t.selected(),
              d = i && i.length == 1 ? t.itemData(i) : undefined;

          if (!d) {
            return false;
          }
          var data = d;
          $.ajax({
            url: obj.generate_url(i, 'validate', d, true),
            type: 'GET',
            success: function success(res) {
              if (res.success == 1) {
                alertify.success(res.info);
                t.removeIcon(i);
                data.valid = true;
                data.icon = 'icon-foreign_key';
                t.addIcon(i, { icon: data.icon });
                setTimeout(function () {
                  t.deselect(i);
                }, 10);
                setTimeout(function () {
                  t.select(i);
                }, 100);
              }
            },
            error: function error(xhr, status, _error) {
              try {
                var err = $.parseJSON(xhr.responseText);
                if (err.success == 0) {
                  alertify.error(err.errormsg);
                }
              } catch (e) {}
              t.unload(i);
            }
          });

          return false;
        }
      },
      // Define the model for foreign key node
      model: pgAdmin.Browser.Node.Model.extend({
        idAttribute: 'oid',

        defaults: {
          name: undefined,
          oid: undefined,
          comment: undefined,
          condeferrable: undefined,
          condeferred: undefined,
          confmatchtype: undefined,
          convalidated: undefined,
          columns: undefined,
          confupdtype: "a",
          confdeltype: "a",
          autoindex: true,
          coveringindex: undefined,
          hasindex: undefined
        },
        toJSON: function toJSON() {
          var d = pgAdmin.Browser.Node.Model.prototype.toJSON.apply(this, arguments);
          delete d.hasindex;
          return d;
        },
        // Define the schema for the foreign key node
        schema: [{
          id: 'name', label: gettext('Name'), type: 'text',
          mode: ['properties', 'create', 'edit'], editable: true,
          headerCell: Backgrid.Extension.CustomHeaderCell, cellHeaderClasses: 'width_percent_50'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', mode: ['properties']
        }, {
          id: 'comment', label: gettext('Comment'), cell: 'string',
          type: 'multiline', mode: ['properties', 'create', 'edit'],
          deps: ['name'], disabled: function disabled(m) {
            var name = m.get('name');
            if (!(name && name != '')) {
              setTimeout(function () {
                if (m.get('comment') && m.get('comment') !== '') m.set('comment', null);
              }, 10);
              return true;
            } else {
              return false;
            }
          }
        }, {
          id: 'condeferrable', label: gettext('Deferrable?'),
          type: 'switch', group: gettext('Definition'),
          disabled: function disabled(m) {
            // If we are in table edit mode then
            if (_.has(m, 'handler') && !_.isUndefined(m.handler)) {
              // If OID is undefined then user is trying to add
              // new constraint which should allowed for Unique
              return !_.isUndefined(m.get('oid'));
            }
            // We can't update condeferrable of existing foreign key.
            return !m.isNew();
          }
        }, {
          id: 'condeferred', label: gettext('Deferred?'),
          type: 'switch', group: gettext('Definition'),
          deps: ['condeferrable'],
          disabled: function disabled(m) {
            // If we are in table edit mode then
            if (_.has(m, 'handler') && !_.isUndefined(m.handler)) {
              // If OID is undefined then user is trying to add
              // new constraint which should allowed for Unique
              return !_.isUndefined(m.get('oid'));
            } else if (!m.isNew()) {
              return true;
            }
            // Disable if condeferred is false or unselected.
            if (m.get('condeferrable') == true) {
              return false;
            } else {
              setTimeout(function () {
                if (m.get('condeferred')) m.set('condeferred', false);
              }, 10);
              return true;
            }
          }
        }, {
          id: 'confmatchtype', label: gettext('Match type'),
          type: 'switch', group: gettext('Definition'),
          options: {
            onText: 'FULL',
            offText: 'SIMPLE'
          }, disabled: function disabled(m) {
            // If we are in table edit mode then
            if (_.has(m, 'handler') && !_.isUndefined(m.handler)) {
              // If OID is undefined then user is trying to add
              // new constraint which should allowed for Unique
              return !_.isUndefined(m.get('oid'));
            }
            // We can't update condeferred of existing foreign key.
            return !m.isNew();
          }
        }, {
          id: 'convalidated', label: gettext("Validated?"),
          type: 'switch', group: gettext('Definition'),
          options: {
            onText: gettext('Yes'),
            offText: gettext('No')
          }, disabled: function disabled(m) {
            // If we are in table edit mode then
            if (_.has(m, 'handler') && !_.isUndefined(m.handler)) {
              // If OID is undefined then user is trying to add
              // new constraint which should allowed
              return !(_.isUndefined(m.get('oid')) || m.get("convalidated"));
            }
            // We can't update condeferred of existing foreign key.
            return !(m.isNew() || m.get("convalidated"));
          }
        }, {
          id: 'autoindex', label: gettext('Auto FK index?'),
          type: 'switch', group: gettext('Definition'),
          deps: ['name', 'hasindex'],
          options: {
            onText: gettext('Yes'),
            offText: gettext('No')
          }, disabled: function disabled(m) {
            var index = m.get('coveringindex'),
                autoindex = m.get('autoindex'),
                setIndexName = function setIndexName() {
              var name = m.get('name'),
                  oldindex = 'fki_' + m.previous('name');

              if (m.get('hasindex')) {
                return true;
              } else if (m.get('autoindex') && !_.isUndefined(name) && !_.isNull(name) && name != '' && (_.isUndefined(index) || _.isNull(index) || index == '' || index == oldindex)) {
                var newIndex = 'fki_' + name;
                m.set('coveringindex', newIndex);
                return false;
              } else {
                return false;
              }
            };
            // If we are in table edit mode then
            if (_.has(m, 'handler') && !_.isUndefined(m.handler)) {
              // If OID is undefined then user is trying to add
              // new constraint which should allowed for Unique
              if (_.isUndefined(m.get('oid')) && _.isUndefined(m.handler.get('oid'))) {
                setTimeout(function () {
                  if (m.get('autoindex')) m.set('autoindex', false);
                }, 10);
                return true;
              } else {
                return setIndexName();
              }
            } else {
              if (!m.isNew() && autoindex && !_.isUndefined(index) && !_.isNull(index) && index != '' && m.get('hasindex')) {
                return true;
              } else {
                return setIndexName();
              }
            }
          }
        }, {
          id: 'coveringindex', label: gettext('Covering index'), type: 'text',
          mode: ['properties', 'create', 'edit'], group: gettext('Definition'),
          deps: ['autoindex', 'hasindex'],
          disabled: function disabled(m) {
            var index = m.get('coveringindex'),
                setIndexName = function setIndexName() {
              if (m.get('hasindex')) {
                return true;
              } else if (!m.get('autoindex')) {
                setTimeout(function () {
                  m.set('coveringindex', null);
                });
                return true;
              } else {
                setTimeout(function () {
                  var name = m.get('name'),
                      newIndex = 'fki_' + name;

                  if (m.get('autoindex') && !_.isUndefined(name) && !_.isNull(name) && name != '') {
                    m.set('coveringindex', newIndex);
                  }
                });

                return false;
              }
            };

            // If we are in table edit mode then
            if (_.has(m, 'handler') && !_.isUndefined(m.handler)) {
              // If OID is undefined then user is trying to add
              // new constraint which should allowed for Unique
              if (_.isUndefined(m.get('oid')) && _.isUndefined(m.handler.get('oid'))) {
                return true;
              } else {
                return setIndexName();
              }
            } else if (!m.isNew() && m.get('autoindex') && !_.isUndefined(index) && _.isNull(index) && index == '') {
              return true;
            }

            return setIndexName();
          }
        }, _defineProperty({
          id: 'columns', label: gettext('Columns'),
          type: 'collection', group: gettext('Columns'), disabled: false,
          node: 'foreign_key', editable: false, headerCell: Backgrid.Extension.CustomHeaderCell,
          cellHeaderClasses: 'width_percent_50',
          cell: Backgrid.StringCell.extend({
            initialize: function initialize() {
              Backgrid.StringCell.prototype.initialize.apply(this, arguments);
              var self = this,
                  collection = this.model.get('columns');
              // Do not listen for any event(s) for existing constraint.
              if (_.isUndefined(self.model.get('oid'))) {
                var tableCols = self.model.top.get('columns');
                self.listenTo(tableCols, 'remove', self.removeColumn);
                self.listenTo(tableCols, 'change:name', self.resetColOptions);
              }

              self.model.get('columns').on('pgadmin:columns:updated', function () {
                self.render.apply(self);
              });
              self.listenTo(collection, "add", self.render);
              self.listenTo(collection, "remove", self.render);
            },
            removeColumn: function removeColumn(m) {
              var self = this,
                  removedCols = self.model.get('columns').where({ local_column: m.get('name') });

              self.model.get('columns').remove(removedCols);
              setTimeout(function () {
                self.render();
              }, 10);

              setTimeout(function () {
                var constraints = self.model.top.get("foreign_key");
                var removed = [];
                constraints.each(function (constraint) {
                  if (constraint.get("columns").length == 0) {
                    removed.push(constraint);
                  }
                });
                constraints.remove(removed);
              }, 100);
            },
            resetColOptions: function resetColOptions(m) {
              var self = this,
                  updatedCols = self.model.get('columns').where({ "local_column": m.previous('name') });
              if (updatedCols.length > 0) {
                /*
                 * Table column name has changed so update
                 * column name in foreign key as well.
                 */
                updatedCols[0].set({ "local_column": m.get('name') });
              }

              setTimeout(function () {
                self.render();
              }, 10);
            },
            formatter: {
              fromRaw: function fromRaw(rawValue, model) {
                var cols = [],
                    remote_cols = [];
                if (rawValue.length > 0) {
                  rawValue.each(function (col) {
                    cols.push(col.get('local_column'));
                    remote_cols.push(col.get('referenced'));
                  });
                  return '(' + cols.join(', ') + ') -> (' + remote_cols.join(', ') + ')';
                }
                return "";
              },
              toRaw: function toRaw(val, model) {
                return val;
              }
            },
            render: function render() {
              return Backgrid.StringCell.prototype.render.apply(this, arguments);
            },
            remove: function remove() {
              var tableCols = this.model.top.get('columns');

              this.stopListening(tableCols, 'remove', self.removeColumn);
              this.stopListening(tableCols, 'change:name', self.resetColOptions);

              Backgrid.StringCell.prototype.remove.apply(this, arguments);
            }
          }),
          canAdd: function canAdd(m) {
            // We can't update columns of existing foreign key.
            return m.isNew();
          }, canDelete: true,
          control: ForeignKeyColumnControl,
          model: ForeignKeyColumnModel
        }, 'disabled', function disabled(m) {
          // If we are in table edit mode then
          if (_.has(m, 'handler') && !_.isUndefined(m.handler)) {
            // If OID is undefined then user is trying to add
            // new constraint which should allowed for Unique
            return !_.isUndefined(m.get('oid'));
          }
          // We can't update columns of existing foreign key.
          return !m.isNew();
        }), {
          id: 'confupdtype', label: gettext('On update'),
          type: "select2", group: gettext('Action'), mode: ['edit', 'create'],
          select2: { width: "50%", allowClear: false },
          options: [{ label: "NO ACTION", value: "a" }, { label: "RESTRICT", value: "r" }, { label: "CASCADE", value: "c" }, { label: "SET NULL", value: "n" }, { label: "SET DEFAULT", value: "d" }], disabled: function disabled(m) {
            // If we are in table edit mode then
            if (_.has(m, 'handler') && !_.isUndefined(m.handler)) {
              // If OID is undefined then user is trying to add
              // new constraint which should allowed for Unique
              return !_.isUndefined(m.get('oid'));
            }
            // We can't update confupdtype of existing foreign key.
            return !m.isNew();
          }
        }, {
          id: 'confdeltype', label: gettext('On delete'),
          type: "select2", group: gettext('Action'), mode: ['edit', 'create'],
          select2: { width: "50%", allowClear: false },
          options: [{ label: "NO ACTION", value: "a" }, { label: "RESTRICT", value: "r" }, { label: "CASCADE", value: "c" }, { label: "SET NULL", value: "n" }, { label: "SET DEFAULT", value: "d" }], disabled: function disabled(m) {
            // If we are in table edit mode then
            if (_.has(m, 'handler') && !_.isUndefined(m.handler)) {
              // If OID is undefined then user is trying to add
              // new constraint which should allowed for Unique
              return !_.isUndefined(m.get('oid'));
            }
            // We can't update confdeltype of existing foreign key.
            return !m.isNew();
          }
        }],
        validate: function validate() {
          this.errorModel.clear();

          var columns = this.get('columns');
          if (_.isUndefined(columns) || _.isNull(columns) || columns.length < 1) {
            var msg = gettext('Please specify columns for Foreign key.');
            this.errorModel.set('columns', msg);
            return msg;
          }

          var coveringindex = this.get('coveringindex'),
              autoindex = this.get('autoindex');
          if (autoindex && (_.isUndefined(coveringindex) || _.isNull(coveringindex) || String(coveringindex).replace(/^\s+|\s+$/g, '') == '')) {
            var msg = gettext('Please specify covering index name.');
            this.errorModel.set('coveringindex', msg);
            return msg;
          }

          return null;
        }
      }),

      canCreate: function canCreate(itemData, item, data) {
        // If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData,
            parents = [],
            immediate_parent_table_found = false,
            is_immediate_parent_table_partitioned = false;
        // To iterate over tree to check parent node
        while (i) {
          // If table is partitioned table then return false
          if (!immediate_parent_table_found && (d._type == 'table' || d._type == 'partition')) {
            immediate_parent_table_found = true;
            if ('is_partitioned' in d && d.is_partitioned) {
              is_immediate_parent_table_partitioned = true;
            }
          }

          // If it is schema then allow user to c reate table
          if (_.indexOf(['schema'], d._type) > -1) return !is_immediate_parent_table_partitioned;
          parents.push(d._type);
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // If node is under catalog then do not allow 'create' menu
        if (_.indexOf(parents, 'catalog') > -1) {
          return false;
        } else {
          return !is_immediate_parent_table_partitioned;
        }
      }
    });
  }

  return pgBrowser.Nodes['foreign_key'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13), __webpack_require__(10)))

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backbone, Backgrid) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, Alertify) {

  var ExclusionConstraintColumnModel = pgBrowser.Node.Model.extend({
    defaults: {
      column: undefined,
      oper_class: undefined,
      order: false,
      nulls_order: false,
      operator: undefined,
      col_type: undefined,
      is_sort_nulls_applicable: true
    },
    toJSON: function toJSON() {
      var d = pgBrowser.Node.Model.prototype.toJSON.apply(this, arguments);
      delete d.col_type;
      return d;
    },
    schema: [{
      id: 'column', label: gettext('Column'), type: 'text', editable: false,
      cell: 'string'
    }, {
      id: 'oper_class', label: gettext('Operator class'), type: 'text',
      node: 'table', url: 'get_oper_class', first_empty: true,
      editable: function editable(m) {
        if (m instanceof Backbone.Collection) {
          return true;
        } else if (_.has(m.collection, 'handler') && !_.isUndefined(m.collection.handler) && !_.isUndefined(m.collection.handler.get('oid'))) {
          return false;
        } else if (_.has(m.collection, 'handler') && !_.isUndefined(m.collection.handler) && !_.isUndefined(m.collection.handler.get('amname')) && m.collection.handler.get('amname') != 'btree') {
          // Disable if access method is not btree
          return false;
        }
        return true;
      },
      select2: {
        allowClear: true, width: 'style', tags: true,
        placeholder: gettext('Select the operator class')
      }, cell: Backgrid.Extension.Select2Cell.extend({
        initialize: function initialize() {
          Backgrid.Extension.Select2Cell.prototype.initialize.apply(this, arguments);

          var self = this,
              url = self.column.get('url') || self.defaults.url,
              m = self.model,
              indextype = self.model.collection.handler.get('amname');

          if (url && (indextype == 'btree' || _.isUndefined(indextype) || _.isNull(indextype) || indextype == '')) {
            // Set sort_order and nulls to true if access method is btree
            setTimeout(function () {
              m.set('order', true);
              m.set('nulls_order', true);
            }, 10);

            var node = this.column.get('schema_node'),
                eventHandler = m.top || m,
                node_info = this.column.get('node_info'),
                full_url = node.generate_url.apply(node, [null, url, this.column.get('node_data'), this.column.get('url_with_id') || false, node_info]),
                data = [];

            indextype = 'btree';

            if (this.column.get('version_compatible')) {
              eventHandler.trigger('pgadmin:view:fetching', m, self.column);
              $.ajax({
                async: false,
                data: { indextype: indextype },
                url: full_url,
                success: function success(res) {
                  data = res.data;
                  self.column.set('options', data);
                },
                error: function error() {
                  eventHandler.trigger('pgadmin:view:fetch:error', m, self.column);
                }
              });
              eventHandler.trigger('pgadmin:view:fetched', m, self.column);
            }
          } else {
            self.column.set('options', []);
          }
        }
      })
    }, {
      id: 'order', label: gettext('DESC'), type: 'switch',
      options: {
        onText: 'ASC',
        offText: 'DESC'
      },
      editable: function editable(m) {
        if (m instanceof Backbone.Collection) {
          return true;
        } else if (_.has(m.collection, 'handler') && !_.isUndefined(m.collection.handler) && !_.isUndefined(m.collection.handler.get('oid'))) {
          return false;
        } else if (m.top.get('amname') === 'btree') {
          m.set('is_sort_nulls_applicable', true);
          return true;
        } else {
          m.set('is_sort_nulls_applicable', false);
          return false;
        }
      }
    }, {
      id: 'nulls_order', label: gettext('NULLs order'), type: "switch",
      options: {
        onText: 'FIRST',
        offText: 'LAST'
      },
      editable: function editable(m) {
        if (m instanceof Backbone.Collection) {
          return true;
        } else if (_.has(m.collection, 'handler') && !_.isUndefined(m.collection.handler) && !_.isUndefined(m.collection.handler.get('oid'))) {
          return false;
        } else if (m.top.get('amname') === 'btree') {
          m.set('is_sort_nulls_applicable', true);
          return true;
        } else {
          m.set('is_sort_nulls_applicable', false);
          return false;
        }
      }
    }, {
      id: 'operator', label: gettext('Operator'), type: 'text',
      node: 'table', url: 'get_operator',
      editable: function editable(m) {
        if (m instanceof Backbone.Collection) {
          return true;
        }
        if (_.has(m.collection, 'handler') && !_.isUndefined(m.collection.handler) && !_.isUndefined(m.collection.handler.get('oid'))) {
          return false;
        }
        return true;
      },
      select2: {
        allowClear: false, width: 'style'
      }, cell: Backgrid.Extension.Select2Cell.extend({
        initialize: function initialize() {
          Backgrid.Extension.Select2Cell.prototype.initialize.apply(this, arguments);

          var self = this,
              url = self.column.get('url') || self.defaults.url,
              m = self.model,
              col_type = self.model.get('col_type');

          self.column.set('options', []);

          if (url && !_.isUndefined(col_type) && !_.isNull(col_type) && col_type != '') {
            var node = this.column.get('schema_node'),
                eventHandler = m.top || m,
                node_info = this.column.get('node_info'),
                full_url = node.generate_url.apply(node, [null, url, this.column.get('node_data'), this.column.get('url_with_id') || false, node_info]),
                data = [];

            if (this.column.get('version_compatible')) {
              eventHandler.trigger('pgadmin:view:fetching', m, self.column);
              $.ajax({
                async: false,
                data: { col_type: col_type },
                url: full_url,
                success: function success(res) {
                  data = res.data;
                  self.column.set('options', data);
                },
                error: function error() {
                  eventHandler.trigger('pgadmin:view:fetch:error', m, self.column);
                }
              });
              eventHandler.trigger('pgadmin:view:fetched', m, self.column);
            }
          }
        }
      })
    }],
    validate: function validate() {
      this.errorModel.clear();
      var operator = this.get('operator'),
          column_name = this.get('column');
      if (_.isUndefined(operator) || _.isNull(operator)) {
        var msg = gettext('Please specify operator for column: ') + column_name;
        this.errorModel.set('operator', msg);
        return msg;
      }
      return null;
    }
  });

  var ExclusionConstraintColumnControl = Backform.ExclusionConstraintColumnControl = Backform.UniqueColCollectionControl.extend({

    initialize: function initialize(opts) {
      Backform.UniqueColCollectionControl.prototype.initialize.apply(this, arguments);

      var self = this,
          node = 'exclusion_constraint',
          headerSchema = [{
        id: 'column', label: '', type: 'text',
        node: 'column', control: Backform.NodeListByNameControl.extend({
          initialize: function initialize() {
            // Here we will decide if we need to call URL
            // Or fetch the data from parent columns collection
            if (self.model.handler) {
              Backform.Select2Control.prototype.initialize.apply(this, arguments);
              // Do not listen for any event(s) for existing constraint.
              if (_.isUndefined(self.model.get('oid'))) {
                var tableCols = self.model.top.get('columns');
                this.listenTo(tableCols, 'remove', this.removeColumn);
                this.listenTo(tableCols, 'change:name', this.resetColOptions);
                this.listenTo(tableCols, 'change:cltype', this.resetColOptions);
              }
              this.custom_options();
            } else {
              Backform.NodeListByNameControl.prototype.initialize.apply(this, arguments);
            }
          },
          removeColumn: function removeColumn(m) {
            var that = this;
            setTimeout(function () {
              that.custom_options();
              that.render.apply(that);
            }, 50);
          },
          resetColOptions: function resetColOptions(m) {
            var that = this;

            if (m.previous('name') == self.headerData.get('column')) {
              /*
               * Table column name has changed so update
               * column name in exclusion constraint as well.
               */
              self.headerData.set({ "column": m.get('name') });
              self.headerDataChanged();
            }

            setTimeout(function () {
              that.custom_options();
              that.render.apply(that);
            }, 50);
          },
          custom_options: function custom_options() {
            // We will add all the columns entered by user in table model
            var columns = self.model.top.get('columns'),
                added_columns_from_tables = [],
                col_types = [];

            if (columns.length > 0) {
              _.each(columns.models, function (m) {
                var col = m.get('name');
                if (!_.isUndefined(col) && !_.isNull(col)) {
                  added_columns_from_tables.push({
                    label: col, value: col, image: 'icon-column'
                  });
                  col_types.push({ name: col, type: m.get('cltype') });
                }
              });
            }
            // Set the values in to options so that user can select
            this.field.set('options', added_columns_from_tables);
            self.field.set('col_types', col_types);
          },
          remove: function remove() {
            if (self.model.handler) {
              var tableCols = self.model.top.get('columns');
              this.stopListening(tableCols, 'remove', this.removeColumn);
              this.stopListening(tableCols, 'change:name', this.resetColOptions);
              this.stopListening(tableCols, 'change:cltype', this.resetColOptions);

              Backform.Select2Control.prototype.remove.apply(this, arguments);
            } else {
              Backform.NodeListByNameControl.prototype.remove.apply(this, arguments);
            }
          },
          template: _.template(['<div class="<%=Backform.controlsClassName%> <%=extraClasses.join(\' \')%>">', '  <select class="pgadmin-node-select form-control" name="<%=name%>" style="width:100%;" value="<%-value%>" <%=disabled ? "disabled" : ""%> <%=required ? "required" : ""%> >', '    <% for (var i=0; i < options.length; i++) { %>', '    <% var option = options[i]; %>', '    <option <% if (option.image) { %> data-image=<%= option.image %> <% } %> value=<%= formatter.fromRaw(option.value) %> <%=option.value === rawValue ? "selected=\'selected\'" : "" %>><%-option.label%></option>', '    <% } %>', '  </select>', '</div>'].join("\n"))
        }),
        transform: function transform(rows) {
          // This will only get called in case of NodeListByNameControl.

          var that = this,
              node = that.field.get('schema_node'),
              res = [],
              col_types = [],
              filter = that.field.get('filter') || function () {
            return true;
          };

          filter = filter.bind(that);

          _.each(rows, function (r) {
            if (filter(r)) {
              var l = _.isFunction(node['node_label']) ? node['node_label'].apply(node, [r, that.model, that]) : r.label,
                  image = _.isFunction(node['node_image']) ? node['node_image'].apply(node, [r, that.model, that]) : node['node_image'] || 'icon-' + node.type;
              res.push({
                'value': r.label,
                'image': image,
                'label': l
              });
              col_types.push({ name: r.label, type: r.datatype });
            }
          });
          self.field.set('col_types', col_types);
          return res;
        },
        canAdd: function canAdd(m) {
          return !(_.has(m, 'handler') && !_.isUndefined(m.handler) && !_.isUndefined(m.get('oid')) || _.isFunction(m.isNew) && !m.isNew());
        },
        select2: {
          allowClear: false, width: 'style',
          placeholder: 'Select column'
        }, first_empty: !self.model.isNew(),
        disabled: function disabled(m) {
          return !_.isUndefined(self.model.get('oid'));
        }
      }],
          headerDefaults = { column: null },
          gridCols = ['column', 'oper_class', 'order', 'nulls_order', 'operator'];

      self.headerData = new (Backbone.Model.extend({
        defaults: headerDefaults,
        schema: headerSchema
      }))({});

      var headerGroups = Backform.generateViewSchema(self.field.get('node_info'), self.headerData, 'create', node, self.field.get('node_data')),
          fields = [];

      _.each(headerGroups, function (o) {
        fields = fields.concat(o.fields);
      });

      self.headerFields = new Backform.Fields(fields);
      self.gridSchema = Backform.generateGridColumnsFromModel(self.field.get('node_info'), self.field.get('model'), 'edit', gridCols, self.field.get('schema_node'));

      self.controls = [];
      self.listenTo(self.headerData, "change", self.headerDataChanged);
      self.listenTo(self.headerData, "select2", self.headerDataChanged);
      self.listenTo(self.collection, "add", self.onAddorRemoveColumns);
      self.listenTo(self.collection, "remove", self.onAddorRemoveColumns);
    },

    generateHeader: function generateHeader(data) {
      var header = ['<div class="subnode-header-form">', ' <div class="container-fluid">', '  <div class="row">', '   <div class="col-xs-4">', '    <label class="control-label"><%-column_label%></label>', '   </div>', '   <div class="col-xs-4" header="column"></div>', '   <div class="col-xs-4">', '     <button class="btn-sm btn-default add fa fa-plus" <%=canAdd ? "" : "disabled=\'disabled\'"%> ></button>', '   </div>', '  </div>', ' </div>', '</div>'].join("\n");

      _.extend(data, {
        column_label: gettext('Column')
      });

      var self = this,
          headerTmpl = _.template(header),
          $header = $(headerTmpl(data)),
          controls = this.controls;

      this.headerFields.each(function (field) {
        var control = new (field.get("control"))({
          field: field,
          model: self.headerData
        });

        $header.find('div[header="' + field.get('name') + '"]').append(control.render().$el);

        controls.push(control);
      });

      // We should not show in properties mode
      if (data.mode == 'properties') {
        $header.html('');
      }

      self.$header = $header;

      return $header;
    },

    events: _.extend({}, Backform.UniqueColCollectionControl.prototype.events, { 'click button.add': 'addColumns' }),

    showGridControl: function showGridControl(data) {
      var self = this,
          titleTmpl = _.template("<div class='subnode-header'></div>"),
          $gridBody = $("<div class='pgadmin-control-group backgrid form-group col-xs-12 object subnode'></div>").append(
      // Append titleTmpl only if create/edit mode
      data.mode !== 'properties' ? titleTmpl({ label: data.label }) : '');

      $gridBody.append(self.generateHeader(data));

      var gridColumns = _.clone(this.gridSchema.columns);

      // Insert Delete Cell into Grid
      if (data.disabled == false && data.canDelete) {
        gridColumns.unshift({
          name: "pg-backform-delete", label: "",
          cell: Backgrid.Extension.DeleteCell,
          editable: false, cell_priority: -1
        });
      }

      if (self.grid) {
        self.grid.remove();
        self.grid.null;
      }
      // Initialize a new Grid instance
      var grid = self.grid = new Backgrid.Grid({
        columns: gridColumns,
        collection: self.collection,
        className: "backgrid table-bordered"
      });
      self.$grid = grid.render().$el;

      $gridBody.append(self.$grid);

      setTimeout(function () {
        self.headerData.set({
          'column': self.$header.find('div[header="column"] select').val()
        }, { silent: true });
      }, 10);

      // Remove unwanted class from grid to display it properly
      if (data.mode === 'properties') $gridBody.find('.subnode-header-form').removeClass('subnode-header-form');

      // Render node grid
      return $gridBody;
    },

    headerDataChanged: function headerDataChanged() {
      var self = this,
          val,
          data = this.headerData.toJSON(),
          inSelected = false,
          checkVars = ['column'];

      if (!self.$header) {
        return;
      }

      if (self.control_data.canAdd) {
        self.collection.each(function (m) {
          if (!inSelected) {
            _.each(checkVars, function (v) {
              if (!inSelected) {
                val = m.get(v);
                inSelected = (_.isUndefined(val) || _.isNull(val)) && (_.isUndefined(data[v]) || _.isNull(data[v])) || val == data[v];
              }
            });
          }
        });
      } else {
        inSelected = true;
      }

      self.$header.find('button.add').prop('disabled', inSelected);
    },

    addColumns: function addColumns(ev) {
      ev.preventDefault();
      var self = this,
          column = self.headerData.get('column');

      if (!column || column == '') {
        return false;
      }

      var coll = self.model.get(self.field.get('name')),
          m = new (self.field.get('model'))(self.headerData.toJSON(), {
        silent: true, top: self.model.top,
        collection: coll, handler: coll
      }),
          col_types = self.field.get('col_types') || [];

      for (var i = 0; i < col_types.length; i++) {
        var col_type = col_types[i];
        if (col_type['name'] == m.get('column')) {
          m.set({ 'col_type': col_type['type'] });
          break;
        }
      }

      coll.add(m);

      var idx = coll.indexOf(m);

      // idx may not be always > -1 because our UniqueColCollection may
      // remove 'm' if duplicate value found.
      if (idx > -1) {
        self.$grid.find('.new').removeClass('new');

        var newRow = self.grid.body.rows[idx].$el;

        newRow.addClass("new");
        $(newRow).pgMakeVisible('backform-tab');
      } else {
        //delete m;
      }

      return false;
    },

    onAddorRemoveColumns: function onAddorRemoveColumns() {
      var self = this;

      // Wait for collection to be updated before checking for the button to be
      // enabled, or not.
      setTimeout(function () {
        self.collection.trigger('pgadmin:columns:updated', self.collection);
        self.headerDataChanged();
      }, 10);
    },

    remove: function remove() {
      /*
       * Stop listening the events registered by this control.
       */
      this.stopListening(this.headerData, "change", this.headerDataChanged);
      this.listenTo(this.headerData, "select2", this.headerDataChanged);
      this.listenTo(this.collection, "remove", this.onAddorRemoveColumns);

      // Remove header controls.
      _.each(this.controls, function (controls) {
        controls.remove();
      });

      ExclusionConstraintColumnControl.__super__.remove.apply(this, arguments);

      // Remove the header model
      delete this.headerData;
    }
  });

  // Extend the browser's node class for exclusion constraint node
  if (!pgBrowser.Nodes['exclusion_constraint']) {
    pgAdmin.Browser.Nodes['exclusion_constraint'] = pgBrowser.Node.extend({
      getTreeNodeHierarchy: pgBrowser.tableChildTreeNodeHierarchy,
      type: 'exclusion_constraint',
      label: gettext('Exclusion constraint'),
      collection_type: 'coll-constraints',
      sqlAlterHelp: 'ddl-alter.html',
      sqlCreateHelp: 'ddl-constraints.html',
      dialogHelp: url_for('help.static', { 'filename': 'exclusion_constraint_dialog.html' }),
      hasSQL: true,
      parent_type: ['table', 'partition'],
      canDrop: true,
      canDropCascade: true,
      hasDepends: true,
      hasStatistics: true,
      statsPrettifyFields: ['Index size'],
      Init: function Init() {
        /* Avoid multiple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_exclusion_constraint_on_coll', node: 'coll-constraints', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Exclusion constraint...'),
          icon: 'wcTabIcon icon-exclusion_constraint', data: { action: 'create', check: true },
          enable: 'canCreate'
        }]);
      },
      is_not_valid: function is_not_valid(node) {
        return node && !node.valid;
      },
      // Define the model for exclusion constraint node
      model: pgAdmin.Browser.Node.Model.extend({
        idAttribute: 'oid',

        defaults: {
          name: undefined,
          oid: undefined,
          comment: undefined,
          spcname: undefined,
          amname: "gist",
          fillfactor: undefined,
          condeferrable: undefined,
          condeferred: undefined,
          columns: []
        },

        // Define the schema for the exclusion constraint node
        schema: [{
          id: 'name', label: gettext('Name'), type: 'text',
          mode: ['properties', 'create', 'edit'], editable: true
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', mode: ['properties']
        }, {
          id: 'comment', label: gettext('Comment'), cell: 'string',
          type: 'multiline', mode: ['properties', 'create', 'edit'],
          deps: ['name'], disabled: function disabled(m) {
            var name = m.get('name');
            if (!(name && name != '')) {
              setTimeout(function () {
                if (m.get('comment') && m.get('comment') !== '') m.set('comment', null);
              }, 10);
              return true;
            } else {
              return false;
            }
          }
        }, {
          id: 'spcname', label: gettext('Tablespace'),
          type: 'text', group: gettext('Definition'),
          control: 'node-list-by-name', node: 'tablespace',
          select2: { allowClear: false },
          filter: function filter(m) {
            // Don't show pg_global tablespace in selection.
            if (m.label == "pg_global") return false;else return true;
          }
        }, {
          id: 'amname', label: gettext('Access method'),
          type: 'text', group: gettext('Definition'),
          url: "get_access_methods", node: 'table',
          control: Backform.NodeAjaxOptionsControl.extend({
            // When access method changes we need to clear columns collection
            onChange: function onChange() {
              Backform.NodeAjaxOptionsControl.prototype.onChange.apply(this, arguments);
              var self = this,

              // current access method
              current_am = self.model.get('amname'),

              // previous access method
              previous_am = self.model.previous('amname'),
                  column_collection = self.model.get('columns');

              if (column_collection.length > 0 && current_am != previous_am) {
                var msg = gettext('Changing access method will clear columns collection');
                Alertify.confirm(msg, function (e) {
                  // User clicks Ok, lets clear collection.
                  column_collection.each(function (m) {
                    /*
                     * Our datamodel do not support collection reset method.
                     * So remove model one by one.
                     */
                    column_collection.remove(m);
                  });
                  setTimeout(function () {
                    column_collection.trigger('pgadmin:columns:updated', column_collection);
                  }, 10);
                }, function () {
                  // User clicks Cancel set previous value again in combo box
                  setTimeout(function () {
                    self.model.set('amname', previous_am);
                  }, 10);
                });
              }
            }
          }),
          select2: { allowClear: true },
          disabled: function disabled(m) {
            return _.has(m, 'handler') && !_.isUndefined(m.handler) && !_.isUndefined(m.get('oid')) || _.isFunction(m.isNew) && !m.isNew();
          }
        }, {
          id: 'fillfactor', label: gettext('Fill factor'),
          type: 'int', group: gettext('Definition'), allowNull: true
        }, {
          id: 'condeferrable', label: gettext('Deferrable?'),
          type: 'switch', group: gettext('Definition'), deps: ['index'],
          disabled: function disabled(m) {
            return _.has(m, 'handler') && !_.isUndefined(m.handler) && !_.isUndefined(m.get('oid')) || _.isFunction(m.isNew) && !m.isNew();
          }
        }, {
          id: 'condeferred', label: gettext('Deferred?'),
          type: 'switch', group: gettext('Definition'),
          deps: ['condeferrable'],
          disabled: function disabled(m) {
            if (_.has(m, 'handler') && !_.isUndefined(m.handler) && !_.isUndefined(m.get('oid')) || _.isFunction(m.isNew) && !m.isNew()) {
              return true;
            }

            // Disable if condeferred is false or unselected.
            if (m.get('condeferrable') == true) {
              return false;
            } else {
              setTimeout(function () {
                if (m.get('condeferred')) m.set('condeferred', false);
              }, 10);
              return true;
            }
          }
        }, {
          id: 'constraint', label: gettext('Constraint'), cell: 'string',
          type: 'multiline', mode: ['create', 'edit'], editable: false,
          group: gettext('Definition'), disabled: function disabled(m) {
            return _.has(m, 'handler') && !_.isUndefined(m.handler) && !_.isUndefined(m.get('oid')) || _.isFunction(m.isNew) && !m.isNew();
          }
        }, {
          id: 'columns', label: gettext('Columns'),
          type: 'collection', group: gettext('Columns'),
          deps: ['amname'], canDelete: true, editable: false,
          canAdd: function canAdd(m) {
            // We can't update columns of existing exclusion constraint.
            return !(_.has(m, 'handler') && !_.isUndefined(m.handler) && !_.isUndefined(m.get('oid')) || _.isFunction(m.isNew) && !m.isNew());
          },
          control: ExclusionConstraintColumnControl,
          model: ExclusionConstraintColumnModel,
          disabled: function disabled(m) {
            return _.has(m, 'handler') && !_.isUndefined(m.handler) && !_.isUndefined(m.get('oid')) || _.isFunction(m.isNew) && !m.isNew();
          },
          cell: Backgrid.StringCell.extend({
            initialize: function initialize() {
              Backgrid.StringCell.prototype.initialize.apply(this, arguments);
              var self = this;
              // Do not listen for any event(s) for existing constraint.
              if (_.isUndefined(self.model.get('oid'))) {
                var tableCols = self.model.top.get('columns');

                self.listenTo(tableCols, 'remove', self.removeColumn);
                self.listenTo(tableCols, 'change:name', self.resetColOptions);
                self.listenTo(tableCols, 'change:cltype', self.removeColumnWithType);
              }

              this.model.get('columns').on('pgadmin:columns:updated', function () {
                self.render.apply(self);
              });
            },
            removeColumnWithType: function removeColumnWithType(m) {
              var self = this,
                  cols = self.model.get('columns'),
                  removedCols = cols.where({ col_type: m.previous('cltype') });

              cols.remove(removedCols);
              setTimeout(function () {
                self.render();
              }, 10);

              setTimeout(function () {
                var constraints = self.model.top.get("exclude_constraint");
                var removed = [];
                constraints.each(function (constraint) {
                  if (constraint.get("columns").length == 0) {
                    removed.push(constraint);
                  }
                });
                constraints.remove(removed);
              }, 100);
            },
            removeColumn: function removeColumn(m) {
              var self = this,
                  removedCols = self.model.get('columns').where({ column: m.get('name') });

              self.model.get('columns').remove(removedCols);
              setTimeout(function () {
                self.render();
              }, 10);

              setTimeout(function () {
                var constraints = self.model.top.get("exclude_constraint");
                var removed = [];
                constraints.each(function (constraint) {
                  if (constraint.get("columns").length == 0) {
                    removed.push(constraint);
                  }
                });
                constraints.remove(removed);
              }, 100);
            },
            resetColOptions: function resetColOptions(m) {
              var self = this,
                  updatedCols = self.model.get('columns').where({ "column": m.previous('name') });

              if (updatedCols.length > 0) {
                /*
                 * Table column name has changed so update
                 * column name in foreign key as well.
                 */
                updatedCols[0].set({ "column": m.get('name') });
              }

              setTimeout(function () {
                self.render();
              }, 10);
            },
            formatter: {
              fromRaw: function fromRaw(rawValue, model) {
                return rawValue.pluck("column").toString();
              },
              toRaw: function toRaw(val, model) {
                return val;
              }
            },
            render: function render() {
              return Backgrid.StringCell.prototype.render.apply(this, arguments);
            },
            remove: function remove() {
              var tableCols = this.model.top.get('columns'),
                  cols = this.model.get('columns');
              if (cols) {
                cols.off('pgadmin:columns:updated');
              }

              this.stopListening(tableCols, 'remove', self.removeColumn);
              this.stopListening(tableCols, 'change:name', self.resetColOptions);
              this.stopListening(tableCols, 'change:cltype', self.removeColumnWithType);

              Backgrid.StringCell.prototype.remove.apply(this, arguments);
            }
          })
        }],
        validate: function validate() {
          this.errorModel.clear();
          var columns = this.get('columns'),
              name = this.get('name');

          if (_.isUndefined(name) || _.isNull(name) || name.length < 1) {
            var msg = gettext('Please specify name for exclusion constraint.');
            this.errorModel.set('name', msg);
            return msg;
          } else if (_.isUndefined(columns) || _.isNull(columns) || columns.length < 1) {
            var msg = gettext('Please specify columns for exclusion constraint.');
            this.errorModel.set('columns', msg);
            return msg;
          }

          return null;
        }
      }),

      canCreate: function canCreate(itemData, item, data) {
        // If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData,
            parents = [],
            immediate_parent_table_found = false,
            is_immediate_parent_table_partitioned = false;
        // To iterate over tree to check parent node
        while (i) {
          // If table is partitioned table then return false
          if (!immediate_parent_table_found && (d._type == 'table' || d._type == 'partition')) {
            immediate_parent_table_found = true;
            if ('is_partitioned' in d && d.is_partitioned) {
              is_immediate_parent_table_partitioned = true;
            }
          }

          // If it is schema then allow user to create table
          if (_.indexOf(['schema'], d._type) > -1) return !is_immediate_parent_table_partitioned;
          parents.push(d._type);
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // If node is under catalog then do not allow 'create' menu
        if (_.indexOf(parents, 'catalog') > -1) {
          return false;
        } else {
          return !is_immediate_parent_table_partitioned;
        }
      }
    });
  }

  return pgBrowser.Nodes['exclusion_constraint'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10), __webpack_require__(13)))

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backgrid) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, alertify) {

  // Extend the browser's node class for index constraint node
  if (!pgBrowser.Nodes['primary_key']) {
    pgAdmin.Browser.Nodes['primary_key'] = pgBrowser.Node.extend({
      type: 'primary_key',
      label: gettext('Primary key'),
      collection_type: 'coll-constraints',
      sqlAlterHelp: 'ddl-alter.html',
      sqlCreateHelp: 'ddl-constraints.html',
      dialogHelp: url_for('help.static', { filename: 'primary_key_dialog.html' }),
      hasSQL: true,
      hasDepends: true,
      hasStatistics: true,
      statsPrettifyFields: ['Index size'],
      parent_type: ['table', 'partition'],
      canDrop: true,
      canDropCascade: true,
      getTreeNodeHierarchy: pgBrowser.tableChildTreeNodeHierarchy,
      Init: function Init() {
        /* Avoid multiple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'create_primary_key_on_coll', node: 'coll-constraints', module: this,
          applies: ['object', 'context'], callback: 'show_obj_properties',
          category: 'create', priority: 4, label: gettext('Primary key'),
          icon: 'wcTabIcon icon-primary_key', data: { action: 'create', check: true },
          enable: 'canCreate'

        }]);
      },
      canCreate: function canCreate(itemData, item, data) {
        // If check is false then , we will allow create menu
        if (data && data.check == false) return true;

        var t = pgBrowser.tree,
            i = item,
            d = itemData,
            parents = [],
            immediate_parent_table_found = false,
            is_immediate_parent_table_partitioned = false;

        // To iterate over tree to check parent node
        while (i) {
          // If table is partitioned table then return false
          if (!immediate_parent_table_found && (d._type == 'table' || d._type == 'partition')) {
            immediate_parent_table_found = true;
            if ('is_partitioned' in d && d.is_partitioned) {
              is_immediate_parent_table_partitioned = true;
            }
          }

          // If it is schema then allow user to c reate table
          if (_.indexOf(['schema'], d._type) > -1) {
            if (is_immediate_parent_table_partitioned) {
              return false;
            }

            // There should be only one primary key per table.
            var children = t.children(arguments[1], false),
                primary_key_found = false;

            _.each(children, function (child) {
              data = pgBrowser.tree.itemData($(child));
              if (!primary_key_found && data._type == "primary_key") {
                primary_key_found = true;
              }
            });
            return !primary_key_found;
          }
          parents.push(d._type);
          i = t.hasParent(i) ? t.parent(i) : null;
          d = i ? t.itemData(i) : null;
        }
        // If node is under catalog then do not allow 'create' menu
        if (_.indexOf(parents, 'catalog') > -1) {
          return false;
        } else {
          return !is_immediate_parent_table_partitioned;
        }
      },

      // Define the model for index constraint node
      model: pgAdmin.Browser.Node.Model.extend({
        idAttribute: 'oid',

        defaults: {
          name: undefined,
          oid: undefined,
          comment: undefined,
          spcname: undefined,
          index: undefined,
          fillfactor: undefined,
          condeferrable: undefined,
          condeferred: undefined,
          columns: []
        },

        // Define the schema for the index constraint node
        schema: [{
          id: 'name', label: gettext('Name'), type: 'text',
          mode: ['properties', 'create', 'edit'], editable: true,
          cellHeaderClasses: 'width_percent_40'
        }, {
          id: 'oid', label: gettext('OID'), cell: 'string',
          type: 'text', mode: ['properties'], editable: false,
          cellHeaderClasses: 'width_percent_20'
        }, {
          id: 'comment', label: gettext('Comment'), cell: 'string',
          type: 'multiline', mode: ['properties', 'create', 'edit'],
          deps: ['name'], disabled: function disabled(m) {
            var name = m.get('name');
            if (!(name && name != '')) {
              setTimeout(function () {
                if (m.get('comment') && m.get('comment') !== '') {
                  m.set('comment', null);
                }
              }, 10);
              return true;
            } else {
              return false;
            }
          }
        }, {
          id: 'columns', label: gettext('Columns'),
          type: 'collection', group: gettext('Definition'),
          editable: false,
          cell: Backgrid.StringCell.extend({
            initialize: function initialize() {
              Backgrid.StringCell.prototype.initialize.apply(this, arguments);

              var self = this,
                  collection = this.model.get('columns');

              // Do not listen for any event(s) for existing constraint.
              if (_.isUndefined(self.model.get('oid'))) {
                var tableCols = self.model.top.get('columns');
                self.listenTo(tableCols, 'remove', self.removeColumn);
                self.listenTo(tableCols, 'change:name', self.resetColOptions);
              }

              collection.on('pgadmin:multicolumn:updated', function () {
                self.render.apply(self);
              });
              self.listenTo(collection, "add", self.render);
              self.listenTo(collection, "remove", self.render);
            },
            removeColumn: function removeColumn(m) {
              var self = this,
                  removedCols = self.model.get('columns').where({ column: m.get('name') });

              self.model.get('columns').remove(removedCols);
              setTimeout(function () {
                self.render();
              }, 10);

              var key = 'primary_key';
              setTimeout(function () {
                constraints = self.model.top.get(key);
                var removed = [];
                constraints.each(function (constraint) {
                  if (constraint.get("columns").length == 0) {
                    removed.push(constraint);
                  }
                });
                constraints.remove(removed);
              }, 100);
            },
            resetColOptions: function resetColOptions(m) {
              var self = this,
                  updatedCols = self.model.get('columns').where({ column: m.previous('name') });
              if (updatedCols.length > 0) {
                /*
                 * Table column name has changed so update
                 * column name in primary key as well.
                 */
                updatedCols[0].set({ "column": m.get('name') }, { silent: true });
              }

              setTimeout(function () {
                self.render();
              }, 10);
            },
            formatter: {
              fromRaw: function fromRaw(rawValue, model) {
                return rawValue.pluck("column").toString();
              },
              toRaw: function toRaw(val, model) {
                return val;
              }
            },
            render: function render() {
              return Backgrid.StringCell.prototype.render.apply(this, arguments);
            },
            remove: function remove() {
              var tableCols = this.model.top.get('columns'),
                  primary_key_col = this.model.get('columns');

              if (primary_key_col) {
                primary_key_col.off('pgadmin:multicolumn:updated');
              }

              this.stopListening(tableCols, 'remove', self.removeColumn);
              this.stopListening(tableCols, 'change:name', self.resetColOptions);

              Backgrid.StringCell.prototype.remove.apply(this, arguments);
            }
          }),
          canDelete: true, canAdd: true,
          control: Backform.MultiSelectAjaxControl.extend({
            defaults: _.extend({}, Backform.NodeListByNameControl.prototype.defaults, {
              select2: {
                multiple: true,
                allowClear: true,
                width: 'style',
                placeholder: gettext('Select the column(s)')
              }
            }),
            keyPathAccessor: function keyPathAccessor(obj, path) {
              var res = obj;
              if (_.isArray(res)) {
                return _.map(res, function (o) {
                  return o['column'];
                });
              }
              path = path.split('.');
              for (var i = 0; i < path.length; i++) {
                if (_.isNull(res)) return null;
                if (_.isEmpty(path[i])) continue;
                if (!_.isUndefined(res[path[i]])) res = res[path[i]];
              }
              return _.isObject(res) && !_.isArray(res) ? null : res;
            },
            initialize: function initialize() {
              // Here we will decide if we need to call URL
              // Or fetch the data from parent columns collection
              var self = this;
              if (this.model.handler) {
                Backform.Select2Control.prototype.initialize.apply(this, arguments);
                // Do not listen for any event(s) for existing constraint.
                if (_.isUndefined(self.model.get('oid'))) {
                  var tableCols = self.model.top.get('columns');
                  self.listenTo(tableCols, 'remove', self.resetColOptions);
                  self.listenTo(tableCols, 'change:name', self.resetColOptions);
                }

                self.custom_options();
              } else {
                Backform.MultiSelectAjaxControl.prototype.initialize.apply(this, arguments);
              }
              self.model.get('columns').on('pgadmin:multicolumn:updated', function () {
                self.render.apply(self);
              });
            },
            resetColOptions: function resetColOptions(m) {
              var self = this;

              setTimeout(function () {
                self.custom_options();
                self.render.apply(self);
              }, 50);
            },
            custom_options: function custom_options() {
              // We will add all the columns entered by user in table model
              var columns = this.model.top.get('columns'),
                  added_columns_from_tables = [];

              if (columns.length > 0) {
                _.each(columns.models, function (m) {
                  var col = m.get('name');
                  if (!_.isUndefined(col) && !_.isNull(col)) {
                    added_columns_from_tables.push({ label: col, value: col, image: 'icon-column' });
                  }
                });
              }
              // Set the values in to options so that user can select
              this.field.set('options', added_columns_from_tables);
            },
            onChange: function onChange(e) {
              var self = this,
                  model = this.model,
                  $el = $(e.target),
                  attrArr = this.field.get("name").split('.'),
                  name = attrArr.shift(),
                  path = attrArr.join('.'),
                  vals = this.getValueFromDOM(),
                  collection = model.get(name),
                  removed = [];

              this.stopListening(this.model, "change:" + name, this.render);

              /*
               * Iterate through all the values, and find out how many are already
               * present in the collection.
               */
              collection.each(function (m) {
                var column = m.get('column'),
                    idx = _.indexOf(vals, column);

                if (idx > -1) {
                  vals.splice(idx, 1);
                } else {
                  removed.push(column);
                }
              });

              /*
               * Adding new values
               */

              _.each(vals, function (v) {
                var m = new (self.field.get('model'))({ column: v }, { silent: true,
                  top: self.model.top,
                  collection: collection,
                  handler: collection
                });

                collection.add(m);
              });

              /*
               * Removing unwanted!
               */
              _.each(removed, function (v) {
                collection.remove(collection.where({ column: v }));
              });

              this.listenTo(this.model, "change:" + name, this.render);
            },
            remove: function remove() {
              if (this.model.handler) {
                var self = this,
                    tableCols = self.model.top.get('columns');
                self.stopListening(tableCols, 'remove', self.resetColOptions);
                self.stopListening(tableCols, 'change:name', self.resetColOptions);
                self.model.get('columns').off('pgadmin:multicolumn:updated');

                Backform.Select2Control.prototype.remove.apply(this, arguments);
              } else {
                Backform.MultiSelectAjaxControl.prototype.remove.apply(this, arguments);
              }
            }
          }),
          deps: ['index'], node: 'column',
          model: pgBrowser.Node.Model.extend({
            defaults: {
              column: undefined
            },
            validate: function validate() {
              return null;
            }
          }),
          transform: function transform(data) {
            var res = [];
            if (data && _.isArray(data)) {
              _.each(data, function (d) {
                res.push({ label: d.label, value: d.label, image: 'icon-column' });
              });
            }
            return res;
          },
          select2: { allowClear: false },
          disabled: function disabled(m) {
            // If we are in table edit mode then
            if (_.has(m, 'top') && !_.isUndefined(m.top) && !m.top.isNew()) {
              // If OID is undefined then user is trying to add
              // new constraint which should be allowed for Unique
              return !_.isUndefined(m.get('oid'));
            }

            // We can't update columns of existing index constraint.
            if (!m.isNew()) {
              return true;
            }
            // Disable if index is selected.
            var index = m.get('index');
            if (_.isUndefined(index) || index == '') {
              return false;
            } else {
              var col = m.get('columns');
              col.reset();
              return true;
            }
          }
        }, {
          id: 'spcname', label: gettext('Tablespace'),
          type: 'text', group: gettext('Definition'),
          control: 'node-list-by-name', node: 'tablespace',
          deps: ['index'],
          select2: { allowClear: false },
          filter: function filter(m) {
            // Don't show pg_global tablespace in selection.
            if (m.label == "pg_global") return false;else return true;
          },
          disabled: function disabled(m) {
            // Disable if index is selected.
            m = m.top || m;
            var index = m.get('index');
            if (_.isUndefined(index) || index == '') {
              return false;
            } else {
              setTimeout(function () {
                m.set('spcname', '');
              }, 10);
              return true;
            }
          }
        }, {
          id: 'index', label: gettext('Index'),
          type: 'text', group: gettext('Definition'),
          control: Backform.NodeListByNameControl.extend({
            initialize: function initialize() {
              if (_.isUndefined(this.model.top)) {
                Backform.NodeListByNameControl.prototype.initialize.apply(this, arguments);
              } else {
                Backform.Control.prototype.initialize.apply(this, arguments);
              }
            }
          }),
          select2: { allowClear: true }, node: 'index',
          disabled: function disabled(m) {
            // If we are in table edit mode then disable it
            if (_.has(m, 'top') && !_.isUndefined(m.top) && !m.top.isNew()) {
              return true;
            }

            // We can't update index of existing index constraint.
            return !m.isNew();
          },
          // We will not show this field in Create Table mode
          visible: function visible(m) {
            return !_.isUndefined(m.top.node_info['table']);
          }
        }, {
          id: 'fillfactor', label: gettext('Fill factor'), deps: ['index'],
          type: 'int', group: gettext('Definition'), allowNull: true,
          disabled: function disabled(m) {
            // Disable if index is selected.
            var index = m.get('index');
            if (_.isUndefined(index) || index == '') {
              return false;
            } else {
              setTimeout(function () {
                m.set('fillfactor', null);
              }, 10);
              return true;
            }
          }
        }, {
          id: 'condeferrable', label: gettext('Deferrable?'),
          type: 'switch', group: gettext('Definition'), deps: ['index'],
          disabled: function disabled(m) {
            // If we are in table edit mode then
            if (_.has(m, 'top') && !_.isUndefined(m.top) && !m.top.isNew()) {
              // If OID is undefined then user is trying to add
              // new constraint which should allowed for Unique
              return !_.isUndefined(m.get('oid'));
            }

            // We can't update condeferrable of existing index constraint.
            if (!m.isNew()) {
              return true;
            }
            // Disable if index is selected.
            var index = m.get('index');
            if (_.isUndefined(index) || index == '') {
              return false;
            } else {
              setTimeout(function () {
                if (m.get('condeferrable')) m.set('condeferrable', false);
              }, 10);
              return true;
            }
          }
        }, {
          id: 'condeferred', label: gettext('Deferred?'),
          type: 'switch', group: gettext('Definition'),
          deps: ['condeferrable'],
          disabled: function disabled(m) {
            // If we are in table edit mode then
            if (_.has(m, 'top') && !_.isUndefined(m.top) && !m.top.isNew()) {
              // If OID is undefined then user is trying to add
              // new constraint which should allowed for Unique
              return !_.isUndefined(m.get('oid'));
            }

            // We can't update condeferred of existing index constraint.
            if (!m.isNew()) {
              return true;
            }
            // Disable if condeferred is false or unselected.
            if (m.get('condeferrable') == true) {
              return false;
            } else {
              setTimeout(function () {
                if (m.get('condeferred')) m.set('condeferred', false);
              }, 10);
              return true;
            }
          }
        }],
        validate: function validate() {
          this.errorModel.clear();
          // Clear parent's error as well
          if (_.has(this, 'top')) {
            this.top.errorModel.clear();
          }

          var columns = this.get('columns'),
              index = this.get('index');

          if ((_.isUndefined(index) || String(index).replace(/^\s+|\s+$/g, '') == '') && (_.isUndefined(columns) || _.isNull(columns) || columns.length < 1)) {
            var msg = gettext('Please specify columns for %(node)s', { node: gettext('Primary key') });
            this.errorModel.set('columns', msg);
            return msg;
          }

          return null;
        }
      })
    });
  }

  return pgBrowser.Nodes['primary_key'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Backgrid) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(5), __webpack_require__(0), __webpack_require__(1), __webpack_require__(4), __webpack_require__(3), __webpack_require__(6), __webpack_require__(16), __webpack_require__(17), __webpack_require__(9), __webpack_require__(199)], __WEBPACK_AMD_DEFINE_RESULT__ = function (gettext, url_for, $, _, S, pgAdmin, pgBrowser, Backform, alertify) {

  if (!pgBrowser.Nodes['coll-partition']) {
    var databases = pgAdmin.Browser.Nodes['coll-partition'] = pgAdmin.Browser.Collection.extend({
      node: 'partition',
      label: gettext('Partitions'),
      getTreeNodeHierarchy: pgBrowser.tableChildTreeNodeHierarchy,
      type: 'coll-partition',
      columns: ['name', 'schema', 'partition_value', 'is_partitioned', 'description']
    });
  };

  if (!pgBrowser.Nodes['partition']) {
    var _pgBrowser$Node$exten;

    pgAdmin.Browser.Nodes['partition'] = pgBrowser.Node.extend((_pgBrowser$Node$exten = {
      getTreeNodeHierarchy: pgBrowser.tableChildTreeNodeHierarchy,
      parent_type: 'table',
      collection_type: 'coll-partition',
      type: 'partition',
      label: gettext('Partition'),
      hasSQL: true,
      hasDepends: true,
      hasStatistics: true,
      statsPrettifyFields: ['Size', 'Indexes size', 'Table size', 'Toast table size', 'Tuple length', 'Dead tuple length', 'Free space'],
      sqlAlterHelp: 'sql-altertable.html',
      sqlCreateHelp: 'sql-createtable.html',
      dialogHelp: url_for('help.static', { 'filename': 'table_dialog.html' }),
      hasScriptTypes: ['create'],
      height: '95%',
      width: '85%',
      Init: function Init() {
        /* Avoid mulitple registration of menus */
        if (this.initialized) return;

        this.initialized = true;

        pgBrowser.add_menus([{
          name: 'truncate_table', node: 'partition', module: this,
          applies: ['object', 'context'], callback: 'truncate_table',
          category: 'Truncate', priority: 3, label: gettext('Truncate'),
          icon: 'fa fa-eraser', enable: 'canCreate'
        }, {
          name: 'truncate_table_cascade', node: 'partition', module: this,
          applies: ['object', 'context'], callback: 'truncate_table_cascade',
          category: 'Truncate', priority: 3, label: gettext('Truncate Cascade'),
          icon: 'fa fa-eraser', enable: 'canCreate'
        }, {
          // To enable/disable all triggers for the table
          name: 'enable_all_triggers', node: 'partition', module: this,
          applies: ['object', 'context'], callback: 'enable_triggers_on_table',
          category: 'Trigger(s)', priority: 4, label: gettext('Enable All'),
          icon: 'fa fa-check', enable: 'canCreate_with_trigger_enable'
        }, {
          name: 'disable_all_triggers', node: 'partition', module: this,
          applies: ['object', 'context'], callback: 'disable_triggers_on_table',
          category: 'Trigger(s)', priority: 4, label: gettext('Disable All'),
          icon: 'fa fa-times', enable: 'canCreate_with_trigger_disable'
        }, {
          name: 'reset_table_stats', node: 'partition', module: this,
          applies: ['object', 'context'], callback: 'reset_table_stats',
          category: 'Reset', priority: 4, label: gettext('Reset Statistics'),
          icon: 'fa fa-bar-chart', enable: 'canCreate'
        }, {
          name: 'detach_partition', node: 'partition', module: this,
          applies: ['object', 'context'], callback: 'detach_partition',
          priority: 2, label: gettext('Detach Partition'),
          icon: 'fa fa-remove'
        }]);
      }
    }, _defineProperty(_pgBrowser$Node$exten, 'getTreeNodeHierarchy', function getTreeNodeHierarchy(i) {
      var idx = 0,
          res = {},
          t = pgBrowser.tree;

      do {
        var d = t.itemData(i);
        if (d._type in pgBrowser.Nodes && pgBrowser.Nodes[d._type].hasId) {
          if (d._type == 'partition' && 'partition' in res) {
            if (!('table' in res)) {
              res['table'] = _.extend({}, d, { 'priority': idx });
              idx -= 1;
            }
          } else if (d._type == 'table') {
            if (!('table' in res)) {
              res['table'] = _.extend({}, d, { 'priority': idx });
              idx -= 1;
            }
          } else {
            res[d._type] = _.extend({}, d, { 'priority': idx });
            idx -= 1;
          }
        }
        i = t.hasParent(i) ? t.parent(i) : null;
      } while (i);

      return res;
    }), _defineProperty(_pgBrowser$Node$exten, 'generate_url', function generate_url(item, type, d, with_id, info) {
      if (_.indexOf(['stats', 'statistics', 'dependency', 'dependent', 'reset', 'get_relations', 'get_oftype', 'get_attach_tables'], type) == -1) {
        return pgBrowser.Node.generate_url.apply(this, arguments);
      }

      if (type == 'statistics') {
        type = 'stats';
      }

      info = _.isUndefined(item) || _.isNull(item) ? info || {} : this.getTreeNodeHierarchy(item);

      return S('table/%s/%s/%s/%s/%s/%s').sprintf(encodeURIComponent(type), encodeURIComponent(info['server_group']._id), encodeURIComponent(info['server']._id), encodeURIComponent(info['database']._id), encodeURIComponent(info['partition'].schema_id), encodeURIComponent(info['partition']._id)).value();
    }), _defineProperty(_pgBrowser$Node$exten, 'canDrop', pgBrowser.Nodes['schema'].canChildDrop), _defineProperty(_pgBrowser$Node$exten, 'canDropCascade', pgBrowser.Nodes['schema'].canChildDrop), _defineProperty(_pgBrowser$Node$exten, 'callbacks', {
      /* Enable trigger(s) on table */
      enable_triggers_on_table: function enable_triggers_on_table(args) {
        var params = { 'enable': true };
        this.callbacks.set_triggers.apply(this, [args, params]);
      },
      /* Disable trigger(s) on table */
      disable_triggers_on_table: function disable_triggers_on_table(args) {
        var params = { 'enable': false };
        this.callbacks.set_triggers.apply(this, [args, params]);
      },
      set_triggers: function set_triggers(args, params) {
        // This function will send request to enable or
        // disable triggers on table level
        var input = args || {},
            obj = this,
            t = pgBrowser.tree,
            i = input.item || t.selected(),
            d = i && i.length == 1 ? t.itemData(i) : undefined;

        if (!d) return false;

        $.ajax({
          url: obj.generate_url(i, 'set_trigger', d, true),
          type: 'PUT',
          data: params,
          dataType: "json",
          success: function success(res) {
            if (res.success == 1) {
              alertify.success(res.info);
              t.unload(i);
              t.setInode(i);
              t.deselect(i);
              setTimeout(function () {
                t.select(i);
              }, 10);
            }
          },
          error: function error(xhr, status, _error) {
            try {
              var err = $.parseJSON(xhr.responseText);
              if (err.success == 0) {
                alertify.error(err.errormsg);
              }
            } catch (e) {}
            t.unload(i);
          }
        });
      },
      /* Truncate table */
      truncate_table: function truncate_table(args) {
        var params = { 'cascade': false };
        this.callbacks.truncate.apply(this, [args, params]);
      },
      /* Truncate table with cascade */
      truncate_table_cascade: function truncate_table_cascade(args) {
        var params = { 'cascade': true };
        this.callbacks.truncate.apply(this, [args, params]);
      },
      truncate: function truncate(args, params) {
        var input = args || {},
            obj = this,
            t = pgBrowser.tree,
            i = input.item || t.selected(),
            d = i && i.length == 1 ? t.itemData(i) : undefined;

        if (!d) return false;

        alertify.confirm(gettext('Truncate Table'), S(gettext('Are you sure you want to truncate table %s?')).sprintf(d.label).value(), function (e) {
          if (e) {
            var data = d;
            $.ajax({
              url: obj.generate_url(i, 'truncate', d, true),
              type: 'PUT',
              data: params,
              dataType: "json",
              success: function success(res) {
                if (res.success == 1) {
                  alertify.success(res.info);
                  t.removeIcon(i);
                  data.icon = 'icon-partition';
                  t.addIcon(i, { icon: data.icon });
                  t.unload(i);
                  t.setInode(i);
                  t.deselect(i);
                  // Fetch updated data from server
                  setTimeout(function () {
                    t.select(i);
                  }, 10);
                }
              },
              error: function error(xhr, status, _error2) {
                try {
                  var err = $.parseJSON(xhr.responseText);
                  if (err.success == 0) {
                    alertify.error(err.errormsg);
                  }
                } catch (e) {}
                t.unload(i);
              }
            });
          }
        }, function () {});
      },
      reset_table_stats: function reset_table_stats(args) {
        var input = args || {},
            obj = this,
            t = pgBrowser.tree,
            i = input.item || t.selected(),
            d = i && i.length == 1 ? t.itemData(i) : undefined;

        if (!d) return false;

        alertify.confirm(gettext('Reset statistics'), S(gettext('Are you sure you want to reset the statistics for table %s?')).sprintf(d._label).value(), function (e) {
          if (e) {
            var data = d;
            $.ajax({
              url: obj.generate_url(i, 'reset', d, true),
              type: 'DELETE',
              success: function success(res) {
                if (res.success == 1) {
                  alertify.success(res.info);
                  t.removeIcon(i);
                  data.icon = 'icon-partition';
                  t.addIcon(i, { icon: data.icon });
                  t.unload(i);
                  t.setInode(i);
                  t.deselect(i);
                  // Fetch updated data from server
                  setTimeout(function () {
                    t.select(i);
                  }, 10);
                }
              },
              error: function error(xhr, status, _error3) {
                try {
                  var err = $.parseJSON(xhr.responseText);
                  if (err.success == 0) {
                    alertify.error(err.errormsg);
                  }
                } catch (e) {}
                t.unload(i);
              }
            });
          }
        }, function () {});
      },
      detach_partition: function detach_partition(args) {
        var input = args || {},
            obj = this,
            t = pgBrowser.tree,
            i = input.item || t.selected(),
            d = i && i.length == 1 ? t.itemData(i) : undefined;

        if (!d) return false;

        alertify.confirm(gettext('Detach Partition'), S(gettext('Are you sure you want to detach the partition %s?')).sprintf(d._label).value(), function (e) {
          if (e) {
            var data = d;
            $.ajax({
              url: obj.generate_url(i, 'detach', d, true),
              type: 'PUT',
              success: function success(res) {
                if (res.success == 1) {
                  alertify.success(res.info);
                  var n = t.next(i);
                  if (!n || !n.length) {
                    n = t.prev(i);
                    if (!n || !n.length) {
                      n = t.parent(i);
                      t.setInode(n, true);
                    }
                  }
                  t.remove(i);
                  if (n.length) {
                    t.select(n);
                  }
                }
              },
              error: function error(xhr, status, _error4) {
                try {
                  var err = $.parseJSON(xhr.responseText);
                  if (err.success == 0) {
                    alertify.error(err.errormsg);
                  }
                } catch (e) {}
              }
            });
          }
        }, function () {});
      }
    }), _defineProperty(_pgBrowser$Node$exten, 'model', pgBrowser.Node.Model.extend({
      defaults: {
        name: undefined,
        oid: undefined,
        spcoid: undefined,
        spcname: undefined,
        relowner: undefined,
        relacl: undefined,
        relhasoids: undefined,
        relhassubclass: undefined,
        reltuples: undefined,
        description: undefined,
        conname: undefined,
        conkey: undefined,
        isrepl: undefined,
        triggercount: undefined,
        relpersistence: undefined,
        fillfactor: undefined,
        reloftype: undefined,
        typname: undefined,
        labels: undefined,
        providers: undefined,
        is_sys_table: undefined,
        coll_inherits: [],
        hastoasttable: true,
        toast_autovacuum_enabled: false,
        autovacuum_enabled: false,
        primary_key: [],
        partitions: [],
        partition_type: 'range',
        is_partitioned: false,
        partition_value: undefined
      },
      // Default values!
      initialize: function initialize(attrs, args) {
        var self = this;

        if (_.size(attrs) === 0) {
          var userInfo = pgBrowser.serverInfo[args.node_info.server._id].user,
              schemaInfo = args.node_info.schema;

          this.set({
            'relowner': userInfo.name, 'schema': schemaInfo._label
          }, { silent: true });
        }
        pgBrowser.Node.Model.prototype.initialize.apply(this, arguments);
      },
      schema: [{
        id: 'name', label: gettext('Name'), type: 'text',
        mode: ['properties', 'create', 'edit'], disabled: 'inSchema'
      }, {
        id: 'oid', label: gettext('OID'), type: 'text', mode: ['properties']
      }, {
        id: 'relowner', label: gettext('Owner'), type: 'text', node: 'role',
        mode: ['properties', 'create', 'edit'], select2: { allowClear: false },
        disabled: 'inSchema', control: 'node-list-by-name'
      }, {
        id: 'schema', label: gettext('Schema'), type: 'text', node: 'schema',
        control: 'node-list-by-name', mode: ['create', 'edit', 'properties'],
        disabled: 'inSchema', filter: function filter(d) {
          // If schema name start with pg_* then we need to exclude them
          if (d && d.label.match(/^pg_/)) {
            return false;
          }
          return true;
        }, cache_node: 'database', cache_level: 'database'
      }, {
        id: 'spcname', label: gettext('Tablespace'), node: 'tablespace',
        type: 'text', control: 'node-list-by-name', disabled: 'inSchema',
        mode: ['properties', 'create', 'edit'],
        filter: function filter(d) {
          // If tablespace name is not "pg_global" then we need to exclude them
          return !(d && d.label.match(/pg_global/));
        }
      }, {
        id: 'partition', type: 'group', label: gettext('Partition'),
        mode: ['edit', 'create'], min_version: 100000,
        visible: function visible(m) {
          // Always show in case of create mode
          if (m.isNew() || m.get('is_partitioned')) return true;
          return false;
        }
      }, {
        id: 'is_partitioned', label: gettext('Partitioned Table?'), cell: 'switch',
        type: 'switch', mode: ['properties', 'create', 'edit'],
        visible: function visible(m) {
          if (!_.isUndefined(m.node_info) && !_.isUndefined(m.node_info.server) && !_.isUndefined(m.node_info.server.version) && m.node_info.server.version >= 100000) return true;

          return false;
        },
        disabled: function disabled(m) {
          if (!m.isNew()) return true;
          return false;
        }
      }, {
        id: 'description', label: gettext('Comment'), type: 'multiline',
        mode: ['properties', 'create', 'edit'], disabled: 'inSchema'
      }, {
        id: 'partition_value', label: gettext('Partition Scheme'),
        type: 'text', visible: false
      }, {
        id: 'coll_inherits', label: gettext('Inherited from table(s)'),
        type: 'text', group: gettext('Advanced'), mode: ['properties']
      }, {
        id: 'Columns', type: 'group', label: gettext('Columns'),
        mode: ['edit', 'create'], min_version: 100000,
        visible: function visible(m) {
          // Always hide in case of partition table.
          return false;
        }
      }, {
        // Tab control for columns
        id: 'columns', label: gettext('Columns'), type: 'collection',
        group: gettext('Columns'),
        model: pgBrowser.Nodes['column'].model,
        subnode: pgBrowser.Nodes['column'].model,
        mode: ['create', 'edit'],
        disabled: function disabled(m) {
          // In case of partitioned table remove inherited columns
          if (m.isNew() && m.get('is_partitioned')) {
            setTimeout(function () {
              var coll = m.get('columns');
              coll.remove(coll.filter(function (model) {
                if (_.isUndefined(model.get('inheritedfrom'))) return false;
                return true;
              }));
            }, 10);
          }

          if (this.node_info && 'catalog' in this.node_info) {
            return true;
          }
          return false;
        },
        deps: ['typname', 'is_partitioned'],
        canAdd: 'check_grid_add_condition',
        canEdit: true, canDelete: true,
        // For each row edit/delete button enable/disable
        canEditRow: 'check_grid_row_edit_delete',
        canDeleteRow: 'check_grid_row_edit_delete',
        uniqueCol: ['name'],
        columns: ['name', 'cltype', 'attlen', 'attprecision', 'attnotnull', 'is_primary_key'],
        control: Backform.UniqueColCollectionControl.extend({
          initialize: function initialize() {
            Backform.UniqueColCollectionControl.prototype.initialize.apply(this, arguments);
            var self = this,
                collection = self.model.get(self.field.get('name'));

            collection.on("change:is_primary_key", function (m) {
              var primary_key_coll = self.model.get('primary_key'),
                  column_name = m.get('name'),
                  primary_key;

              if (m.get('is_primary_key')) {
                // Add column to primary key.
                if (primary_key_coll.length < 1) {
                  primary_key = new primary_key_coll.model({}, {
                    top: self.model,
                    collection: primary_key_coll,
                    handler: primary_key_coll
                  });
                  primary_key_coll.add(primary_key);
                } else {
                  primary_key = primary_key_coll.first();
                }
                // Do not alter existing primary key columns.
                if (_.isUndefined(primary_key.get('oid'))) {
                  var primary_key_column_coll = primary_key.get('columns'),
                      primary_key_column_exist = primary_key_column_coll.where({ column: column_name });

                  if (primary_key_column_exist.length == 0) {
                    var primary_key_column = new primary_key_column_coll.model({ column: column_name }, { silent: true,
                      top: self.model,
                      collection: primary_key_coll,
                      handler: primary_key_coll
                    });

                    primary_key_column_coll.add(primary_key_column);
                  }

                  primary_key_column_coll.trigger('pgadmin:multicolumn:updated', primary_key_column_coll);
                }
              } else {
                // remove column from primary key.
                if (primary_key_coll.length > 0) {
                  var primary_key = primary_key_coll.first();
                  // Do not alter existing primary key columns.
                  if (!_.isUndefined(primary_key.get('oid'))) {
                    return;
                  }

                  var primary_key_column_coll = primary_key.get('columns'),
                      removedCols = primary_key_column_coll.where({ column: column_name });
                  if (removedCols.length > 0) {
                    primary_key_column_coll.remove(removedCols);
                    _.each(removedCols, function (m) {
                      m.destroy();
                    });
                    if (primary_key_column_coll.length == 0) {
                      setTimeout(function () {
                        // There will be only on primary key so remove the first one.
                        primary_key_coll.remove(primary_key_coll.first());
                        /* Ideally above line of code should be "primary_key_coll.reset()".
                         * But our custom DataCollection (extended from Backbone collection in datamodel.js)
                         * does not respond to reset event, it only supports add, remove, change events.
                         * And hence no custom event listeners/validators get called for reset event.
                         */
                      }, 10);
                    }
                  }
                  primary_key_column_coll.trigger('pgadmin:multicolumn:updated', primary_key_column_coll);
                }
              }
            });
          },
          remove: function remove() {
            var collection = this.model.get(this.field.get('name'));
            if (collection) {
              collection.off("change:is_primary_key");
            }

            Backform.UniqueColCollectionControl.prototype.remove.apply(this, arguments);
          }
        }),
        allowMultipleEmptyRow: false
      }, {
        id: 'inherited_tables_cnt', label: gettext('Inherited tables count'),
        type: 'text', mode: ['properties'], group: gettext('Advanced'),
        disabled: 'inSchema'
      }, {
        // Here we will create tab control for constraints
        type: 'nested', control: 'tab', group: gettext('Constraints'),
        mode: ['edit', 'create'],
        schema: [{
          id: 'primary_key', label: gettext('Primary key'),
          model: pgBrowser.Nodes['primary_key'].model,
          subnode: pgBrowser.Nodes['primary_key'].model,
          editable: false, type: 'collection',
          group: gettext('Primary Key'), mode: ['edit', 'create'],
          canEdit: true, canDelete: true, deps: ['is_partitioned'],
          control: 'unique-col-collection',
          columns: ['name', 'columns'],
          canAdd: function canAdd(m) {
            if (m.get('is_partitioned')) {
              setTimeout(function () {
                var coll = m.get('primary_key');
                coll.remove(coll.filter(function (model) {
                  return true;
                }));
              }, 10);
              return false;
            }

            return true;
          },
          canAddRow: function canAddRow(m) {
            // User can only add one primary key
            var columns = m.get('columns');

            return m.get('primary_key') && m.get('primary_key').length < 1 && _.some(columns.pluck('name'));
          }
        }, {
          id: 'foreign_key', label: gettext('Foreign key'),
          model: pgBrowser.Nodes['foreign_key'].model,
          subnode: pgBrowser.Nodes['foreign_key'].model,
          editable: false, type: 'collection',
          group: gettext('Foreign Key'), mode: ['edit', 'create'],
          canEdit: true, canDelete: true, deps: ['is_partitioned'],
          control: 'unique-col-collection',
          canAdd: function canAdd(m) {
            if (m.get('is_partitioned')) {
              setTimeout(function () {
                var coll = m.get('foreign_key');
                coll.remove(coll.filter(function (model) {
                  return true;
                }));
              }, 10);
              return false;
            }

            return true;
          },
          columns: ['name', 'columns'],
          canAddRow: function canAddRow(m) {
            // User can only add if there is at least one column with name.
            var columns = m.get('columns');
            return _.some(columns.pluck('name'));
          }
        }, {
          id: 'check_constraint', label: gettext('Check constraint'),
          model: pgBrowser.Nodes['check_constraints'].model,
          subnode: pgBrowser.Nodes['check_constraints'].model,
          editable: false, type: 'collection',
          group: gettext('Check'), mode: ['edit', 'create'],
          canEdit: true, canDelete: true, deps: ['is_partitioned'],
          control: 'unique-col-collection',
          canAdd: true,
          columns: ['name', 'consrc']
        }, {
          id: 'unique_constraint', label: gettext('Unique Constraint'),
          model: pgBrowser.Nodes['unique_constraint'].model,
          subnode: pgBrowser.Nodes['unique_constraint'].model,
          editable: false, type: 'collection',
          group: gettext('Unique'), mode: ['edit', 'create'],
          canEdit: true, canDelete: true, deps: ['is_partitioned'],
          control: 'unique-col-collection',
          columns: ['name', 'columns'],
          canAdd: function canAdd(m) {
            if (m.get('is_partitioned')) {
              setTimeout(function () {
                var coll = m.get('unique_constraint');
                coll.remove(coll.filter(function (model) {
                  return true;
                }));
              }, 10);
              return false;
            }

            return true;
          },
          canAddRow: function canAddRow(m) {
            // User can only add if there is at least one column with name.
            var columns = m.get('columns');
            return _.some(columns.pluck('name'));
          }
        }, {
          id: 'exclude_constraint', label: gettext('Exclude constraint'),
          model: pgBrowser.Nodes['exclusion_constraint'].model,
          subnode: pgBrowser.Nodes['exclusion_constraint'].model,
          editable: false, type: 'collection',
          group: gettext('Exclude'), mode: ['edit', 'create'],
          canEdit: true, canDelete: true, deps: ['is_partitioned'],
          control: 'unique-col-collection',
          columns: ['name', 'columns', 'constraint'],
          canAdd: function canAdd(m) {
            if (m.get('is_partitioned')) {
              setTimeout(function () {
                var coll = m.get('exclude_constraint');
                coll.remove(coll.filter(function (model) {
                  return true;
                }));
              }, 10);
              return false;
            }

            return true;
          },
          canAddRow: function canAddRow(m) {
            // User can only add if there is at least one column with name.
            var columns = m.get('columns');
            return _.some(columns.pluck('name'));
          }
        }]
      }, _defineProperty({
        id: 'typname', label: gettext('Of type'), type: 'text',
        control: 'node-ajax-options', mode: ['properties', 'create', 'edit'],
        disabled: 'checkOfType', url: 'get_oftype', group: gettext('Advanced'),
        deps: ['coll_inherits', 'is_partitioned'], transform: function transform(data, cell) {
          var control = cell || this,
              m = control.model;
          m.of_types_tables = data;
          return data;
        }
      }, 'control', Backform.NodeAjaxOptionsControl.extend({
        // When of_types changes we need to clear columns collection
        onChange: function onChange() {
          Backform.NodeAjaxOptionsControl.prototype.onChange.apply(this, arguments);
          var self = this,
              tbl_oid = undefined,
              tbl_name = self.model.get('typname'),
              data = undefined,
              arg = undefined,
              column_collection = self.model.get('columns');

          if (!_.isUndefined(tbl_name) && tbl_name !== '' && column_collection.length !== 0) {
            var msg = gettext('Changing of type table will clear columns collection');
            alertify.confirm(msg, function (e) {
              if (e) {
                // User clicks Ok, lets clear columns collection
                column_collection.reset();
              } else {
                return this;
              }
            });
          } else if (!_.isUndefined(tbl_name) && tbl_name === '') {
            column_collection.reset();
          }

          // Run Ajax now to fetch columns
          if (!_.isUndefined(tbl_name) && tbl_name !== '') {
            arg = { 'tname': tbl_name };
            data = self.model.fetch_columns_ajax.apply(self, [arg]);
            // Add into column collection
            column_collection.set(data, { merge: false, remove: false });
          }
        }
      })), {
        id: 'fillfactor', label: gettext('Fill factor'), type: 'int',
        mode: ['create', 'edit'], min: 10, max: 100,
        disabled: 'inSchema', group: gettext('Advanced')
      }, {
        id: 'relhasoids', label: gettext('Has OIDs?'), cell: 'switch',
        type: 'switch', mode: ['properties', 'create', 'edit'],
        disabled: 'inSchema', group: gettext('Advanced')
      }, {
        id: 'relpersistence', label: gettext('Unlogged?'), cell: 'switch',
        type: 'switch', mode: ['properties', 'create', 'edit'],
        disabled: 'inSchemaWithModelCheck',
        group: gettext('Advanced')
      }, {
        id: 'conname', label: gettext('Primary key'), cell: 'string',
        type: 'text', mode: ['properties'], group: gettext('Advanced'),
        disabled: 'inSchema'
      }, {
        id: 'reltuples', label: gettext('Rows (estimated)'), cell: 'string',
        type: 'text', mode: ['properties'], group: gettext('Advanced'),
        disabled: 'inSchema'
      }, {
        id: 'rows_cnt', label: gettext('Rows (counted)'), cell: 'string',
        type: 'text', mode: ['properties'], group: gettext('Advanced'),
        disabled: 'inSchema'
      }, {
        id: 'relhassubclass', label: gettext('Inherits tables?'), cell: 'switch',
        type: 'switch', mode: ['properties'], group: gettext('Advanced'),
        disabled: 'inSchema'
      }, {
        id: 'is_sys_table', label: gettext('System table?'), cell: 'switch',
        type: 'switch', mode: ['properties'],
        disabled: 'inSchema'
      }, {
        type: 'nested', control: 'fieldset', label: gettext('Like'),
        group: gettext('Advanced'),
        schema: [{
          id: 'like_relation', label: gettext('Relation'),
          type: 'text', mode: ['create', 'edit'], deps: ['typname'],
          control: 'node-ajax-options', url: 'get_relations',
          disabled: 'isLikeDisable', group: gettext('Like')
        }, {
          id: 'like_default_value', label: gettext('With default values?'),
          type: 'switch', mode: ['create', 'edit'], deps: ['typname'],
          disabled: 'isLikeDisable', group: gettext('Like')
        }, {
          id: 'like_constraints', label: gettext('With constraints?'),
          type: 'switch', mode: ['create', 'edit'], deps: ['typname'],
          disabled: 'isLikeDisable', group: gettext('Like')
        }, {
          id: 'like_indexes', label: gettext('With indexes?'),
          type: 'switch', mode: ['create', 'edit'], deps: ['typname'],
          disabled: 'isLikeDisable', group: gettext('Like')
        }, {
          id: 'like_storage', label: gettext('With storage?'),
          type: 'switch', mode: ['create', 'edit'], deps: ['typname'],
          disabled: 'isLikeDisable', group: gettext('Like')
        }, {
          id: 'like_comments', label: gettext('With comments?'),
          type: 'switch', mode: ['create', 'edit'], deps: ['typname'],
          disabled: 'isLikeDisable', group: gettext('Like')
        }]
      }, {
        id: 'partition_type', label: gettext('Partition Type'),
        editable: false, type: 'select2', select2: { allowClear: false },
        group: 'partition', deps: ['is_partitioned'],
        options: [{
          label: 'Range', value: 'range'
        }, {
          label: 'List', value: 'list'
        }],
        mode: ['create'],
        visible: function visible(m) {
          if (!_.isUndefined(m.node_info) && !_.isUndefined(m.node_info.server) && !_.isUndefined(m.node_info.server.version) && m.node_info.server.version >= 100000) return true;

          return false;
        },
        disabled: function disabled(m) {
          if (!m.isNew() || !m.get('is_partitioned')) return true;
          return false;
        }
      }, {
        id: 'partition_keys', label: gettext('Partition Keys'),
        model: Backform.PartitionKeyModel,
        subnode: Backform.PartitionKeyModel,
        editable: true, type: 'collection',
        group: 'partition', mode: ['create'],
        deps: ['is_partitioned', 'partition_type'],
        canEdit: false, canDelete: true,
        control: 'sub-node-collection',
        canAdd: function canAdd(m) {
          if (m.isNew() && m.get('is_partitioned')) return true;
          return false;
        },
        canAddRow: function canAddRow(m) {
          var columns = m.get('columns');
          var max_row_count = 1000;

          if (m.get('partition_type') && m.get('partition_type') == 'list') max_row_count = 1;

          return m.get('partition_keys') && m.get('partition_keys').length < max_row_count && _.some(columns.pluck('name'));
        },
        visible: function visible(m) {
          if (!_.isUndefined(m.node_info) && !_.isUndefined(m.node_info.server) && !_.isUndefined(m.node_info.server.version) && m.node_info.server.version >= 100000) return true;

          return false;
        },
        disabled: function disabled(m) {
          if (m.get('partition_keys') && m.get('partition_keys').models.length > 0) {
            setTimeout(function () {
              var coll = m.get('partition_keys');
              coll.remove(coll.filter(function (model) {
                return true;
              }));
            }, 10);
          }
        }
      }, {
        id: 'partition_scheme', label: gettext('Partition Scheme'),
        type: 'note', group: 'partition', mode: ['edit'],
        visible: function visible(m) {
          if (!_.isUndefined(m.node_info) && !_.isUndefined(m.node_info.server) && !_.isUndefined(m.node_info.server.version) && m.node_info.server.version >= 100000) return true;

          return false;
        },
        disabled: function disabled(m) {
          if (!m.isNew()) {
            this.text = m.get('partition_scheme');
          }
        }
      }, {
        id: 'partitions', label: gettext('Partitions'),
        model: Backform.PartitionsModel,
        subnode: Backform.PartitionsModel,
        editable: true, type: 'collection',
        group: 'partition', mode: ['edit', 'create'],
        deps: ['is_partitioned', 'partition_type'],
        canEdit: false, canDelete: true,
        customDeleteTitle: gettext('Detach Partition'),
        customDeleteMsg: gettext('Are you sure you wish to detach this partition?'),
        columns: ['is_attach', 'partition_name', 'values_from', 'values_to', 'values_in'],
        control: Backform.SubNodeCollectionControl.extend({
          row: Backgrid.PartitionRow,
          initialize: function initialize() {
            Backform.SubNodeCollectionControl.prototype.initialize.apply(this, arguments);
            var self = this;
            if (!this.model.isNew()) {
              var node = this.field.get('schema_node'),
                  node_info = this.field.get('node_info');

              // Make ajax call to get the tables to be attached
              $.ajax({
                url: node.generate_url.apply(node, [null, 'get_attach_tables', this.field.get('node_data'), true, node_info]),

                type: 'GET',
                async: false,
                success: function success(res) {
                  if (res.success == 1) {
                    self.model.table_options = res.data;
                  } else {
                    alertify.alert('Error fetching tables to be attached', res.data.result);
                  }
                },
                error: function error(e) {
                  var errmsg = $.parseJSON(e.responseText);
                  alertify.alert('Error fetching tables to be attached.', errmsg.errormsg);
                }
              });
            }
          }
        }),
        canAdd: function canAdd(m) {
          if (m.get('is_partitioned')) return true;
          return false;
        },
        visible: function visible(m) {
          if (!_.isUndefined(m.node_info) && !_.isUndefined(m.node_info.server) && !_.isUndefined(m.node_info.server.version) && m.node_info.server.version >= 100000) return true;

          return false;
        },
        disabled: function disabled(m) {
          if (m.isNew() && m.get('partitions') && m.get('partitions').models.length > 0) {
            setTimeout(function () {
              var coll = m.get('partitions');
              coll.remove(coll.filter(function (model) {
                return true;
              }));
            }, 10);
          }
        }
      }, {
        id: 'partition_note', label: gettext('Partition'),
        type: 'note', group: 'partition',
        text: gettext('Above control will be used to Create/Attach/Detach partitions.<br>' + '<ul><li>Create Mode: User will be able to create N number of partitions. Mode switch control is disabled in this scenario.</li>' + '<li>Edit Mode: User will be able to create/attach/detach N number of partitions.' + 'In attach mode there will be list of suitable tables to be attached.</li></ul>'),
        visible: function visible(m) {
          if (!_.isUndefined(m.node_info) && !_.isUndefined(m.node_info.server) && !_.isUndefined(m.node_info.server.version) && m.node_info.server.version >= 100000) return true;

          return false;
        }
      }, {
        // Here - we will create tab control for storage parameters
        // (auto vacuum).
        type: 'nested', control: 'tab', group: gettext('Parameter'),
        mode: ['edit', 'create'], deps: ['is_partitioned'],
        schema: Backform.VacuumSettingsSchema
      }, {
        id: 'relacl_str', label: gettext('Privileges'), disabled: 'inSchema',
        type: 'text', mode: ['properties'], group: gettext('Security')
      }, pgBrowser.SecurityGroupSchema, {
        id: 'relacl', label: gettext('Privileges'), type: 'collection',
        group: 'security', control: 'unique-col-collection',
        model: pgBrowser.Node.PrivilegeRoleModel.extend({
          privileges: ['a', 'r', 'w', 'd', 'D', 'x', 't'] }),
        mode: ['edit', 'create'], canAdd: true, canDelete: true,
        uniqueCol: ['grantee']
      }, {
        id: 'seclabels', label: gettext('Security labels'), canEdit: false,
        model: pgBrowser.SecLabelModel, editable: false, canAdd: true,
        type: 'collection', min_version: 90100, mode: ['edit', 'create'],
        group: 'security', canDelete: true, control: 'unique-col-collection'
      }, {
        id: 'vacuum_settings_str', label: gettext('Storage settings'),
        type: 'multiline', group: gettext('Advanced'), mode: ['properties']
      }],
      validate: function validate(keys) {
        var err = {},
            changedAttrs = this.changed,
            msg = undefined,
            name = this.get('name'),
            schema = this.get('schema'),
            relowner = this.get('relowner'),
            is_partitioned = this.get('is_partitioned'),
            partition_keys = this.get('partition_keys');

        // If nothing to validate or VacuumSetting keys then
        // return from here
        if (keys && (keys.length == 0 || _.indexOf(keys, 'autovacuum_enabled') != -1 || _.indexOf(keys, 'toast_autovacuum_enabled') != -1)) {
          return null;
        }

        // Have to clear existing validation before initiating current state validation only
        this.errorModel.clear();

        if (_.isUndefined(name) || _.isNull(name) || String(name).replace(/^\s+|\s+$/g, '') == '') {
          msg = gettext('Table name cannot be empty.');
          this.errorModel.set('name', msg);
          return msg;
        } else if (_.isUndefined(schema) || _.isNull(schema) || String(schema).replace(/^\s+|\s+$/g, '') == '') {
          msg = gettext('Table schema cannot be empty.');
          this.errorModel.set('schema', msg);
          return msg;
        } else if (_.isUndefined(relowner) || _.isNull(relowner) || String(relowner).replace(/^\s+|\s+$/g, '') == '') {
          msg = gettext('Table owner cannot be empty.');
          this.errorModel.set('relowner', msg);
          return msg;
        } else if (is_partitioned && this.isNew() && !_.isNull(partition_keys) && partition_keys.length <= 0) {
          msg = gettext('Please specify at least one key for partitioned table.');
          this.errorModel.set('partition_keys', msg);
          return msg;
        }
        return null;
      },
      // We will disable everything if we are under catalog node
      inSchema: function inSchema() {
        if (this.node_info && 'catalog' in this.node_info) {
          return true;
        }
        return false;
      },
      isInheritedTable: function isInheritedTable(m) {
        if (!m.inSchema.apply(this, [m])) {
          if (!_.isUndefined(m.get('coll_inherits')) && m.get('coll_inherits').length != 0 || !_.isUndefined(m.get('typname')) && String(m.get('typname')).replace(/^\s+|\s+$/g, '') !== '') {
            // Either of_types or coll_inherits has value
            return false;
          } else {
            return true;
          }
        }
        return false;
      },
      // Oftype is defined?
      checkInheritance: function checkInheritance(m) {
        // Disabled if it is partitioned table
        if (m.get('is_partitioned')) {
          setTimeout(function () {
            m.set('coll_inherits', []);
          }, 10);
          return true;
        }

        // coll_inherits || typname
        if (!m.inSchema.apply(this, [m]) && (_.isUndefined(m.get('typname')) || _.isNull(m.get('typname')) || String(m.get('typname')).replace(/^\s+|\s+$/g, '') == '')) {
          return false;
        }
        return true;
      },
      // We will disable Like if ofType is defined
      isLikeDisable: function isLikeDisable(m) {
        if (!m.inSchemaWithModelCheck.apply(this, [m]) && (_.isUndefined(m.get('typname')) || _.isNull(m.get('typname')) || String(m.get('typname')).replace(/^\s+|\s+$/g, '') == '')) {
          return false;
        }
        return true;
      },
      // Check for column grid when to Add
      check_grid_add_condition: function check_grid_add_condition(m) {
        var enable_flag = true;
        if (!m.inSchema.apply(this, [m])) {
          // if of_type then disable add in grid
          if (!_.isUndefined(m.get('typname')) && !_.isNull(m.get('typname')) && m.get('typname') !== '') {
            enable_flag = false;
          }
        }
        return enable_flag;
      },
      // Check for column grid when to edit/delete (for each row)
      check_grid_row_edit_delete: function check_grid_row_edit_delete(m) {
        var flag = true;
        if (!_.isUndefined(m.get('inheritedfrom')) && !_.isNull(m.get('inheritedfrom')) && String(m.get('inheritedfrom')).replace(/^\s+|\s+$/g, '') !== '') {
          flag = false;
        }
        return flag;
      },
      // We will disable it if Inheritance is defined
      checkOfType: function checkOfType(m) {
        // Disabled if it is partitioned table
        if (m.get('is_partitioned')) {
          setTimeout(function () {
            m.set('typname', undefined);
          }, 10);
          return true;
        }

        //coll_inherits || typname
        if (!m.inSchemaWithModelCheck.apply(this, [m]) && (_.isUndefined(m.get('coll_inherits')) || _.isNull(m.get('coll_inherits')) || String(m.get('coll_inherits')).replace(/^\s+|\s+$/g, '') == '')) {
          return false;
        }
        return true;
      },
      // We will check if we are under schema node & in 'create' mode
      inSchemaWithModelCheck: function inSchemaWithModelCheck(m) {
        if (this.node_info && 'schema' in this.node_info) {
          // We will disbale control if it's in 'edit' mode
          if (m.isNew()) {
            return false;
          } else {
            return true;
          }
        }
        return true;
      },
      isTableAutoVacuumEnable: function isTableAutoVacuumEnable(m) {
        // We need to check additional condition to toggle enable/disable
        // for table auto-vacuum
        if (!m.inSchema.apply(this, [m]) && m.get('autovacuum_enabled') === true) {
          return false;
        }
        return true;
      },
      isToastTableAutoVacuumEnable: function isToastTableAutoVacuumEnable(m) {
        // We need to check additional condition to toggle enable/disable
        // for toast table auto-vacuum
        if (!m.inSchemaWithModelCheck.apply(this, [m]) && m.get('toast_autovacuum_enabled') == true) {
          return false;
        }
        return true;
      },
      fetch_columns_ajax: function fetch_columns_ajax(arg) {
        var self = this,
            url = 'get_columns',
            m = self.model.top || self.model,
            old_columns = _.clone(m.get('columns')),
            data = undefined,
            node = this.field.get('schema_node'),
            node_info = this.field.get('node_info'),
            full_url = node.generate_url.apply(node, [null, url, this.field.get('node_data'), this.field.get('url_with_id') || false, node_info]),
            cache_level = this.field.get('cache_level') || node.type,
            cache_node = this.field.get('cache_node');

        cache_node = cache_node && pgBrowser.Nodes['cache_node'] || node;

        m.trigger('pgadmin:view:fetching', m, self.field);
        // Fetching Columns data for the selected table.
        $.ajax({
          async: false,
          url: full_url,
          data: arg,
          success: function success(res) {
            data = cache_node.cache(url, node_info, cache_level, res.data);
          },
          error: function error() {
            m.trigger('pgadmin:view:fetch:error', m, self.field);
          }
        });
        m.trigger('pgadmin:view:fetched', m, self.field);
        data = data && data.data || [];
        return data;
      }
    })), _defineProperty(_pgBrowser$Node$exten, 'canCreate', function canCreate(itemData, item, data) {
      //If check is false then , we will allow create menu
      if (data && data.check == false) return true;

      var t = pgBrowser.tree,
          i = item,
          d = itemData;
      // To iterate over tree to check parent node
      while (i) {
        // If it is schema then allow user to create table
        if (_.indexOf(['schema'], d._type) > -1) return true;

        if ('coll-table' == d._type) {
          //Check if we are not child of catalog
          var prev_i = t.hasParent(i) ? t.parent(i) : null;
          var prev_d = prev_i ? t.itemData(prev_i) : null;
          if (prev_d._type == 'catalog') {
            return false;
          } else {
            return true;
          }
        }
        i = t.hasParent(i) ? t.parent(i) : null;
        d = i ? t.itemData(i) : null;
      }
      // by default we do not want to allow create menu
      return true;
    }), _defineProperty(_pgBrowser$Node$exten, 'canCreate_with_trigger_enable', function canCreate_with_trigger_enable(itemData, item, data) {
      if (this.canCreate.apply(this, [itemData, item, data])) {
        // We are here means we can create menu, now let's check condition
        if (itemData.tigger_count > 0) {
          return true;
        } else {
          return false;
        }
      }
    }), _defineProperty(_pgBrowser$Node$exten, 'canCreate_with_trigger_disable', function canCreate_with_trigger_disable(itemData, item, data) {
      if (this.canCreate.apply(this, [itemData, item, data])) {
        // We are here means we can create menu, now let's check condition
        if (itemData.tigger_count > 0 && itemData.has_enable_triggers > 0) {
          return true;
        } else {
          return false;
        }
      }
    }), _pgBrowser$Node$exten));
  }

  return pgBrowser.Nodes['partition'];
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ })
],[233])["default"]});;
//# sourceMappingURL=app.bundle.js.map